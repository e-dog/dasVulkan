#include "dasVulkan.h"

namespace das {

/* VOLK_GENERATE_WRAP_FUNC */
#if defined(VK_KHR_acceleration_structure)
#endif /* defined(VK_KHR_acceleration_structure) */
#if defined(VK_EXT_descriptor_buffer) && (defined(VK_KHR_acceleration_structure) || defined(VK_NV_ray_tracing))
#endif /* defined(VK_EXT_descriptor_buffer) && (defined(VK_KHR_acceleration_structure) || defined(VK_NV_ray_tracing)) */
#if defined(VK_KHR_acceleration_structure)
#endif /* defined(VK_KHR_acceleration_structure) */
#if defined(VK_NV_ray_tracing)
#endif /* defined(VK_NV_ray_tracing) */
#if defined(VK_KHR_acceleration_structure)
#endif /* defined(VK_KHR_acceleration_structure) */
#if defined(VK_NV_ray_tracing_motion_blur)
#endif /* defined(VK_NV_ray_tracing_motion_blur) */
#if defined(VK_NV_ray_tracing)
#endif /* defined(VK_NV_ray_tracing) */
#if defined(VK_NV_ray_tracing_motion_blur)
#endif /* defined(VK_NV_ray_tracing_motion_blur) */
#if defined(VK_EXT_opacity_micromap)
#endif /* defined(VK_EXT_opacity_micromap) */
#if defined(VK_NV_displacement_micromap)
#endif /* defined(VK_NV_displacement_micromap) */
#if defined(VK_EXT_opacity_micromap)
#endif /* defined(VK_EXT_opacity_micromap) */
#if defined(VK_KHR_acceleration_structure)
#endif /* defined(VK_KHR_acceleration_structure) */
#if (defined(VK_KHR_device_group) && defined(VK_KHR_swapchain)) || (defined(VK_KHR_swapchain) && defined(VK_VERSION_1_1))
#endif /* (defined(VK_KHR_device_group) && defined(VK_KHR_swapchain)) || (defined(VK_KHR_swapchain) && defined(VK_VERSION_1_1)) */
#if defined(VK_KHR_performance_query)
#endif /* defined(VK_KHR_performance_query) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_SEC_amigo_profiling)
#endif /* defined(VK_SEC_amigo_profiling) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_ANDROID_external_memory_android_hardware_buffer) && (defined(VK_KHR_format_feature_flags2) || defined(VK_VERSION_1_3))
#endif /* defined(VK_ANDROID_external_memory_android_hardware_buffer) && (defined(VK_KHR_format_feature_flags2) || defined(VK_VERSION_1_3)) */
#if defined(VK_ANDROID_external_memory_android_hardware_buffer)
#endif /* defined(VK_ANDROID_external_memory_android_hardware_buffer) */
#if defined(VK_ANDROID_external_format_resolve)
#endif /* defined(VK_ANDROID_external_format_resolve) */
#if defined(VK_ANDROID_external_memory_android_hardware_buffer)
#endif /* defined(VK_ANDROID_external_memory_android_hardware_buffer) */
#if defined(VK_KHR_android_surface)
#endif /* defined(VK_KHR_android_surface) */
#if defined(VK_AMD_anti_lag)
#endif /* defined(VK_AMD_anti_lag) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_VERSION_1_2)
#endif /* defined(VK_VERSION_1_2) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_VERSION_1_2)
#endif /* defined(VK_VERSION_1_2) */
#if defined(VK_AMD_mixed_attachment_samples) && (defined(VK_VERSION_1_3) || defined(VK_KHR_dynamic_rendering))
#endif /* defined(VK_AMD_mixed_attachment_samples) && (defined(VK_VERSION_1_3) || defined(VK_KHR_dynamic_rendering)) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_EXT_sample_locations)
#endif /* defined(VK_EXT_sample_locations) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_NV_ray_tracing)
#endif /* defined(VK_NV_ray_tracing) */
#if defined(VK_VERSION_1_1)
#endif /* defined(VK_VERSION_1_1) */
#if defined(VK_KHR_maintenance6) && defined(VK_EXT_descriptor_buffer)
#endif /* defined(VK_KHR_maintenance6) && defined(VK_EXT_descriptor_buffer) */
#if defined(VK_VERSION_1_4)
#endif /* defined(VK_VERSION_1_4) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_VERSION_1_1)
#endif /* defined(VK_VERSION_1_1) */
#if (defined(VK_KHR_device_group) && defined(VK_KHR_swapchain)) || (defined(VK_KHR_swapchain) && defined(VK_VERSION_1_1))
#endif /* (defined(VK_KHR_device_group) && defined(VK_KHR_swapchain)) || (defined(VK_KHR_swapchain) && defined(VK_VERSION_1_1)) */
#if defined(VK_VERSION_1_1)
#endif /* defined(VK_VERSION_1_1) */
#if defined(VK_EXT_device_generated_commands)
#endif /* defined(VK_EXT_device_generated_commands) */
#if defined(VK_NV_device_generated_commands)
#endif /* defined(VK_NV_device_generated_commands) */
#if defined(VK_VERSION_1_4)
#endif /* defined(VK_VERSION_1_4) */
#if defined(VK_NV_device_generated_commands_compute)
#endif /* defined(VK_NV_device_generated_commands_compute) */
#if defined(VK_NV_device_generated_commands)
#endif /* defined(VK_NV_device_generated_commands) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_EXT_device_generated_commands)
#endif /* defined(VK_EXT_device_generated_commands) */
#if defined(VK_NV_device_generated_commands)
#endif /* defined(VK_NV_device_generated_commands) */
#if defined(VK_KHR_video_queue)
#endif /* defined(VK_KHR_video_queue) */
#if defined(VK_QCOM_filter_cubic_weights)
#endif /* defined(VK_QCOM_filter_cubic_weights) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_VERSION_1_3)
#endif /* defined(VK_VERSION_1_3) */
#if defined(VK_EXT_descriptor_buffer)
#endif /* defined(VK_EXT_descriptor_buffer) */
#if defined(VK_FUCHSIA_buffer_collection)
#endif /* defined(VK_FUCHSIA_buffer_collection) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_FUCHSIA_buffer_collection)
#endif /* defined(VK_FUCHSIA_buffer_collection) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_VERSION_1_3)
#endif /* defined(VK_VERSION_1_3) */
#if defined(VK_EXT_buffer_device_address)
#endif /* defined(VK_EXT_buffer_device_address) */
#if defined(VK_VERSION_1_2)
#endif /* defined(VK_VERSION_1_2) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_VERSION_1_3)
#endif /* defined(VK_VERSION_1_3) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_VERSION_1_3)
#endif /* defined(VK_VERSION_1_3) */
#if defined(VK_VERSION_1_1)
#endif /* defined(VK_VERSION_1_1) */
#if defined(VK_VERSION_1_2)
#endif /* defined(VK_VERSION_1_2) */
#if defined(VK_VERSION_1_4)
#endif /* defined(VK_VERSION_1_4) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_KHR_calibrated_timestamps)
#endif /* defined(VK_KHR_calibrated_timestamps) */
#if defined(VK_NV_device_diagnostic_checkpoints) && (defined(VK_VERSION_1_3) || defined(VK_KHR_synchronization2))
#endif /* defined(VK_NV_device_diagnostic_checkpoints) && (defined(VK_VERSION_1_3) || defined(VK_KHR_synchronization2)) */
#if defined(VK_NV_device_diagnostic_checkpoints)
#endif /* defined(VK_NV_device_diagnostic_checkpoints) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_NV_shading_rate_image)
#endif /* defined(VK_NV_shading_rate_image) */
#if (defined(VK_EXT_extended_dynamic_state3)) || (defined(VK_EXT_shader_object))
#endif /* (defined(VK_EXT_extended_dynamic_state3)) || (defined(VK_EXT_shader_object)) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_EXT_conditional_rendering)
#endif /* defined(VK_EXT_conditional_rendering) */
#if defined(VK_QCOM_render_pass_transform)
#endif /* defined(VK_QCOM_render_pass_transform) */
#if defined(VK_VERSION_1_3)
#endif /* defined(VK_VERSION_1_3) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_NV_inherited_viewport_scissor)
#endif /* defined(VK_NV_inherited_viewport_scissor) */
#if defined(VK_VERSION_1_3)
#endif /* defined(VK_VERSION_1_3) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_NV_device_generated_commands_compute)
#endif /* defined(VK_NV_device_generated_commands_compute) */
#if defined(VK_EXT_conditional_rendering)
#endif /* defined(VK_EXT_conditional_rendering) */
#if defined(VK_VERSION_1_2)
#endif /* defined(VK_VERSION_1_2) */
#if defined(VK_NV_cooperative_matrix2)
#endif /* defined(VK_NV_cooperative_matrix2) */
#if defined(VK_KHR_cooperative_matrix)
#endif /* defined(VK_KHR_cooperative_matrix) */
#if defined(VK_NV_cooperative_matrix)
#endif /* defined(VK_NV_cooperative_matrix) */
#if defined(VK_KHR_acceleration_structure)
#endif /* defined(VK_KHR_acceleration_structure) */
#if defined(VK_VERSION_1_3)
#endif /* defined(VK_VERSION_1_3) */
#if defined(VK_QCOM_rotated_copy_commands)
#endif /* defined(VK_QCOM_rotated_copy_commands) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_VERSION_1_3)
#endif /* defined(VK_VERSION_1_3) */
#if defined(VK_VERSION_1_4)
#endif /* defined(VK_VERSION_1_4) */
#if defined(VK_NV_copy_memory_indirect)
#endif /* defined(VK_NV_copy_memory_indirect) */
#if defined(VK_KHR_acceleration_structure)
#endif /* defined(VK_KHR_acceleration_structure) */
#if defined(VK_NV_copy_memory_indirect)
#endif /* defined(VK_NV_copy_memory_indirect) */
#if defined(VK_VERSION_1_4)
#endif /* defined(VK_VERSION_1_4) */
#if defined(VK_EXT_opacity_micromap)
#endif /* defined(VK_EXT_opacity_micromap) */
#if defined(VK_NVX_binary_import)
#endif /* defined(VK_NVX_binary_import) */
#if defined(VK_NV_cuda_kernel_launch)
#endif /* defined(VK_NV_cuda_kernel_launch) */
#if defined(VK_KHR_external_semaphore_win32)
#endif /* defined(VK_KHR_external_semaphore_win32) */
#if defined(VK_EXT_debug_marker)
#endif /* defined(VK_EXT_debug_marker) */
#if defined(VK_EXT_debug_report)
#endif /* defined(VK_EXT_debug_report) */
#if defined(VK_EXT_debug_utils)
#endif /* defined(VK_EXT_debug_utils) */
#if defined(VK_NV_memory_decompression)
#endif /* defined(VK_NV_memory_decompression) */
#if defined(VK_NV_dedicated_allocation)
#endif /* defined(VK_NV_dedicated_allocation) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_VERSION_1_3)
#endif /* defined(VK_VERSION_1_3) */
#if defined(VK_EXT_depth_bias_control)
#endif /* defined(VK_EXT_depth_bias_control) */
#if defined(VK_EXT_depth_clamp_control)
#endif /* defined(VK_EXT_depth_clamp_control) */
#if defined(VK_EXT_descriptor_buffer)
#endif /* defined(VK_EXT_descriptor_buffer) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_EXT_descriptor_buffer)
#endif /* defined(VK_EXT_descriptor_buffer) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_VERSION_1_3)
#endif /* defined(VK_VERSION_1_3) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_VALVE_descriptor_set_host_mapping)
#endif /* defined(VK_VALVE_descriptor_set_host_mapping) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_VERSION_1_2)
#endif /* defined(VK_VERSION_1_2) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_VALVE_descriptor_set_host_mapping)
#endif /* defined(VK_VALVE_descriptor_set_host_mapping) */
#if defined(VK_VERSION_1_1)
#endif /* defined(VK_VERSION_1_1) */
#if defined(VK_VERSION_1_2)
#endif /* defined(VK_VERSION_1_2) */
#if defined(VK_VERSION_1_1)
#endif /* defined(VK_VERSION_1_1) */
#if defined(VK_EXT_device_address_binding_report)
#endif /* defined(VK_EXT_device_address_binding_report) */
#if defined(VK_VERSION_1_3)
#endif /* defined(VK_VERSION_1_3) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_EXT_device_memory_report)
#endif /* defined(VK_EXT_device_memory_report) */
#if defined(VK_NV_device_diagnostics_config)
#endif /* defined(VK_NV_device_diagnostics_config) */
#if defined(VK_EXT_display_control)
#endif /* defined(VK_EXT_display_control) */
#if defined(VK_EXT_device_fault)
#endif /* defined(VK_EXT_device_fault) */
#if defined(VK_VERSION_1_1)
#endif /* defined(VK_VERSION_1_1) */
#if (defined(VK_KHR_device_group) && defined(VK_KHR_surface)) || (defined(VK_KHR_swapchain) && defined(VK_VERSION_1_1))
#endif /* (defined(VK_KHR_device_group) && defined(VK_KHR_surface)) || (defined(VK_KHR_swapchain) && defined(VK_VERSION_1_1)) */
#if (defined(VK_KHR_device_group) && defined(VK_KHR_swapchain)) || (defined(VK_KHR_swapchain) && defined(VK_VERSION_1_1))
#endif /* (defined(VK_KHR_device_group) && defined(VK_KHR_swapchain)) || (defined(VK_KHR_swapchain) && defined(VK_VERSION_1_1)) */
#if defined(VK_VERSION_1_1)
#endif /* defined(VK_VERSION_1_1) */
#if (defined(VK_KHR_device_group) && defined(VK_KHR_swapchain)) || (defined(VK_KHR_swapchain) && defined(VK_VERSION_1_1))
#endif /* (defined(VK_KHR_device_group) && defined(VK_KHR_swapchain)) || (defined(VK_KHR_swapchain) && defined(VK_VERSION_1_1)) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_VERSION_1_3)
#endif /* defined(VK_VERSION_1_3) */
#if defined(VK_VERSION_1_4)
#endif /* defined(VK_VERSION_1_4) */
#if defined(VK_VERSION_1_2)
#endif /* defined(VK_VERSION_1_2) */
#if defined(VK_AMD_memory_overallocation_behavior)
#endif /* defined(VK_AMD_memory_overallocation_behavior) */
#if defined(VK_EXT_device_memory_report)
#endif /* defined(VK_EXT_device_memory_report) */
#if defined(VK_AMDX_shader_enqueue)
#endif /* defined(VK_AMDX_shader_enqueue) */
#if defined(VK_KHR_pipeline_binary)
#endif /* defined(VK_KHR_pipeline_binary) */
#if defined(VK_VERSION_1_3)
#endif /* defined(VK_VERSION_1_3) */
#if defined(VK_VERSION_1_4)
#endif /* defined(VK_VERSION_1_4) */
#if defined(VK_VERSION_1_1)
#endif /* defined(VK_VERSION_1_1) */
#if defined(VK_ARM_scheduling_controls)
#endif /* defined(VK_ARM_scheduling_controls) */
#if defined(VK_LUNARG_direct_driver_loading)
#endif /* defined(VK_LUNARG_direct_driver_loading) */
#if defined(VK_EXT_directfb_surface)
#endif /* defined(VK_EXT_directfb_surface) */
#if defined(VK_AMDX_shader_enqueue)
#endif /* defined(VK_AMDX_shader_enqueue) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_EXT_display_control)
#endif /* defined(VK_EXT_display_control) */
#if defined(VK_KHR_display)
#endif /* defined(VK_KHR_display) */
#if defined(VK_KHR_get_display_properties2)
#endif /* defined(VK_KHR_get_display_properties2) */
#if defined(VK_NV_display_stereo)
#endif /* defined(VK_NV_display_stereo) */
#if defined(VK_AMD_display_native_hdr)
#endif /* defined(VK_AMD_display_native_hdr) */
#if defined(VK_KHR_display)
#endif /* defined(VK_KHR_display) */
#if defined(VK_KHR_get_display_properties2)
#endif /* defined(VK_KHR_get_display_properties2) */
#if defined(VK_KHR_display)
#endif /* defined(VK_KHR_display) */
#if defined(VK_KHR_get_display_properties2)
#endif /* defined(VK_KHR_get_display_properties2) */
#if defined(VK_EXT_display_control)
#endif /* defined(VK_EXT_display_control) */
#if defined(VK_KHR_display_swapchain)
#endif /* defined(VK_KHR_display_swapchain) */
#if defined(VK_KHR_display)
#endif /* defined(VK_KHR_display) */
#if defined(VK_KHR_get_display_properties2)
#endif /* defined(VK_KHR_get_display_properties2) */
#if defined(VK_KHR_display)
#endif /* defined(VK_KHR_display) */
#if defined(VK_NV_display_stereo)
#endif /* defined(VK_NV_display_stereo) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_EXT_device_generated_commands)
#endif /* defined(VK_EXT_device_generated_commands) */
#if defined(VK_EXT_mesh_shader)
#endif /* defined(VK_EXT_mesh_shader) */
#if defined(VK_NV_mesh_shader)
#endif /* defined(VK_NV_mesh_shader) */
#if defined(VK_EXT_image_drm_format_modifier) && (defined(VK_KHR_format_feature_flags2) || defined(VK_VERSION_1_3))
#endif /* defined(VK_EXT_image_drm_format_modifier) && (defined(VK_KHR_format_feature_flags2) || defined(VK_VERSION_1_3)) */
#if defined(VK_EXT_image_drm_format_modifier)
#endif /* defined(VK_EXT_image_drm_format_modifier) */
#if defined(VK_EXT_image_drm_format_modifier) && (defined(VK_KHR_format_feature_flags2) || defined(VK_VERSION_1_3))
#endif /* defined(VK_EXT_image_drm_format_modifier) && (defined(VK_KHR_format_feature_flags2) || defined(VK_VERSION_1_3)) */
#if defined(VK_EXT_image_drm_format_modifier)
#endif /* defined(VK_EXT_image_drm_format_modifier) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_KHR_pipeline_library)
#endif /* defined(VK_KHR_pipeline_library) */
#if defined(VK_AMDX_shader_enqueue)
#endif /* defined(VK_AMDX_shader_enqueue) */
#if defined(VK_VERSION_1_1)
#endif /* defined(VK_VERSION_1_1) */
#if defined(VK_KHR_external_fence_win32)
#endif /* defined(VK_KHR_external_fence_win32) */
#if defined(VK_VERSION_1_1)
#endif /* defined(VK_VERSION_1_1) */
#if defined(VK_NV_external_memory)
#endif /* defined(VK_NV_external_memory) */
#if defined(VK_KHR_external_memory_win32)
#endif /* defined(VK_KHR_external_memory_win32) */
#if defined(VK_NV_external_memory_win32)
#endif /* defined(VK_NV_external_memory_win32) */
#if defined(VK_EXT_metal_objects)
#endif /* defined(VK_EXT_metal_objects) */
#if defined(VK_VERSION_1_1)
#endif /* defined(VK_VERSION_1_1) */
#if defined(VK_KHR_external_semaphore_win32)
#endif /* defined(VK_KHR_external_semaphore_win32) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_VERSION_1_1)
#endif /* defined(VK_VERSION_1_1) */
#if defined(VK_ANDROID_external_memory_android_hardware_buffer)
#endif /* defined(VK_ANDROID_external_memory_android_hardware_buffer) */
#if defined(VK_QNX_external_memory_screen_buffer)
#endif /* defined(VK_QNX_external_memory_screen_buffer) */
#if defined(VK_VERSION_1_1)
#endif /* defined(VK_VERSION_1_1) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_NV_external_memory_capabilities)
#endif /* defined(VK_NV_external_memory_capabilities) */
#if defined(VK_EXT_external_memory_acquire_unmodified)
#endif /* defined(VK_EXT_external_memory_acquire_unmodified) */
#if defined(VK_VERSION_1_1)
#endif /* defined(VK_VERSION_1_1) */
#if defined(VK_NV_external_memory)
#endif /* defined(VK_NV_external_memory) */
#if defined(VK_VERSION_1_1)
#endif /* defined(VK_VERSION_1_1) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_KHR_external_fence_fd)
#endif /* defined(VK_KHR_external_fence_fd) */
#if defined(VK_KHR_external_fence_win32)
#endif /* defined(VK_KHR_external_fence_win32) */
#if defined(VK_EXT_filter_cubic)
#endif /* defined(VK_EXT_filter_cubic) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_VERSION_1_1)
#endif /* defined(VK_VERSION_1_1) */
#if defined(VK_VERSION_1_3)
#endif /* defined(VK_VERSION_1_3) */
#if defined(VK_KHR_fragment_shading_rate)
#endif /* defined(VK_KHR_fragment_shading_rate) */
#if defined(VK_EXT_frame_boundary)
#endif /* defined(VK_EXT_frame_boundary) */
#if defined(VK_VERSION_1_2)
#endif /* defined(VK_VERSION_1_2) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_NV_coverage_reduction_mode)
#endif /* defined(VK_NV_coverage_reduction_mode) */
#if defined(VK_EXT_device_generated_commands)
#endif /* defined(VK_EXT_device_generated_commands) */
#if defined(VK_NV_device_generated_commands)
#endif /* defined(VK_NV_device_generated_commands) */
#if defined(VK_EXT_device_generated_commands)
#endif /* defined(VK_EXT_device_generated_commands) */
#if defined(VK_NV_device_generated_commands)
#endif /* defined(VK_NV_device_generated_commands) */
#if defined(VK_EXT_device_generated_commands)
#endif /* defined(VK_EXT_device_generated_commands) */
#if defined(VK_NV_low_latency2)
#endif /* defined(VK_NV_low_latency2) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_EXT_graphics_pipeline_library)
#endif /* defined(VK_EXT_graphics_pipeline_library) */
#if defined(VK_NV_device_generated_commands)
#endif /* defined(VK_NV_device_generated_commands) */
#if defined(VK_EXT_hdr_metadata)
#endif /* defined(VK_EXT_hdr_metadata) */
#if defined(VK_HUAWEI_hdr_vivid)
#endif /* defined(VK_HUAWEI_hdr_vivid) */
#if defined(VK_EXT_headless_surface)
#endif /* defined(VK_EXT_headless_surface) */
#if defined(VK_VERSION_1_4)
#endif /* defined(VK_VERSION_1_4) */
#if defined(VK_MVK_ios_surface)
#endif /* defined(VK_MVK_ios_surface) */
#if defined(VK_MESA_image_alignment_control)
#endif /* defined(VK_MESA_image_alignment_control) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_EXT_descriptor_buffer)
#endif /* defined(VK_EXT_descriptor_buffer) */
#if defined(VK_EXT_image_compression_control)
#endif /* defined(VK_EXT_image_compression_control) */
#if defined(VK_FUCHSIA_buffer_collection)
#endif /* defined(VK_FUCHSIA_buffer_collection) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_EXT_image_drm_format_modifier)
#endif /* defined(VK_EXT_image_drm_format_modifier) */
#if defined(VK_VERSION_1_2)
#endif /* defined(VK_VERSION_1_2) */
#if defined(VK_VERSION_1_1)
#endif /* defined(VK_VERSION_1_1) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_VERSION_1_1)
#endif /* defined(VK_VERSION_1_1) */
#if defined(VK_FUCHSIA_imagepipe_surface)
#endif /* defined(VK_FUCHSIA_imagepipe_surface) */
#if defined(VK_VERSION_1_1)
#endif /* defined(VK_VERSION_1_1) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_VERSION_1_3)
#endif /* defined(VK_VERSION_1_3) */
#if defined(VK_VERSION_1_1)
#endif /* defined(VK_VERSION_1_1) */
#if defined(VK_VERSION_1_2)
#endif /* defined(VK_VERSION_1_2) */
#if (defined(VK_KHR_device_group) && defined(VK_KHR_swapchain)) || (defined(VK_KHR_swapchain) && defined(VK_VERSION_1_1))
#endif /* (defined(VK_KHR_device_group) && defined(VK_KHR_swapchain)) || (defined(VK_KHR_swapchain) && defined(VK_VERSION_1_1)) */
#if defined(VK_EXT_astc_decode_mode)
#endif /* defined(VK_EXT_astc_decode_mode) */
#if defined(VK_NVX_image_view_handle)
#endif /* defined(VK_NVX_image_view_handle) */
#if defined(VK_EXT_descriptor_buffer)
#endif /* defined(VK_EXT_descriptor_buffer) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_NVX_image_view_handle)
#endif /* defined(VK_NVX_image_view_handle) */
#if defined(VK_EXT_image_view_min_lod)
#endif /* defined(VK_EXT_image_view_min_lod) */
#if defined(VK_QCOM_image_processing)
#endif /* defined(VK_QCOM_image_processing) */
#if defined(VK_EXT_image_sliced_view_of_3d)
#endif /* defined(VK_EXT_image_sliced_view_of_3d) */
#if defined(VK_VERSION_1_1)
#endif /* defined(VK_VERSION_1_1) */
#if defined(VK_ANDROID_external_memory_android_hardware_buffer)
#endif /* defined(VK_ANDROID_external_memory_android_hardware_buffer) */
#if defined(VK_KHR_external_fence_fd)
#endif /* defined(VK_KHR_external_fence_fd) */
#if defined(VK_KHR_external_fence_win32)
#endif /* defined(VK_KHR_external_fence_win32) */
#if defined(VK_FUCHSIA_buffer_collection)
#endif /* defined(VK_FUCHSIA_buffer_collection) */
#if defined(VK_KHR_external_memory_fd)
#endif /* defined(VK_KHR_external_memory_fd) */
#if defined(VK_EXT_external_memory_host)
#endif /* defined(VK_EXT_external_memory_host) */
#if defined(VK_KHR_external_memory_win32)
#endif /* defined(VK_KHR_external_memory_win32) */
#if defined(VK_NV_external_memory_win32)
#endif /* defined(VK_NV_external_memory_win32) */
#if defined(VK_FUCHSIA_external_memory)
#endif /* defined(VK_FUCHSIA_external_memory) */
#if defined(VK_EXT_metal_objects)
#endif /* defined(VK_EXT_metal_objects) */
#if defined(VK_QNX_external_memory_screen_buffer)
#endif /* defined(VK_QNX_external_memory_screen_buffer) */
#if defined(VK_KHR_external_semaphore_fd)
#endif /* defined(VK_KHR_external_semaphore_fd) */
#if defined(VK_KHR_external_semaphore_win32)
#endif /* defined(VK_KHR_external_semaphore_win32) */
#if defined(VK_FUCHSIA_external_semaphore)
#endif /* defined(VK_FUCHSIA_external_semaphore) */
#if defined(VK_EXT_device_generated_commands)
#endif /* defined(VK_EXT_device_generated_commands) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_EXT_device_generated_commands)
#endif /* defined(VK_EXT_device_generated_commands) */
#if defined(VK_NV_device_generated_commands)
#endif /* defined(VK_NV_device_generated_commands) */
#if defined(VK_EXT_device_generated_commands)
#endif /* defined(VK_EXT_device_generated_commands) */
#if defined(VK_INTEL_performance_query)
#endif /* defined(VK_INTEL_performance_query) */
#if defined(VK_VERSION_1_1)
#endif /* defined(VK_VERSION_1_1) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_NV_low_latency2)
#endif /* defined(VK_NV_low_latency2) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_EXT_layer_settings)
#endif /* defined(VK_EXT_layer_settings) */
#if defined(VK_MVK_macos_surface)
#endif /* defined(VK_MVK_macos_surface) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_VERSION_1_1)
#endif /* defined(VK_VERSION_1_1) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_VERSION_1_1)
#endif /* defined(VK_VERSION_1_1) */
#if defined(VK_KHR_external_memory_fd)
#endif /* defined(VK_KHR_external_memory_fd) */
#if defined(VK_ANDROID_external_memory_android_hardware_buffer)
#endif /* defined(VK_ANDROID_external_memory_android_hardware_buffer) */
#if defined(VK_KHR_external_memory_fd)
#endif /* defined(VK_KHR_external_memory_fd) */
#if defined(VK_NV_external_memory_rdma)
#endif /* defined(VK_NV_external_memory_rdma) */
#if defined(VK_KHR_external_memory_win32)
#endif /* defined(VK_KHR_external_memory_win32) */
#if defined(VK_FUCHSIA_external_memory)
#endif /* defined(VK_FUCHSIA_external_memory) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_EXT_external_memory_host)
#endif /* defined(VK_EXT_external_memory_host) */
#if defined(VK_VERSION_1_4)
#endif /* defined(VK_VERSION_1_4) */
#if defined(VK_EXT_map_memory_placed)
#endif /* defined(VK_EXT_map_memory_placed) */
#if defined(VK_VERSION_1_2)
#endif /* defined(VK_VERSION_1_2) */
#if defined(VK_EXT_memory_priority)
#endif /* defined(VK_EXT_memory_priority) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_VERSION_1_1)
#endif /* defined(VK_VERSION_1_1) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_VERSION_1_4)
#endif /* defined(VK_VERSION_1_4) */
#if defined(VK_KHR_external_memory_win32)
#endif /* defined(VK_KHR_external_memory_win32) */
#if defined(VK_FUCHSIA_external_memory)
#endif /* defined(VK_FUCHSIA_external_memory) */
#if defined(VK_EXT_metal_surface)
#endif /* defined(VK_EXT_metal_surface) */
#if defined(VK_EXT_opacity_micromap)
#endif /* defined(VK_EXT_opacity_micromap) */
#if defined(VK_EXT_multi_draw)
#endif /* defined(VK_EXT_multi_draw) */
#if defined(VK_EXT_sample_locations)
#endif /* defined(VK_EXT_sample_locations) */
#if defined(VK_EXT_multisampled_render_to_single_sampled)
#endif /* defined(VK_EXT_multisampled_render_to_single_sampled) */
#if defined(VK_NVX_multiview_per_view_attributes) && (defined(VK_VERSION_1_3) || defined(VK_KHR_dynamic_rendering))
#endif /* defined(VK_NVX_multiview_per_view_attributes) && (defined(VK_VERSION_1_3) || defined(VK_KHR_dynamic_rendering)) */
#if defined(VK_QCOM_multiview_per_view_render_areas)
#endif /* defined(VK_QCOM_multiview_per_view_render_areas) */
#if defined(VK_EXT_mutable_descriptor_type)
#endif /* defined(VK_EXT_mutable_descriptor_type) */
#if defined(VK_EXT_descriptor_buffer)
#endif /* defined(VK_EXT_descriptor_buffer) */
#if defined(VK_NV_optical_flow)
#endif /* defined(VK_NV_optical_flow) */
#if defined(VK_NV_low_latency2)
#endif /* defined(VK_NV_low_latency2) */
#if defined(VK_GOOGLE_display_timing)
#endif /* defined(VK_GOOGLE_display_timing) */
#if defined(VK_INTEL_performance_query)
#endif /* defined(VK_INTEL_performance_query) */
#if defined(VK_KHR_performance_query)
#endif /* defined(VK_KHR_performance_query) */
#if defined(VK_INTEL_performance_query)
#endif /* defined(VK_INTEL_performance_query) */
#if defined(VK_KHR_performance_query) && defined(VKSC_VERSION_1_0)
#endif /* defined(VK_KHR_performance_query) && defined(VKSC_VERSION_1_0) */
#if defined(VK_KHR_performance_query)
#endif /* defined(VK_KHR_performance_query) */
#if defined(VK_INTEL_performance_query)
#endif /* defined(VK_INTEL_performance_query) */
#if defined(VK_VERSION_1_1)
#endif /* defined(VK_VERSION_1_1) */
#if defined(VK_EXT_4444_formats)
#endif /* defined(VK_EXT_4444_formats) */
#if defined(VK_VERSION_1_2)
#endif /* defined(VK_VERSION_1_2) */
#if defined(VK_EXT_astc_decode_mode)
#endif /* defined(VK_EXT_astc_decode_mode) */
#if defined(VK_KHR_acceleration_structure)
#endif /* defined(VK_KHR_acceleration_structure) */
#if defined(VK_EXT_device_address_binding_report)
#endif /* defined(VK_EXT_device_address_binding_report) */
#if defined(VK_SEC_amigo_profiling)
#endif /* defined(VK_SEC_amigo_profiling) */
#if defined(VK_AMD_anti_lag)
#endif /* defined(VK_AMD_anti_lag) */
#if defined(VK_EXT_attachment_feedback_loop_dynamic_state)
#endif /* defined(VK_EXT_attachment_feedback_loop_dynamic_state) */
#if defined(VK_EXT_attachment_feedback_loop_layout)
#endif /* defined(VK_EXT_attachment_feedback_loop_layout) */
#if defined(VK_EXT_blend_operation_advanced)
#endif /* defined(VK_EXT_blend_operation_advanced) */
#if defined(VK_EXT_border_color_swizzle)
#endif /* defined(VK_EXT_border_color_swizzle) */
#if defined(VK_VERSION_1_2)
#endif /* defined(VK_VERSION_1_2) */
#if defined(VK_EXT_buffer_device_address)
#endif /* defined(VK_EXT_buffer_device_address) */
#if defined(VK_HUAWEI_cluster_culling_shader)
#endif /* defined(VK_HUAWEI_cluster_culling_shader) */
#if defined(VK_AMD_device_coherent_memory)
#endif /* defined(VK_AMD_device_coherent_memory) */
#if defined(VK_EXT_color_write_enable)
#endif /* defined(VK_EXT_color_write_enable) */
#if defined(VK_NV_command_buffer_inheritance)
#endif /* defined(VK_NV_command_buffer_inheritance) */
#if defined(VK_KHR_compute_shader_derivatives)
#endif /* defined(VK_KHR_compute_shader_derivatives) */
#if defined(VK_EXT_conditional_rendering)
#endif /* defined(VK_EXT_conditional_rendering) */
#if defined(VK_EXT_conservative_rasterization)
#endif /* defined(VK_EXT_conservative_rasterization) */
#if defined(VK_NV_cooperative_matrix2)
#endif /* defined(VK_NV_cooperative_matrix2) */
#if defined(VK_KHR_cooperative_matrix)
#endif /* defined(VK_KHR_cooperative_matrix) */
#if defined(VK_NV_cooperative_matrix)
#endif /* defined(VK_NV_cooperative_matrix) */
#if defined(VK_KHR_cooperative_matrix)
#endif /* defined(VK_KHR_cooperative_matrix) */
#if defined(VK_NV_cooperative_matrix)
#endif /* defined(VK_NV_cooperative_matrix) */
#if defined(VK_NV_copy_memory_indirect)
#endif /* defined(VK_NV_copy_memory_indirect) */
#if defined(VK_NV_corner_sampled_image)
#endif /* defined(VK_NV_corner_sampled_image) */
#if defined(VK_NV_coverage_reduction_mode)
#endif /* defined(VK_NV_coverage_reduction_mode) */
#if defined(VK_QCOM_filter_cubic_clamp)
#endif /* defined(VK_QCOM_filter_cubic_clamp) */
#if defined(VK_QCOM_filter_cubic_weights)
#endif /* defined(VK_QCOM_filter_cubic_weights) */
#if defined(VK_NV_cuda_kernel_launch)
#endif /* defined(VK_NV_cuda_kernel_launch) */
#if defined(VK_EXT_custom_border_color)
#endif /* defined(VK_EXT_custom_border_color) */
#if defined(VK_NV_dedicated_allocation_image_aliasing)
#endif /* defined(VK_NV_dedicated_allocation_image_aliasing) */
#if defined(VK_EXT_depth_bias_control)
#endif /* defined(VK_EXT_depth_bias_control) */
#if defined(VK_EXT_depth_clamp_control)
#endif /* defined(VK_EXT_depth_clamp_control) */
#if defined(VK_EXT_depth_clamp_zero_one)
#endif /* defined(VK_EXT_depth_clamp_zero_one) */
#if defined(VK_EXT_depth_clip_control)
#endif /* defined(VK_EXT_depth_clip_control) */
#if defined(VK_EXT_depth_clip_enable)
#endif /* defined(VK_EXT_depth_clip_enable) */
#if defined(VK_VERSION_1_2)
#endif /* defined(VK_VERSION_1_2) */
#if defined(VK_EXT_descriptor_buffer)
#endif /* defined(VK_EXT_descriptor_buffer) */
#if defined(VK_VERSION_1_2)
#endif /* defined(VK_VERSION_1_2) */
#if defined(VK_NV_descriptor_pool_overallocation)
#endif /* defined(VK_NV_descriptor_pool_overallocation) */
#if defined(VK_VALVE_descriptor_set_host_mapping)
#endif /* defined(VK_VALVE_descriptor_set_host_mapping) */
#if defined(VK_NV_device_generated_commands_compute)
#endif /* defined(VK_NV_device_generated_commands_compute) */
#if defined(VK_EXT_device_generated_commands)
#endif /* defined(VK_EXT_device_generated_commands) */
#if defined(VK_NV_device_generated_commands)
#endif /* defined(VK_NV_device_generated_commands) */
#if defined(VK_EXT_device_generated_commands)
#endif /* defined(VK_EXT_device_generated_commands) */
#if defined(VK_NV_device_generated_commands)
#endif /* defined(VK_NV_device_generated_commands) */
#if defined(VK_EXT_device_memory_report)
#endif /* defined(VK_EXT_device_memory_report) */
#if defined(VK_NV_device_diagnostics_config)
#endif /* defined(VK_NV_device_diagnostics_config) */
#if defined(VK_EXT_discard_rectangles)
#endif /* defined(VK_EXT_discard_rectangles) */
#if defined(VK_NV_displacement_micromap)
#endif /* defined(VK_NV_displacement_micromap) */
#if defined(VK_VERSION_1_2)
#endif /* defined(VK_VERSION_1_2) */
#if defined(VK_EXT_physical_device_drm)
#endif /* defined(VK_EXT_physical_device_drm) */
#if defined(VK_VERSION_1_3)
#endif /* defined(VK_VERSION_1_3) */
#if defined(VK_VERSION_1_4)
#endif /* defined(VK_VERSION_1_4) */
#if defined(VK_EXT_dynamic_rendering_unused_attachments)
#endif /* defined(VK_EXT_dynamic_rendering_unused_attachments) */
#if defined(VK_NV_scissor_exclusive)
#endif /* defined(VK_NV_scissor_exclusive) */
#if defined(VK_EXT_extended_dynamic_state2)
#endif /* defined(VK_EXT_extended_dynamic_state2) */
#if defined(VK_EXT_extended_dynamic_state3)
#endif /* defined(VK_EXT_extended_dynamic_state3) */
#if defined(VK_EXT_extended_dynamic_state)
#endif /* defined(VK_EXT_extended_dynamic_state) */
#if defined(VK_NV_extended_sparse_address_space)
#endif /* defined(VK_NV_extended_sparse_address_space) */
#if defined(VK_VERSION_1_1)
#endif /* defined(VK_VERSION_1_1) */
#if defined(VK_ANDROID_external_format_resolve)
#endif /* defined(VK_ANDROID_external_format_resolve) */
#if defined(VK_VERSION_1_1)
#endif /* defined(VK_VERSION_1_1) */
#if defined(VK_EXT_external_memory_host)
#endif /* defined(VK_EXT_external_memory_host) */
#if defined(VK_NV_external_memory_rdma)
#endif /* defined(VK_NV_external_memory_rdma) */
#if defined(VK_QNX_external_memory_screen_buffer)
#endif /* defined(VK_QNX_external_memory_screen_buffer) */
#if defined(VK_VERSION_1_1)
#endif /* defined(VK_VERSION_1_1) */
#if defined(VK_EXT_device_fault)
#endif /* defined(VK_EXT_device_fault) */
#if defined(VK_VERSION_1_1)
#endif /* defined(VK_VERSION_1_1) */
#if defined(VK_VERSION_1_2)
#endif /* defined(VK_VERSION_1_2) */
#if defined(VK_EXT_fragment_density_map2)
#endif /* defined(VK_EXT_fragment_density_map2) */
#if defined(VK_EXT_fragment_density_map)
#endif /* defined(VK_EXT_fragment_density_map) */
#if defined(VK_QCOM_fragment_density_map_offset)
#endif /* defined(VK_QCOM_fragment_density_map_offset) */
#if defined(VK_EXT_fragment_density_map)
#endif /* defined(VK_EXT_fragment_density_map) */
#if defined(VK_KHR_fragment_shader_barycentric)
#endif /* defined(VK_KHR_fragment_shader_barycentric) */
#if defined(VK_EXT_fragment_shader_interlock)
#endif /* defined(VK_EXT_fragment_shader_interlock) */
#if defined(VK_NV_fragment_shading_rate_enums)
#endif /* defined(VK_NV_fragment_shading_rate_enums) */
#if defined(VK_KHR_fragment_shading_rate)
#endif /* defined(VK_KHR_fragment_shading_rate) */
#if defined(VK_EXT_frame_boundary)
#endif /* defined(VK_EXT_frame_boundary) */
#if defined(VK_VERSION_1_4)
#endif /* defined(VK_VERSION_1_4) */
#if defined(VK_EXT_graphics_pipeline_library)
#endif /* defined(VK_EXT_graphics_pipeline_library) */
#if defined(VK_VERSION_1_1)
#endif /* defined(VK_VERSION_1_1) */
#if defined(VK_HUAWEI_hdr_vivid)
#endif /* defined(VK_HUAWEI_hdr_vivid) */
#if defined(VK_VERSION_1_4)
#endif /* defined(VK_VERSION_1_4) */
#if defined(VK_VERSION_1_2)
#endif /* defined(VK_VERSION_1_2) */
#if defined(VK_VERSION_1_1)
#endif /* defined(VK_VERSION_1_1) */
#if defined(VK_EXT_image_2d_view_of_3d)
#endif /* defined(VK_EXT_image_2d_view_of_3d) */
#if defined(VK_MESA_image_alignment_control)
#endif /* defined(VK_MESA_image_alignment_control) */
#if defined(VK_EXT_image_compression_control)
#endif /* defined(VK_EXT_image_compression_control) */
#if defined(VK_EXT_image_compression_control_swapchain)
#endif /* defined(VK_EXT_image_compression_control_swapchain) */
#if defined(VK_EXT_image_drm_format_modifier)
#endif /* defined(VK_EXT_image_drm_format_modifier) */
#if defined(VK_VERSION_1_1)
#endif /* defined(VK_VERSION_1_1) */
#if defined(VK_QCOM_image_processing2)
#endif /* defined(VK_QCOM_image_processing2) */
#if defined(VK_QCOM_image_processing)
#endif /* defined(VK_QCOM_image_processing) */
#if defined(VK_VERSION_1_3)
#endif /* defined(VK_VERSION_1_3) */
#if defined(VK_EXT_image_sliced_view_of_3d)
#endif /* defined(VK_EXT_image_sliced_view_of_3d) */
#if defined(VK_EXT_filter_cubic)
#endif /* defined(VK_EXT_filter_cubic) */
#if defined(VK_EXT_image_view_min_lod)
#endif /* defined(VK_EXT_image_view_min_lod) */
#if defined(VK_VERSION_1_2)
#endif /* defined(VK_VERSION_1_2) */
#if defined(VK_VERSION_1_4)
#endif /* defined(VK_VERSION_1_4) */
#if defined(VK_NV_inherited_viewport_scissor)
#endif /* defined(VK_NV_inherited_viewport_scissor) */
#if defined(VK_VERSION_1_3)
#endif /* defined(VK_VERSION_1_3) */
#if defined(VK_HUAWEI_invocation_mask)
#endif /* defined(VK_HUAWEI_invocation_mask) */
#if defined(VK_KHR_maintenance7)
#endif /* defined(VK_KHR_maintenance7) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_VERSION_1_1)
#endif /* defined(VK_VERSION_1_1) */
#if defined(VK_KHR_maintenance7)
#endif /* defined(VK_KHR_maintenance7) */
#if defined(VK_MSFT_layered_driver)
#endif /* defined(VK_MSFT_layered_driver) */
#if defined(VK_EXT_legacy_dithering)
#endif /* defined(VK_EXT_legacy_dithering) */
#if defined(VK_EXT_legacy_vertex_attributes)
#endif /* defined(VK_EXT_legacy_vertex_attributes) */
#if defined(VK_VERSION_1_4)
#endif /* defined(VK_VERSION_1_4) */
#if defined(VK_NV_linear_color_attachment)
#endif /* defined(VK_NV_linear_color_attachment) */
#if defined(VK_VERSION_1_1)
#endif /* defined(VK_VERSION_1_1) */
#if defined(VK_VERSION_1_3)
#endif /* defined(VK_VERSION_1_3) */
#if defined(VK_VERSION_1_4)
#endif /* defined(VK_VERSION_1_4) */
#if defined(VK_KHR_maintenance7)
#endif /* defined(VK_KHR_maintenance7) */
#if defined(VK_EXT_map_memory_placed)
#endif /* defined(VK_EXT_map_memory_placed) */
#if defined(VK_EXT_memory_budget)
#endif /* defined(VK_EXT_memory_budget) */
#if defined(VK_NV_memory_decompression)
#endif /* defined(VK_NV_memory_decompression) */
#if defined(VK_EXT_memory_priority)
#endif /* defined(VK_EXT_memory_priority) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_VERSION_1_1)
#endif /* defined(VK_VERSION_1_1) */
#if defined(VK_EXT_mesh_shader)
#endif /* defined(VK_EXT_mesh_shader) */
#if defined(VK_NV_mesh_shader)
#endif /* defined(VK_NV_mesh_shader) */
#if defined(VK_EXT_mesh_shader)
#endif /* defined(VK_EXT_mesh_shader) */
#if defined(VK_NV_mesh_shader)
#endif /* defined(VK_NV_mesh_shader) */
#if defined(VK_EXT_multi_draw)
#endif /* defined(VK_EXT_multi_draw) */
#if defined(VK_EXT_multisampled_render_to_single_sampled)
#endif /* defined(VK_EXT_multisampled_render_to_single_sampled) */
#if defined(VK_VERSION_1_1)
#endif /* defined(VK_VERSION_1_1) */
#if defined(VK_NVX_multiview_per_view_attributes)
#endif /* defined(VK_NVX_multiview_per_view_attributes) */
#if defined(VK_QCOM_multiview_per_view_render_areas)
#endif /* defined(VK_QCOM_multiview_per_view_render_areas) */
#if defined(VK_QCOM_multiview_per_view_viewports)
#endif /* defined(VK_QCOM_multiview_per_view_viewports) */
#if defined(VK_VERSION_1_1)
#endif /* defined(VK_VERSION_1_1) */
#if defined(VK_EXT_mutable_descriptor_type)
#endif /* defined(VK_EXT_mutable_descriptor_type) */
#if defined(VK_EXT_nested_command_buffer)
#endif /* defined(VK_EXT_nested_command_buffer) */
#if defined(VK_EXT_non_seamless_cube_map)
#endif /* defined(VK_EXT_non_seamless_cube_map) */
#if defined(VK_EXT_opacity_micromap)
#endif /* defined(VK_EXT_opacity_micromap) */
#if defined(VK_NV_optical_flow)
#endif /* defined(VK_NV_optical_flow) */
#if defined(VK_EXT_pci_bus_info)
#endif /* defined(VK_EXT_pci_bus_info) */
#if defined(VK_EXT_pageable_device_local_memory)
#endif /* defined(VK_EXT_pageable_device_local_memory) */
#if defined(VK_NV_per_stage_descriptor_set)
#endif /* defined(VK_NV_per_stage_descriptor_set) */
#if defined(VK_KHR_performance_query)
#endif /* defined(VK_KHR_performance_query) */
#if defined(VK_KHR_pipeline_binary)
#endif /* defined(VK_KHR_pipeline_binary) */
#if defined(VK_VERSION_1_3)
#endif /* defined(VK_VERSION_1_3) */
#if defined(VK_KHR_pipeline_executable_properties)
#endif /* defined(VK_KHR_pipeline_executable_properties) */
#if defined(VK_EXT_pipeline_library_group_handles)
#endif /* defined(VK_EXT_pipeline_library_group_handles) */
#if defined(VK_EXT_pipeline_properties)
#endif /* defined(VK_EXT_pipeline_properties) */
#if defined(VK_VERSION_1_4)
#endif /* defined(VK_VERSION_1_4) */
#if defined(VK_VERSION_1_1)
#endif /* defined(VK_VERSION_1_1) */
#if defined(VK_KHR_portability_subset)
#endif /* defined(VK_KHR_portability_subset) */
#if defined(VK_NV_present_barrier)
#endif /* defined(VK_NV_present_barrier) */
#if defined(VK_KHR_present_id)
#endif /* defined(VK_KHR_present_id) */
#if defined(VK_EXT_present_mode_fifo_latest_ready)
#endif /* defined(VK_EXT_present_mode_fifo_latest_ready) */
#if defined(VK_KHR_present_wait)
#endif /* defined(VK_KHR_present_wait) */
#if defined(VK_EXT_primitive_topology_list_restart)
#endif /* defined(VK_EXT_primitive_topology_list_restart) */
#if defined(VK_EXT_primitives_generated_query)
#endif /* defined(VK_EXT_primitives_generated_query) */
#if defined(VK_VERSION_1_3)
#endif /* defined(VK_VERSION_1_3) */
#if defined(VK_VERSION_1_1)
#endif /* defined(VK_VERSION_1_1) */
#if defined(VK_EXT_provoking_vertex)
#endif /* defined(VK_EXT_provoking_vertex) */
#if defined(VK_VERSION_1_4)
#endif /* defined(VK_VERSION_1_4) */
#if defined(VK_EXT_rgba10x6_formats)
#endif /* defined(VK_EXT_rgba10x6_formats) */
#if defined(VK_EXT_rasterization_order_attachment_access)
#endif /* defined(VK_EXT_rasterization_order_attachment_access) */
#if defined(VK_NV_raw_access_chains)
#endif /* defined(VK_NV_raw_access_chains) */
#if defined(VK_KHR_ray_query)
#endif /* defined(VK_KHR_ray_query) */
#if defined(VK_NV_ray_tracing_invocation_reorder)
#endif /* defined(VK_NV_ray_tracing_invocation_reorder) */
#if defined(VK_KHR_ray_tracing_maintenance1)
#endif /* defined(VK_KHR_ray_tracing_maintenance1) */
#if defined(VK_NV_ray_tracing_motion_blur)
#endif /* defined(VK_NV_ray_tracing_motion_blur) */
#if defined(VK_KHR_ray_tracing_pipeline)
#endif /* defined(VK_KHR_ray_tracing_pipeline) */
#if defined(VK_KHR_ray_tracing_position_fetch)
#endif /* defined(VK_KHR_ray_tracing_position_fetch) */
#if defined(VK_NV_ray_tracing)
#endif /* defined(VK_NV_ray_tracing) */
#if defined(VK_NV_ray_tracing_validation)
#endif /* defined(VK_NV_ray_tracing_validation) */
#if defined(VK_IMG_relaxed_line_rasterization)
#endif /* defined(VK_IMG_relaxed_line_rasterization) */
#if defined(VK_ARM_render_pass_striped)
#endif /* defined(VK_ARM_render_pass_striped) */
#if defined(VK_NV_representative_fragment_test)
#endif /* defined(VK_NV_representative_fragment_test) */
#if defined(VK_EXT_robustness2)
#endif /* defined(VK_EXT_robustness2) */
#if defined(VK_EXT_sample_locations)
#endif /* defined(VK_EXT_sample_locations) */
#if defined(VK_VERSION_1_2)
#endif /* defined(VK_VERSION_1_2) */
#if defined(VK_VERSION_1_1)
#endif /* defined(VK_VERSION_1_1) */
#if defined(VK_VERSION_1_2)
#endif /* defined(VK_VERSION_1_2) */
#if defined(VK_ARM_scheduling_controls)
#endif /* defined(VK_ARM_scheduling_controls) */
#if defined(VK_VERSION_1_2)
#endif /* defined(VK_VERSION_1_2) */
#if defined(VK_NV_shader_atomic_float16_vector)
#endif /* defined(VK_NV_shader_atomic_float16_vector) */
#if defined(VK_EXT_shader_atomic_float2)
#endif /* defined(VK_EXT_shader_atomic_float2) */
#if defined(VK_EXT_shader_atomic_float)
#endif /* defined(VK_EXT_shader_atomic_float) */
#if defined(VK_VERSION_1_2)
#endif /* defined(VK_VERSION_1_2) */
#if defined(VK_KHR_shader_clock)
#endif /* defined(VK_KHR_shader_clock) */
#if defined(VK_ARM_shader_core_builtins)
#endif /* defined(VK_ARM_shader_core_builtins) */
#if defined(VK_AMD_shader_core_properties2)
#endif /* defined(VK_AMD_shader_core_properties2) */
#if defined(VK_AMD_shader_core_properties)
#endif /* defined(VK_AMD_shader_core_properties) */
#if defined(VK_ARM_shader_core_properties)
#endif /* defined(VK_ARM_shader_core_properties) */
#if defined(VK_VERSION_1_3)
#endif /* defined(VK_VERSION_1_3) */
#if defined(VK_VERSION_1_1)
#endif /* defined(VK_VERSION_1_1) */
#if defined(VK_AMD_shader_early_and_late_fragment_tests)
#endif /* defined(VK_AMD_shader_early_and_late_fragment_tests) */
#if defined(VK_AMDX_shader_enqueue)
#endif /* defined(VK_AMDX_shader_enqueue) */
#if defined(VK_VERSION_1_4)
#endif /* defined(VK_VERSION_1_4) */
#if defined(VK_VERSION_1_2)
#endif /* defined(VK_VERSION_1_2) */
#if defined(VK_VERSION_1_4)
#endif /* defined(VK_VERSION_1_4) */
#if defined(VK_EXT_shader_image_atomic_int64)
#endif /* defined(VK_EXT_shader_image_atomic_int64) */
#if defined(VK_NV_shader_image_footprint)
#endif /* defined(VK_NV_shader_image_footprint) */
#if defined(VK_VERSION_1_3)
#endif /* defined(VK_VERSION_1_3) */
#if defined(VK_INTEL_shader_integer_functions2)
#endif /* defined(VK_INTEL_shader_integer_functions2) */
#if defined(VK_KHR_shader_maximal_reconvergence)
#endif /* defined(VK_KHR_shader_maximal_reconvergence) */
#if defined(VK_EXT_shader_module_identifier)
#endif /* defined(VK_EXT_shader_module_identifier) */
#if defined(VK_EXT_shader_object)
#endif /* defined(VK_EXT_shader_object) */
#if defined(VK_KHR_shader_quad_control)
#endif /* defined(VK_KHR_shader_quad_control) */
#if defined(VK_KHR_shader_relaxed_extended_instruction)
#endif /* defined(VK_KHR_shader_relaxed_extended_instruction) */
#if defined(VK_EXT_shader_replicated_composites)
#endif /* defined(VK_EXT_shader_replicated_composites) */
#if defined(VK_NV_shader_sm_builtins)
#endif /* defined(VK_NV_shader_sm_builtins) */
#if defined(VK_VERSION_1_2)
#endif /* defined(VK_VERSION_1_2) */
#if defined(VK_VERSION_1_4)
#endif /* defined(VK_VERSION_1_4) */
#if defined(VK_KHR_shader_subgroup_uniform_control_flow)
#endif /* defined(VK_KHR_shader_subgroup_uniform_control_flow) */
#if defined(VK_VERSION_1_3)
#endif /* defined(VK_VERSION_1_3) */
#if defined(VK_EXT_shader_tile_image)
#endif /* defined(VK_EXT_shader_tile_image) */
#if defined(VK_NV_shading_rate_image)
#endif /* defined(VK_NV_shading_rate_image) */
#if defined(VK_VERSION_1_1)
#endif /* defined(VK_VERSION_1_1) */
#if defined(VK_VERSION_1_3)
#endif /* defined(VK_VERSION_1_3) */
#if defined(VK_EXT_subpass_merge_feedback)
#endif /* defined(VK_EXT_subpass_merge_feedback) */
#if defined(VK_HUAWEI_subpass_shading)
#endif /* defined(VK_HUAWEI_subpass_shading) */
#if defined(VK_KHR_get_surface_capabilities2)
#endif /* defined(VK_KHR_get_surface_capabilities2) */
#if defined(VK_EXT_swapchain_maintenance1)
#endif /* defined(VK_EXT_swapchain_maintenance1) */
#if defined(VK_VERSION_1_3)
#endif /* defined(VK_VERSION_1_3) */
#if defined(VK_EXT_texel_buffer_alignment)
#endif /* defined(VK_EXT_texel_buffer_alignment) */
#if defined(VK_VERSION_1_3)
#endif /* defined(VK_VERSION_1_3) */
#if defined(VK_QCOM_tile_properties)
#endif /* defined(VK_QCOM_tile_properties) */
#if defined(VK_VERSION_1_2)
#endif /* defined(VK_VERSION_1_2) */
#if defined(VK_VERSION_1_3)
#endif /* defined(VK_VERSION_1_3) */
#if defined(VK_EXT_transform_feedback)
#endif /* defined(VK_EXT_transform_feedback) */
#if defined(VK_VERSION_1_2)
#endif /* defined(VK_VERSION_1_2) */
#if defined(VK_VERSION_1_1)
#endif /* defined(VK_VERSION_1_1) */
#if defined(VK_VERSION_1_4)
#endif /* defined(VK_VERSION_1_4) */
#if defined(VK_EXT_vertex_attribute_divisor)
#endif /* defined(VK_EXT_vertex_attribute_divisor) */
#if defined(VK_EXT_vertex_attribute_robustness)
#endif /* defined(VK_EXT_vertex_attribute_robustness) */
#if defined(VK_EXT_vertex_input_dynamic_state)
#endif /* defined(VK_EXT_vertex_input_dynamic_state) */
#if defined(VK_KHR_video_encode_av1)
#endif /* defined(VK_KHR_video_encode_av1) */
#if defined(VK_KHR_video_queue)
#endif /* defined(VK_KHR_video_queue) */
#if defined(VK_KHR_video_encode_queue)
#endif /* defined(VK_KHR_video_encode_queue) */
#if defined(VK_KHR_video_encode_quantization_map)
#endif /* defined(VK_KHR_video_encode_quantization_map) */
#if defined(VK_KHR_video_queue)
#endif /* defined(VK_KHR_video_queue) */
#if defined(VK_KHR_video_maintenance1)
#endif /* defined(VK_KHR_video_maintenance1) */
#if defined(VK_VERSION_1_2)
#endif /* defined(VK_VERSION_1_2) */
#if defined(VK_VERSION_1_3)
#endif /* defined(VK_VERSION_1_3) */
#if defined(VK_VERSION_1_4)
#endif /* defined(VK_VERSION_1_4) */
#if defined(VK_VERSION_1_2)
#endif /* defined(VK_VERSION_1_2) */
#if defined(VK_KHR_workgroup_memory_explicit_layout)
#endif /* defined(VK_KHR_workgroup_memory_explicit_layout) */
#if defined(VK_EXT_ycbcr_2plane_444_formats)
#endif /* defined(VK_EXT_ycbcr_2plane_444_formats) */
#if defined(VK_QCOM_ycbcr_degamma)
#endif /* defined(VK_QCOM_ycbcr_degamma) */
#if defined(VK_EXT_ycbcr_image_arrays)
#endif /* defined(VK_EXT_ycbcr_image_arrays) */
#if defined(VK_VERSION_1_3)
#endif /* defined(VK_VERSION_1_3) */
#if defined(VK_KHR_pipeline_binary)
#endif /* defined(VK_KHR_pipeline_binary) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_EXT_blend_operation_advanced)
#endif /* defined(VK_EXT_blend_operation_advanced) */
#if defined(VK_EXT_color_write_enable)
#endif /* defined(VK_EXT_color_write_enable) */
#if defined(VK_AMD_pipeline_compiler_control)
#endif /* defined(VK_AMD_pipeline_compiler_control) */
#if defined(VK_NV_framebuffer_mixed_samples)
#endif /* defined(VK_NV_framebuffer_mixed_samples) */
#if defined(VK_NV_coverage_reduction_mode)
#endif /* defined(VK_NV_coverage_reduction_mode) */
#if defined(VK_NV_fragment_coverage_to_color)
#endif /* defined(VK_NV_fragment_coverage_to_color) */
#if defined(VK_VERSION_1_4)
#endif /* defined(VK_VERSION_1_4) */
#if defined(VK_VERSION_1_3)
#endif /* defined(VK_VERSION_1_3) */
#if defined(VK_EXT_discard_rectangles)
#endif /* defined(VK_EXT_discard_rectangles) */
#if defined(VK_KHR_pipeline_executable_properties)
#endif /* defined(VK_KHR_pipeline_executable_properties) */
#if defined(VK_NV_fragment_shading_rate_enums)
#endif /* defined(VK_NV_fragment_shading_rate_enums) */
#if defined(VK_KHR_fragment_shading_rate)
#endif /* defined(VK_KHR_fragment_shading_rate) */
#if defined(VK_NV_device_generated_commands_compute)
#endif /* defined(VK_NV_device_generated_commands_compute) */
#if defined(VK_KHR_pipeline_executable_properties)
#endif /* defined(VK_KHR_pipeline_executable_properties) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_EXT_pipeline_properties)
#endif /* defined(VK_EXT_pipeline_properties) */
#if defined(VK_EXT_conservative_rasterization)
#endif /* defined(VK_EXT_conservative_rasterization) */
#if defined(VK_EXT_depth_clip_enable)
#endif /* defined(VK_EXT_depth_clip_enable) */
#if defined(VK_VERSION_1_4)
#endif /* defined(VK_VERSION_1_4) */
#if defined(VK_EXT_provoking_vertex)
#endif /* defined(VK_EXT_provoking_vertex) */
#if defined(VK_AMD_rasterization_order)
#endif /* defined(VK_AMD_rasterization_order) */
#if defined(VK_EXT_transform_feedback)
#endif /* defined(VK_EXT_transform_feedback) */
#if defined(VK_VERSION_1_3)
#endif /* defined(VK_VERSION_1_3) */
#if defined(VK_NV_representative_fragment_test)
#endif /* defined(VK_NV_representative_fragment_test) */
#if defined(VK_VERSION_1_4)
#endif /* defined(VK_VERSION_1_4) */
#if defined(VK_EXT_sample_locations)
#endif /* defined(VK_EXT_sample_locations) */
#if defined(VK_EXT_shader_module_identifier)
#endif /* defined(VK_EXT_shader_module_identifier) */
#if defined(VK_AMDX_shader_enqueue)
#endif /* defined(VK_AMDX_shader_enqueue) */
#if defined(VK_VERSION_1_3)
#endif /* defined(VK_VERSION_1_3) */
#if defined(VK_VERSION_1_1)
#endif /* defined(VK_VERSION_1_1) */
#if defined(VK_VERSION_1_4)
#endif /* defined(VK_VERSION_1_4) */
#if defined(VK_NV_shading_rate_image)
#endif /* defined(VK_NV_shading_rate_image) */
#if defined(VK_EXT_depth_clamp_control)
#endif /* defined(VK_EXT_depth_clamp_control) */
#if defined(VK_EXT_depth_clip_control)
#endif /* defined(VK_EXT_depth_clip_control) */
#if defined(VK_NV_scissor_exclusive)
#endif /* defined(VK_NV_scissor_exclusive) */
#if defined(VK_NV_shading_rate_image)
#endif /* defined(VK_NV_shading_rate_image) */
#if defined(VK_NV_viewport_swizzle)
#endif /* defined(VK_NV_viewport_swizzle) */
#if defined(VK_NV_clip_space_w_scaling)
#endif /* defined(VK_NV_clip_space_w_scaling) */
#if defined(VK_GGP_frame_token)
#endif /* defined(VK_GGP_frame_token) */
#if defined(VK_KHR_present_id)
#endif /* defined(VK_KHR_present_id) */
#if defined(VK_KHR_swapchain)
#endif /* defined(VK_KHR_swapchain) */
#if defined(VK_KHR_incremental_present)
#endif /* defined(VK_KHR_incremental_present) */
#if defined(VK_GOOGLE_display_timing)
#endif /* defined(VK_GOOGLE_display_timing) */
#if defined(VK_VERSION_1_3)
#endif /* defined(VK_VERSION_1_3) */
#if defined(VK_VERSION_1_1)
#endif /* defined(VK_VERSION_1_1) */
#if defined(VK_VERSION_1_4)
#endif /* defined(VK_VERSION_1_4) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_VERSION_1_4)
#endif /* defined(VK_VERSION_1_4) */
#if defined(VK_NV_low_latency)
#endif /* defined(VK_NV_low_latency) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_KHR_performance_query)
#endif /* defined(VK_KHR_performance_query) */
#if defined(VK_INTEL_performance_query)
#endif /* defined(VK_INTEL_performance_query) */
#if defined(VK_KHR_video_encode_queue)
#endif /* defined(VK_KHR_video_encode_queue) */
#if defined(VK_NV_device_diagnostic_checkpoints) && (defined(VK_VERSION_1_3) || defined(VK_KHR_synchronization2))
#endif /* defined(VK_NV_device_diagnostic_checkpoints) && (defined(VK_VERSION_1_3) || defined(VK_KHR_synchronization2)) */
#if defined(VK_NV_device_diagnostic_checkpoints)
#endif /* defined(VK_NV_device_diagnostic_checkpoints) */
#if defined(VK_VERSION_1_4)
#endif /* defined(VK_VERSION_1_4) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_VERSION_1_1)
#endif /* defined(VK_VERSION_1_1) */
#if defined(VK_KHR_video_queue)
#endif /* defined(VK_KHR_video_queue) */
#if defined(VK_KHR_ray_tracing_pipeline)
#endif /* defined(VK_KHR_ray_tracing_pipeline) */
#if defined(VK_NV_ray_tracing)
#endif /* defined(VK_NV_ray_tracing) */
#if defined(VK_GOOGLE_display_timing)
#endif /* defined(VK_GOOGLE_display_timing) */
#if defined(VK_KHR_pipeline_binary)
#endif /* defined(VK_KHR_pipeline_binary) */
#if defined(VK_EXT_swapchain_maintenance1)
#endif /* defined(VK_EXT_swapchain_maintenance1) */
#if defined(VK_VERSION_1_2)
#endif /* defined(VK_VERSION_1_2) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_VERSION_1_2)
#endif /* defined(VK_VERSION_1_2) */
#if defined(VK_EXT_subpass_merge_feedback)
#endif /* defined(VK_EXT_subpass_merge_feedback) */
#if defined(VK_EXT_fragment_density_map)
#endif /* defined(VK_EXT_fragment_density_map) */
#if defined(VK_VERSION_1_1)
#endif /* defined(VK_VERSION_1_1) */
#if defined(VK_EXT_sample_locations)
#endif /* defined(VK_EXT_sample_locations) */
#if defined(VK_ARM_render_pass_striped)
#endif /* defined(VK_ARM_render_pass_striped) */
#if defined(VK_VERSION_1_3)
#endif /* defined(VK_VERSION_1_3) */
#if defined(VK_ARM_render_pass_striped)
#endif /* defined(VK_ARM_render_pass_striped) */
#if defined(VK_EXT_subpass_merge_feedback)
#endif /* defined(VK_EXT_subpass_merge_feedback) */
#if defined(VK_QCOM_render_pass_transform)
#endif /* defined(VK_QCOM_render_pass_transform) */
#if defined(VK_VERSION_1_4)
#endif /* defined(VK_VERSION_1_4) */
#if defined(VK_VERSION_1_3)
#endif /* defined(VK_VERSION_1_3) */
#if defined(VK_VERSION_1_4)
#endif /* defined(VK_VERSION_1_4) */
#if defined(VK_EXT_fragment_density_map) && (defined(VK_VERSION_1_3) || defined(VK_KHR_dynamic_rendering))
#endif /* defined(VK_EXT_fragment_density_map) && (defined(VK_VERSION_1_3) || defined(VK_KHR_dynamic_rendering)) */
#if defined(VK_KHR_fragment_shading_rate) && (defined(VK_VERSION_1_3) || defined(VK_KHR_dynamic_rendering))
#endif /* defined(VK_KHR_fragment_shading_rate) && (defined(VK_VERSION_1_3) || defined(VK_KHR_dynamic_rendering)) */
#if defined(VK_VERSION_1_3)
#endif /* defined(VK_VERSION_1_3) */
#if defined(VK_VERSION_1_4)
#endif /* defined(VK_VERSION_1_4) */
#if defined(VK_VERSION_1_3)
#endif /* defined(VK_VERSION_1_3) */
#if defined(VK_NV_ray_tracing_motion_blur)
#endif /* defined(VK_NV_ray_tracing_motion_blur) */
#if defined(VK_QCOM_image_processing2)
#endif /* defined(VK_QCOM_image_processing2) */
#if defined(VK_EXT_border_color_swizzle)
#endif /* defined(VK_EXT_border_color_swizzle) */
#if defined(VK_EXT_descriptor_buffer)
#endif /* defined(VK_EXT_descriptor_buffer) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_QCOM_filter_cubic_weights)
#endif /* defined(VK_QCOM_filter_cubic_weights) */
#if defined(VK_EXT_custom_border_color)
#endif /* defined(VK_EXT_custom_border_color) */
#if defined(VK_VERSION_1_2)
#endif /* defined(VK_VERSION_1_2) */
#if defined(VK_VERSION_1_1)
#endif /* defined(VK_VERSION_1_1) */
#if defined(VK_QCOM_ycbcr_degamma)
#endif /* defined(VK_QCOM_ycbcr_degamma) */
#if defined(VK_QNX_external_memory_screen_buffer)
#endif /* defined(VK_QNX_external_memory_screen_buffer) */
#if defined(VK_QNX_screen_surface)
#endif /* defined(VK_QNX_screen_surface) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_KHR_external_semaphore_fd)
#endif /* defined(VK_KHR_external_semaphore_fd) */
#if defined(VK_KHR_external_semaphore_win32)
#endif /* defined(VK_KHR_external_semaphore_win32) */
#if defined(VK_FUCHSIA_external_semaphore)
#endif /* defined(VK_FUCHSIA_external_semaphore) */
#if defined(VK_VERSION_1_2)
#endif /* defined(VK_VERSION_1_2) */
#if defined(VK_KHR_maintenance6) && defined(VK_EXT_descriptor_buffer)
#endif /* defined(VK_KHR_maintenance6) && defined(VK_EXT_descriptor_buffer) */
#if defined(VK_NV_low_latency2)
#endif /* defined(VK_NV_low_latency2) */
#if defined(VK_NV_device_generated_commands)
#endif /* defined(VK_NV_device_generated_commands) */
#if defined(VK_EXT_shader_object)
#endif /* defined(VK_EXT_shader_object) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_EXT_shader_module_identifier)
#endif /* defined(VK_EXT_shader_module_identifier) */
#if defined(VK_EXT_validation_cache)
#endif /* defined(VK_EXT_validation_cache) */
#if defined(VK_AMD_shader_info)
#endif /* defined(VK_AMD_shader_info) */
#if defined(VK_KHR_shared_presentable_image)
#endif /* defined(VK_KHR_shared_presentable_image) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_VERSION_1_1)
#endif /* defined(VK_VERSION_1_1) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_VERSION_1_1)
#endif /* defined(VK_VERSION_1_1) */
#if defined(VK_GGP_stream_descriptor_surface)
#endif /* defined(VK_GGP_stream_descriptor_surface) */
#if defined(VK_KHR_ray_tracing_pipeline)
#endif /* defined(VK_KHR_ray_tracing_pipeline) */
#if defined(VK_VERSION_1_0)
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_VERSION_1_3)
#endif /* defined(VK_VERSION_1_3) */
#if defined(VK_VERSION_1_2)
#endif /* defined(VK_VERSION_1_2) */
#if defined(VK_QCOM_fragment_density_map_offset)
#endif /* defined(VK_QCOM_fragment_density_map_offset) */
#if defined(VK_EXT_multisampled_render_to_single_sampled)
#endif /* defined(VK_EXT_multisampled_render_to_single_sampled) */
#if defined(VK_HUAWEI_subpass_shading)
#endif /* defined(VK_HUAWEI_subpass_shading) */
#if defined(VK_VERSION_1_4)
#endif /* defined(VK_VERSION_1_4) */
#if defined(VK_EXT_display_surface_counter)
#endif /* defined(VK_EXT_display_surface_counter) */
#if defined(VK_KHR_surface)
#endif /* defined(VK_KHR_surface) */
#if defined(VK_KHR_get_surface_capabilities2)
#endif /* defined(VK_KHR_get_surface_capabilities2) */
#if defined(VK_EXT_full_screen_exclusive)
#endif /* defined(VK_EXT_full_screen_exclusive) */
#if defined(VK_NV_present_barrier)
#endif /* defined(VK_NV_present_barrier) */
#if defined(VK_KHR_surface)
#endif /* defined(VK_KHR_surface) */
#if defined(VK_KHR_get_surface_capabilities2)
#endif /* defined(VK_KHR_get_surface_capabilities2) */
#if defined(VK_EXT_full_screen_exclusive)
#endif /* defined(VK_EXT_full_screen_exclusive) */
#if defined(VK_EXT_full_screen_exclusive) && defined(VK_KHR_win32_surface)
#endif /* defined(VK_EXT_full_screen_exclusive) && defined(VK_KHR_win32_surface) */
#if defined(VK_EXT_surface_maintenance1)
#endif /* defined(VK_EXT_surface_maintenance1) */
#if defined(VK_KHR_surface_protected_capabilities)
#endif /* defined(VK_KHR_surface_protected_capabilities) */
#if defined(VK_EXT_display_control)
#endif /* defined(VK_EXT_display_control) */
#if defined(VK_KHR_swapchain)
#endif /* defined(VK_KHR_swapchain) */
#if defined(VK_AMD_display_native_hdr)
#endif /* defined(VK_AMD_display_native_hdr) */
#if defined(VK_NV_low_latency2)
#endif /* defined(VK_NV_low_latency2) */
#if defined(VK_NV_present_barrier)
#endif /* defined(VK_NV_present_barrier) */
#if defined(VK_EXT_swapchain_maintenance1)
#endif /* defined(VK_EXT_swapchain_maintenance1) */
#if defined(VK_AMD_texture_gather_bias_lod)
#endif /* defined(VK_AMD_texture_gather_bias_lod) */
#if defined(VK_QCOM_tile_properties)
#endif /* defined(VK_QCOM_tile_properties) */
#if defined(VK_VERSION_1_2)
#endif /* defined(VK_VERSION_1_2) */
#if defined(VK_KHR_ray_tracing_maintenance1) && defined(VK_KHR_ray_tracing_pipeline)
#endif /* defined(VK_KHR_ray_tracing_maintenance1) && defined(VK_KHR_ray_tracing_pipeline) */
#if defined(VK_KHR_ray_tracing_pipeline)
#endif /* defined(VK_KHR_ray_tracing_pipeline) */
#if defined(VK_KHR_acceleration_structure)
#endif /* defined(VK_KHR_acceleration_structure) */
#if defined(VK_EXT_validation_cache)
#endif /* defined(VK_EXT_validation_cache) */
#if defined(VK_EXT_validation_features)
#endif /* defined(VK_EXT_validation_features) */
#if defined(VK_EXT_validation_flags)
#endif /* defined(VK_EXT_validation_flags) */
#if (defined(VK_EXT_shader_object)) || (defined(VK_EXT_vertex_input_dynamic_state))
#endif /* (defined(VK_EXT_shader_object)) || (defined(VK_EXT_vertex_input_dynamic_state)) */
#if defined(VK_NN_vi_surface)
#endif /* defined(VK_NN_vi_surface) */
#if defined(VK_KHR_video_queue)
#endif /* defined(VK_KHR_video_queue) */
#if defined(VK_KHR_video_decode_av1)
#endif /* defined(VK_KHR_video_decode_av1) */
#if defined(VK_KHR_video_decode_queue)
#endif /* defined(VK_KHR_video_decode_queue) */
#if defined(VK_KHR_video_decode_h264)
#endif /* defined(VK_KHR_video_decode_h264) */
#if defined(VK_KHR_video_decode_h265)
#endif /* defined(VK_KHR_video_decode_h265) */
#if defined(VK_KHR_video_decode_queue)
#endif /* defined(VK_KHR_video_decode_queue) */
#if defined(VK_KHR_video_encode_av1)
#endif /* defined(VK_KHR_video_encode_av1) */
#if defined(VK_KHR_video_encode_quantization_map) && defined(VK_KHR_video_encode_av1)
#endif /* defined(VK_KHR_video_encode_quantization_map) && defined(VK_KHR_video_encode_av1) */
#if defined(VK_KHR_video_encode_av1)
#endif /* defined(VK_KHR_video_encode_av1) */
#if defined(VK_KHR_video_encode_queue)
#endif /* defined(VK_KHR_video_encode_queue) */
#if defined(VK_KHR_video_encode_h264)
#endif /* defined(VK_KHR_video_encode_h264) */
#if defined(VK_KHR_video_encode_quantization_map) && defined(VK_KHR_video_encode_h264)
#endif /* defined(VK_KHR_video_encode_quantization_map) && defined(VK_KHR_video_encode_h264) */
#if defined(VK_KHR_video_encode_h264)
#endif /* defined(VK_KHR_video_encode_h264) */
#if defined(VK_KHR_video_encode_h265)
#endif /* defined(VK_KHR_video_encode_h265) */
#if defined(VK_KHR_video_encode_quantization_map) && defined(VK_KHR_video_encode_h265)
#endif /* defined(VK_KHR_video_encode_quantization_map) && defined(VK_KHR_video_encode_h265) */
#if defined(VK_KHR_video_encode_h265)
#endif /* defined(VK_KHR_video_encode_h265) */
#if defined(VK_KHR_video_encode_queue)
#endif /* defined(VK_KHR_video_encode_queue) */
#if defined(VK_KHR_video_encode_quantization_map)
#endif /* defined(VK_KHR_video_encode_quantization_map) */
#if defined(VK_KHR_video_encode_queue)
#endif /* defined(VK_KHR_video_encode_queue) */
#if defined(VK_KHR_video_queue)
#endif /* defined(VK_KHR_video_queue) */
#if defined(VK_KHR_video_encode_quantization_map) && defined(VK_KHR_video_encode_av1)
#endif /* defined(VK_KHR_video_encode_quantization_map) && defined(VK_KHR_video_encode_av1) */
#if defined(VK_KHR_video_encode_quantization_map) && defined(VK_KHR_video_encode_h265)
#endif /* defined(VK_KHR_video_encode_quantization_map) && defined(VK_KHR_video_encode_h265) */
#if defined(VK_KHR_video_queue)
#endif /* defined(VK_KHR_video_queue) */
#if defined(VK_KHR_video_encode_quantization_map)
#endif /* defined(VK_KHR_video_encode_quantization_map) */
#if defined(VK_KHR_video_maintenance1)
#endif /* defined(VK_KHR_video_maintenance1) */
#if defined(VK_KHR_video_queue)
#endif /* defined(VK_KHR_video_queue) */
#if defined(VK_KHR_wayland_surface)
#endif /* defined(VK_KHR_wayland_surface) */
#if defined(VK_KHR_win32_keyed_mutex)
#endif /* defined(VK_KHR_win32_keyed_mutex) */
#if defined(VK_NV_win32_keyed_mutex)
#endif /* defined(VK_NV_win32_keyed_mutex) */
#if defined(VK_KHR_win32_surface)
#endif /* defined(VK_KHR_win32_surface) */
#if defined(VK_KHR_acceleration_structure)
#endif /* defined(VK_KHR_acceleration_structure) */
#if defined(VK_NV_ray_tracing)
#endif /* defined(VK_NV_ray_tracing) */
#if defined(VK_VERSION_1_3)
#endif /* defined(VK_VERSION_1_3) */
#if defined(VK_EXT_device_generated_commands)
#endif /* defined(VK_EXT_device_generated_commands) */
#if defined(VK_EXT_device_generated_commands) && defined(VK_EXT_shader_object)
#endif /* defined(VK_EXT_device_generated_commands) && defined(VK_EXT_shader_object) */
#if defined(VK_KHR_xcb_surface)
#endif /* defined(VK_KHR_xcb_surface) */
#if defined(VK_KHR_xlib_surface)
#endif /* defined(VK_KHR_xlib_surface) */
#if defined(VK_VERSION_1_0)
VkResult WRAP_vkAllocateCommandBuffers(VkDevice device, 
            VkCommandBufferAllocateInfo& pAllocateInfo, VkCommandBuffer* pCommandBuffers) { return vkAllocateCommandBuffers(device, &pAllocateInfo, pCommandBuffers); }
VkResult WRAP_vkAllocateDescriptorSets(VkDevice device, 
            VkDescriptorSetAllocateInfo& pAllocateInfo, VkDescriptorSet* pDescriptorSets) { return vkAllocateDescriptorSets(device, &pAllocateInfo, pDescriptorSets); }
VkResult WRAP_vkAllocateMemory(VkDevice device, 
            VkMemoryAllocateInfo& pAllocateInfo, const VkAllocationCallbacks* pAllocator, 
        VkDeviceMemory& pMemory) { return vkAllocateMemory(device, &pAllocateInfo, pAllocator, &pMemory); }
VkResult WRAP_vkBeginCommandBuffer(VkCommandBuffer commandBuffer, 
            VkCommandBufferBeginInfo& pBeginInfo) { return vkBeginCommandBuffer(commandBuffer, &pBeginInfo); }
VkResult WRAP_vkBindBufferMemory(VkDevice device, VkBuffer buffer, VkDeviceMemory memory, VkDeviceSize memoryOffset) { return vkBindBufferMemory(device, buffer, memory, memoryOffset); }
VkResult WRAP_vkBindImageMemory(VkDevice device, VkImage image, VkDeviceMemory memory, VkDeviceSize memoryOffset) { return vkBindImageMemory(device, image, memory, memoryOffset); }
void WRAP_vkCmdBeginQuery(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, VkQueryControlFlags flags) { vkCmdBeginQuery(commandBuffer, queryPool, query, flags); }
void WRAP_vkCmdBeginRenderPass(VkCommandBuffer commandBuffer, 
            VkRenderPassBeginInfo& pRenderPassBegin, VkSubpassContents contents) { vkCmdBeginRenderPass(commandBuffer, &pRenderPassBegin, contents); }
void WRAP_vkCmdBindDescriptorSets(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t firstSet, uint32_t descriptorSetCount, const VkDescriptorSet* pDescriptorSets, uint32_t dynamicOffsetCount, const uint32_t* pDynamicOffsets) { vkCmdBindDescriptorSets(commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets); }
void WRAP_vkCmdBindIndexBuffer(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkIndexType indexType) { vkCmdBindIndexBuffer(commandBuffer, buffer, offset, indexType); }
void WRAP_vkCmdBindPipeline(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline) { vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline); }
void WRAP_vkCmdBindVertexBuffers(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer* pBuffers, const VkDeviceSize* pOffsets) { vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets); }
void WRAP_vkCmdBlitImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageBlit* pRegions, VkFilter filter) { vkCmdBlitImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions, filter); }
void WRAP_vkCmdClearAttachments(VkCommandBuffer commandBuffer, uint32_t attachmentCount, const VkClearAttachment* pAttachments, uint32_t rectCount, const VkClearRect* pRects) { vkCmdClearAttachments(commandBuffer, attachmentCount, pAttachments, rectCount, pRects); }
void WRAP_vkCmdClearColorImage(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, 
            VkClearColorValue& pColor, uint32_t rangeCount, const VkImageSubresourceRange* pRanges) { vkCmdClearColorImage(commandBuffer, image, imageLayout, &pColor, rangeCount, pRanges); }
void WRAP_vkCmdClearDepthStencilImage(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, 
            VkClearDepthStencilValue& pDepthStencil, uint32_t rangeCount, const VkImageSubresourceRange* pRanges) { vkCmdClearDepthStencilImage(commandBuffer, image, imageLayout, &pDepthStencil, rangeCount, pRanges); }
void WRAP_vkCmdCopyBuffer(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkBuffer dstBuffer, uint32_t regionCount, const VkBufferCopy* pRegions) { vkCmdCopyBuffer(commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions); }
void WRAP_vkCmdCopyBufferToImage(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkBufferImageCopy* pRegions) { vkCmdCopyBufferToImage(commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount, pRegions); }
void WRAP_vkCmdCopyImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageCopy* pRegions) { vkCmdCopyImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions); }
void WRAP_vkCmdCopyImageToBuffer(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkBuffer dstBuffer, uint32_t regionCount, const VkBufferImageCopy* pRegions) { vkCmdCopyImageToBuffer(commandBuffer, srcImage, srcImageLayout, dstBuffer, regionCount, pRegions); }
void WRAP_vkCmdCopyQueryPoolResults(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize stride, VkQueryResultFlags flags) { vkCmdCopyQueryPoolResults(commandBuffer, queryPool, firstQuery, queryCount, dstBuffer, dstOffset, stride, flags); }
void WRAP_vkCmdDispatch(VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ) { vkCmdDispatch(commandBuffer, groupCountX, groupCountY, groupCountZ); }
void WRAP_vkCmdDispatchIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset) { vkCmdDispatchIndirect(commandBuffer, buffer, offset); }
void WRAP_vkCmdDraw(VkCommandBuffer commandBuffer, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance) { vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance); }
void WRAP_vkCmdDrawIndexed(VkCommandBuffer commandBuffer, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance) { vkCmdDrawIndexed(commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance); }
void WRAP_vkCmdDrawIndexedIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride) { vkCmdDrawIndexedIndirect(commandBuffer, buffer, offset, drawCount, stride); }
void WRAP_vkCmdDrawIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride) { vkCmdDrawIndirect(commandBuffer, buffer, offset, drawCount, stride); }
void WRAP_vkCmdEndQuery(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query) { vkCmdEndQuery(commandBuffer, queryPool, query); }
void WRAP_vkCmdEndRenderPass(VkCommandBuffer commandBuffer) { vkCmdEndRenderPass(commandBuffer); }
void WRAP_vkCmdExecuteCommands(VkCommandBuffer commandBuffer, uint32_t commandBufferCount, const VkCommandBuffer* pCommandBuffers) { vkCmdExecuteCommands(commandBuffer, commandBufferCount, pCommandBuffers); }
void WRAP_vkCmdFillBuffer(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize size, uint32_t data) { vkCmdFillBuffer(commandBuffer, dstBuffer, dstOffset, size, data); }
void WRAP_vkCmdNextSubpass(VkCommandBuffer commandBuffer, VkSubpassContents contents) { vkCmdNextSubpass(commandBuffer, contents); }
void WRAP_vkCmdPipelineBarrier(VkCommandBuffer commandBuffer, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, VkDependencyFlags dependencyFlags, uint32_t memoryBarrierCount, const VkMemoryBarrier* pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier* pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier* pImageMemoryBarriers) { vkCmdPipelineBarrier(commandBuffer, srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers); }
void WRAP_vkCmdPushConstants(VkCommandBuffer commandBuffer, VkPipelineLayout layout, VkShaderStageFlags stageFlags, uint32_t offset, uint32_t size, const void* pValues) { vkCmdPushConstants(commandBuffer, layout, stageFlags, offset, size, pValues); }
void WRAP_vkCmdResetEvent(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask) { vkCmdResetEvent(commandBuffer, event, stageMask); }
void WRAP_vkCmdResetQueryPool(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount) { vkCmdResetQueryPool(commandBuffer, queryPool, firstQuery, queryCount); }
void WRAP_vkCmdResolveImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageResolve* pRegions) { vkCmdResolveImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions); }
void WRAP_vkCmdSetBlendConstants(VkCommandBuffer commandBuffer, const float blendConstants[4]) { vkCmdSetBlendConstants(commandBuffer, blendConstants); }
void WRAP_vkCmdSetDepthBias(VkCommandBuffer commandBuffer, float depthBiasConstantFactor, float depthBiasClamp, float depthBiasSlopeFactor) { vkCmdSetDepthBias(commandBuffer, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor); }
void WRAP_vkCmdSetDepthBounds(VkCommandBuffer commandBuffer, float minDepthBounds, float maxDepthBounds) { vkCmdSetDepthBounds(commandBuffer, minDepthBounds, maxDepthBounds); }
void WRAP_vkCmdSetEvent(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask) { vkCmdSetEvent(commandBuffer, event, stageMask); }
void WRAP_vkCmdSetLineWidth(VkCommandBuffer commandBuffer, float lineWidth) { vkCmdSetLineWidth(commandBuffer, lineWidth); }
void WRAP_vkCmdSetScissor(VkCommandBuffer commandBuffer, uint32_t firstScissor, uint32_t scissorCount, const VkRect2D* pScissors) { vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors); }
void WRAP_vkCmdSetStencilCompareMask(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t compareMask) { vkCmdSetStencilCompareMask(commandBuffer, faceMask, compareMask); }
void WRAP_vkCmdSetStencilReference(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t reference) { vkCmdSetStencilReference(commandBuffer, faceMask, reference); }
void WRAP_vkCmdSetStencilWriteMask(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t writeMask) { vkCmdSetStencilWriteMask(commandBuffer, faceMask, writeMask); }
void WRAP_vkCmdSetViewport(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewport* pViewports) { vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports); }
void WRAP_vkCmdUpdateBuffer(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize dataSize, const void* pData) { vkCmdUpdateBuffer(commandBuffer, dstBuffer, dstOffset, dataSize, pData); }
void WRAP_vkCmdWaitEvents(VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent* pEvents, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, uint32_t memoryBarrierCount, const VkMemoryBarrier* pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier* pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier* pImageMemoryBarriers) { vkCmdWaitEvents(commandBuffer, eventCount, pEvents, srcStageMask, dstStageMask, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers); }
void WRAP_vkCmdWriteTimestamp(VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkQueryPool queryPool, uint32_t query) { vkCmdWriteTimestamp(commandBuffer, pipelineStage, queryPool, query); }
VkResult WRAP_vkCreateBuffer(VkDevice device, 
            VkBufferCreateInfo& pCreateInfo, const VkAllocationCallbacks* pAllocator, 
        VkBuffer& pBuffer) { return vkCreateBuffer(device, &pCreateInfo, pAllocator, &pBuffer); }
VkResult WRAP_vkCreateBufferView(VkDevice device, 
            VkBufferViewCreateInfo& pCreateInfo, const VkAllocationCallbacks* pAllocator, 
        VkBufferView& pView) { return vkCreateBufferView(device, &pCreateInfo, pAllocator, &pView); }
VkResult WRAP_vkCreateCommandPool(VkDevice device, 
            VkCommandPoolCreateInfo& pCreateInfo, const VkAllocationCallbacks* pAllocator, 
        VkCommandPool& pCommandPool) { return vkCreateCommandPool(device, &pCreateInfo, pAllocator, &pCommandPool); }
VkResult WRAP_vkCreateComputePipelines(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkComputePipelineCreateInfo* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines) { return vkCreateComputePipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines); }
VkResult WRAP_vkCreateDescriptorPool(VkDevice device, 
            VkDescriptorPoolCreateInfo& pCreateInfo, const VkAllocationCallbacks* pAllocator, 
        VkDescriptorPool& pDescriptorPool) { return vkCreateDescriptorPool(device, &pCreateInfo, pAllocator, &pDescriptorPool); }
VkResult WRAP_vkCreateDescriptorSetLayout(VkDevice device, 
            VkDescriptorSetLayoutCreateInfo& pCreateInfo, const VkAllocationCallbacks* pAllocator, 
        VkDescriptorSetLayout& pSetLayout) { return vkCreateDescriptorSetLayout(device, &pCreateInfo, pAllocator, &pSetLayout); }
VkResult WRAP_vkCreateDevice(VkPhysicalDevice physicalDevice, 
            VkDeviceCreateInfo& pCreateInfo, const VkAllocationCallbacks* pAllocator, 
        VkDevice& pDevice) { return vkCreateDevice(physicalDevice, &pCreateInfo, pAllocator, &pDevice); }
VkResult WRAP_vkCreateEvent(VkDevice device, 
            VkEventCreateInfo& pCreateInfo, const VkAllocationCallbacks* pAllocator, 
        VkEvent& pEvent) { return vkCreateEvent(device, &pCreateInfo, pAllocator, &pEvent); }
VkResult WRAP_vkCreateFence(VkDevice device, 
            VkFenceCreateInfo& pCreateInfo, const VkAllocationCallbacks* pAllocator, 
        VkFence& pFence) { return vkCreateFence(device, &pCreateInfo, pAllocator, &pFence); }
VkResult WRAP_vkCreateFramebuffer(VkDevice device, 
            VkFramebufferCreateInfo& pCreateInfo, const VkAllocationCallbacks* pAllocator, 
        VkFramebuffer& pFramebuffer) { return vkCreateFramebuffer(device, &pCreateInfo, pAllocator, &pFramebuffer); }
VkResult WRAP_vkCreateGraphicsPipelines(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkGraphicsPipelineCreateInfo* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines) { return vkCreateGraphicsPipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines); }
VkResult WRAP_vkCreateImage(VkDevice device, 
            VkImageCreateInfo& pCreateInfo, const VkAllocationCallbacks* pAllocator, 
        VkImage& pImage) { return vkCreateImage(device, &pCreateInfo, pAllocator, &pImage); }
VkResult WRAP_vkCreateImageView(VkDevice device, 
            VkImageViewCreateInfo& pCreateInfo, const VkAllocationCallbacks* pAllocator, 
        VkImageView& pView) { return vkCreateImageView(device, &pCreateInfo, pAllocator, &pView); }
VkResult WRAP_vkCreateInstance(
            VkInstanceCreateInfo& pCreateInfo, const VkAllocationCallbacks* pAllocator, 
        VkInstance& pInstance) { return vkCreateInstance(&pCreateInfo, pAllocator, &pInstance); }
VkResult WRAP_vkCreatePipelineCache(VkDevice device, 
            VkPipelineCacheCreateInfo& pCreateInfo, const VkAllocationCallbacks* pAllocator, 
        VkPipelineCache& pPipelineCache) { return vkCreatePipelineCache(device, &pCreateInfo, pAllocator, &pPipelineCache); }
VkResult WRAP_vkCreatePipelineLayout(VkDevice device, 
            VkPipelineLayoutCreateInfo& pCreateInfo, const VkAllocationCallbacks* pAllocator, 
        VkPipelineLayout& pPipelineLayout) { return vkCreatePipelineLayout(device, &pCreateInfo, pAllocator, &pPipelineLayout); }
VkResult WRAP_vkCreateQueryPool(VkDevice device, 
            VkQueryPoolCreateInfo& pCreateInfo, const VkAllocationCallbacks* pAllocator, 
        VkQueryPool& pQueryPool) { return vkCreateQueryPool(device, &pCreateInfo, pAllocator, &pQueryPool); }
VkResult WRAP_vkCreateRenderPass(VkDevice device, 
            VkRenderPassCreateInfo& pCreateInfo, const VkAllocationCallbacks* pAllocator, 
        VkRenderPass& pRenderPass) { return vkCreateRenderPass(device, &pCreateInfo, pAllocator, &pRenderPass); }
VkResult WRAP_vkCreateSampler(VkDevice device, 
            VkSamplerCreateInfo& pCreateInfo, const VkAllocationCallbacks* pAllocator, 
        VkSampler& pSampler) { return vkCreateSampler(device, &pCreateInfo, pAllocator, &pSampler); }
VkResult WRAP_vkCreateSemaphore(VkDevice device, 
            VkSemaphoreCreateInfo& pCreateInfo, const VkAllocationCallbacks* pAllocator, 
        VkSemaphore& pSemaphore) { return vkCreateSemaphore(device, &pCreateInfo, pAllocator, &pSemaphore); }
VkResult WRAP_vkCreateShaderModule(VkDevice device, 
            VkShaderModuleCreateInfo& pCreateInfo, const VkAllocationCallbacks* pAllocator, 
        VkShaderModule& pShaderModule) { return vkCreateShaderModule(device, &pCreateInfo, pAllocator, &pShaderModule); }
void WRAP_vkDestroyBuffer(VkDevice device, VkBuffer buffer, const VkAllocationCallbacks* pAllocator) { vkDestroyBuffer(device, buffer, pAllocator); }
void WRAP_vkDestroyBufferView(VkDevice device, VkBufferView bufferView, const VkAllocationCallbacks* pAllocator) { vkDestroyBufferView(device, bufferView, pAllocator); }
void WRAP_vkDestroyCommandPool(VkDevice device, VkCommandPool commandPool, const VkAllocationCallbacks* pAllocator) { vkDestroyCommandPool(device, commandPool, pAllocator); }
void WRAP_vkDestroyDescriptorPool(VkDevice device, VkDescriptorPool descriptorPool, const VkAllocationCallbacks* pAllocator) { vkDestroyDescriptorPool(device, descriptorPool, pAllocator); }
void WRAP_vkDestroyDescriptorSetLayout(VkDevice device, VkDescriptorSetLayout descriptorSetLayout, const VkAllocationCallbacks* pAllocator) { vkDestroyDescriptorSetLayout(device, descriptorSetLayout, pAllocator); }
void WRAP_vkDestroyDevice(VkDevice device, const VkAllocationCallbacks* pAllocator) { vkDestroyDevice(device, pAllocator); }
void WRAP_vkDestroyEvent(VkDevice device, VkEvent event, const VkAllocationCallbacks* pAllocator) { vkDestroyEvent(device, event, pAllocator); }
void WRAP_vkDestroyFence(VkDevice device, VkFence fence, const VkAllocationCallbacks* pAllocator) { vkDestroyFence(device, fence, pAllocator); }
void WRAP_vkDestroyFramebuffer(VkDevice device, VkFramebuffer framebuffer, const VkAllocationCallbacks* pAllocator) { vkDestroyFramebuffer(device, framebuffer, pAllocator); }
void WRAP_vkDestroyImage(VkDevice device, VkImage image, const VkAllocationCallbacks* pAllocator) { vkDestroyImage(device, image, pAllocator); }
void WRAP_vkDestroyImageView(VkDevice device, VkImageView imageView, const VkAllocationCallbacks* pAllocator) { vkDestroyImageView(device, imageView, pAllocator); }
void WRAP_vkDestroyInstance(VkInstance instance, const VkAllocationCallbacks* pAllocator) { vkDestroyInstance(instance, pAllocator); }
void WRAP_vkDestroyPipeline(VkDevice device, VkPipeline pipeline, const VkAllocationCallbacks* pAllocator) { vkDestroyPipeline(device, pipeline, pAllocator); }
void WRAP_vkDestroyPipelineCache(VkDevice device, VkPipelineCache pipelineCache, const VkAllocationCallbacks* pAllocator) { vkDestroyPipelineCache(device, pipelineCache, pAllocator); }
void WRAP_vkDestroyPipelineLayout(VkDevice device, VkPipelineLayout pipelineLayout, const VkAllocationCallbacks* pAllocator) { vkDestroyPipelineLayout(device, pipelineLayout, pAllocator); }
void WRAP_vkDestroyQueryPool(VkDevice device, VkQueryPool queryPool, const VkAllocationCallbacks* pAllocator) { vkDestroyQueryPool(device, queryPool, pAllocator); }
void WRAP_vkDestroyRenderPass(VkDevice device, VkRenderPass renderPass, const VkAllocationCallbacks* pAllocator) { vkDestroyRenderPass(device, renderPass, pAllocator); }
void WRAP_vkDestroySampler(VkDevice device, VkSampler sampler, const VkAllocationCallbacks* pAllocator) { vkDestroySampler(device, sampler, pAllocator); }
void WRAP_vkDestroySemaphore(VkDevice device, VkSemaphore semaphore, const VkAllocationCallbacks* pAllocator) { vkDestroySemaphore(device, semaphore, pAllocator); }
void WRAP_vkDestroyShaderModule(VkDevice device, VkShaderModule shaderModule, const VkAllocationCallbacks* pAllocator) { vkDestroyShaderModule(device, shaderModule, pAllocator); }
VkResult WRAP_vkDeviceWaitIdle(VkDevice device) { return vkDeviceWaitIdle(device); }
VkResult WRAP_vkEndCommandBuffer(VkCommandBuffer commandBuffer) { return vkEndCommandBuffer(commandBuffer); }
VkResult WRAP_vkEnumerateDeviceExtensionProperties(VkPhysicalDevice physicalDevice, const char* pLayerName, 
            uint32_t& pPropertyCount, VkExtensionProperties* pProperties) { return vkEnumerateDeviceExtensionProperties(physicalDevice, pLayerName, &pPropertyCount, pProperties); }
VkResult WRAP_vkEnumerateDeviceLayerProperties(VkPhysicalDevice physicalDevice, 
            uint32_t& pPropertyCount, VkLayerProperties* pProperties) { return vkEnumerateDeviceLayerProperties(physicalDevice, &pPropertyCount, pProperties); }
VkResult WRAP_vkEnumerateInstanceExtensionProperties(const char* pLayerName, 
            uint32_t& pPropertyCount, VkExtensionProperties* pProperties) { return vkEnumerateInstanceExtensionProperties(pLayerName, &pPropertyCount, pProperties); }
VkResult WRAP_vkEnumerateInstanceLayerProperties(
            uint32_t& pPropertyCount, VkLayerProperties* pProperties) { return vkEnumerateInstanceLayerProperties(&pPropertyCount, pProperties); }
VkResult WRAP_vkEnumeratePhysicalDevices(VkInstance instance, 
            uint32_t& pPhysicalDeviceCount, VkPhysicalDevice* pPhysicalDevices) { return vkEnumeratePhysicalDevices(instance, &pPhysicalDeviceCount, pPhysicalDevices); }
VkResult WRAP_vkFlushMappedMemoryRanges(VkDevice device, uint32_t memoryRangeCount, const VkMappedMemoryRange* pMemoryRanges) { return vkFlushMappedMemoryRanges(device, memoryRangeCount, pMemoryRanges); }
void WRAP_vkFreeCommandBuffers(VkDevice device, VkCommandPool commandPool, uint32_t commandBufferCount, const VkCommandBuffer* pCommandBuffers) { vkFreeCommandBuffers(device, commandPool, commandBufferCount, pCommandBuffers); }
VkResult WRAP_vkFreeDescriptorSets(VkDevice device, VkDescriptorPool descriptorPool, uint32_t descriptorSetCount, const VkDescriptorSet* pDescriptorSets) { return vkFreeDescriptorSets(device, descriptorPool, descriptorSetCount, pDescriptorSets); }
void WRAP_vkFreeMemory(VkDevice device, VkDeviceMemory memory, const VkAllocationCallbacks* pAllocator) { vkFreeMemory(device, memory, pAllocator); }
void WRAP_vkGetBufferMemoryRequirements(VkDevice device, VkBuffer buffer, 
        VkMemoryRequirements& pMemoryRequirements) { vkGetBufferMemoryRequirements(device, buffer, &pMemoryRequirements); }
void WRAP_vkGetDeviceMemoryCommitment(VkDevice device, VkDeviceMemory memory, 
        VkDeviceSize& pCommittedMemoryInBytes) { vkGetDeviceMemoryCommitment(device, memory, &pCommittedMemoryInBytes); }
PFN_vkVoidFunction WRAP_vkGetDeviceProcAddr(VkDevice device, const char* pName) { return vkGetDeviceProcAddr(device, pName); }
void WRAP_vkGetDeviceQueue(VkDevice device, uint32_t queueFamilyIndex, uint32_t queueIndex, 
        VkQueue& pQueue) { vkGetDeviceQueue(device, queueFamilyIndex, queueIndex, &pQueue); }
VkResult WRAP_vkGetEventStatus(VkDevice device, VkEvent event) { return vkGetEventStatus(device, event); }
VkResult WRAP_vkGetFenceStatus(VkDevice device, VkFence fence) { return vkGetFenceStatus(device, fence); }
void WRAP_vkGetImageMemoryRequirements(VkDevice device, VkImage image, 
        VkMemoryRequirements& pMemoryRequirements) { vkGetImageMemoryRequirements(device, image, &pMemoryRequirements); }
void WRAP_vkGetImageSparseMemoryRequirements(VkDevice device, VkImage image, 
            uint32_t& pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements* pSparseMemoryRequirements) { vkGetImageSparseMemoryRequirements(device, image, &pSparseMemoryRequirementCount, pSparseMemoryRequirements); }
void WRAP_vkGetImageSubresourceLayout(VkDevice device, VkImage image, 
            VkImageSubresource& pSubresource, 
        VkSubresourceLayout& pLayout) { vkGetImageSubresourceLayout(device, image, &pSubresource, &pLayout); }
PFN_vkVoidFunction WRAP_vkGetInstanceProcAddr(VkInstance instance, const char* pName) { return vkGetInstanceProcAddr(instance, pName); }
void WRAP_vkGetPhysicalDeviceFeatures(VkPhysicalDevice physicalDevice, 
        VkPhysicalDeviceFeatures& pFeatures) { vkGetPhysicalDeviceFeatures(physicalDevice, &pFeatures); }
void WRAP_vkGetPhysicalDeviceFormatProperties(VkPhysicalDevice physicalDevice, VkFormat format, 
        VkFormatProperties& pFormatProperties) { vkGetPhysicalDeviceFormatProperties(physicalDevice, format, &pFormatProperties); }
VkResult WRAP_vkGetPhysicalDeviceImageFormatProperties(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, 
        VkImageFormatProperties& pImageFormatProperties) { return vkGetPhysicalDeviceImageFormatProperties(physicalDevice, format, type, tiling, usage, flags, &pImageFormatProperties); }
void WRAP_vkGetPhysicalDeviceMemoryProperties(VkPhysicalDevice physicalDevice, 
        VkPhysicalDeviceMemoryProperties& pMemoryProperties) { vkGetPhysicalDeviceMemoryProperties(physicalDevice, &pMemoryProperties); }
void WRAP_vkGetPhysicalDeviceProperties(VkPhysicalDevice physicalDevice, 
        VkPhysicalDeviceProperties& pProperties) { vkGetPhysicalDeviceProperties(physicalDevice, &pProperties); }
void WRAP_vkGetPhysicalDeviceQueueFamilyProperties(VkPhysicalDevice physicalDevice, 
            uint32_t& pQueueFamilyPropertyCount, VkQueueFamilyProperties* pQueueFamilyProperties) { vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice, &pQueueFamilyPropertyCount, pQueueFamilyProperties); }
void WRAP_vkGetPhysicalDeviceSparseImageFormatProperties(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkSampleCountFlagBits samples, VkImageUsageFlags usage, VkImageTiling tiling, 
            uint32_t& pPropertyCount, VkSparseImageFormatProperties* pProperties) { vkGetPhysicalDeviceSparseImageFormatProperties(physicalDevice, format, type, samples, usage, tiling, &pPropertyCount, pProperties); }
VkResult WRAP_vkGetPipelineCacheData(VkDevice device, VkPipelineCache pipelineCache, 
            size_t& pDataSize, void* pData) { return vkGetPipelineCacheData(device, pipelineCache, &pDataSize, pData); }
VkResult WRAP_vkGetQueryPoolResults(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, size_t dataSize, void* pData, VkDeviceSize stride, VkQueryResultFlags flags) { return vkGetQueryPoolResults(device, queryPool, firstQuery, queryCount, dataSize, pData, stride, flags); }
void WRAP_vkGetRenderAreaGranularity(VkDevice device, VkRenderPass renderPass, 
        VkExtent2D& pGranularity) { vkGetRenderAreaGranularity(device, renderPass, &pGranularity); }
VkResult WRAP_vkInvalidateMappedMemoryRanges(VkDevice device, uint32_t memoryRangeCount, const VkMappedMemoryRange* pMemoryRanges) { return vkInvalidateMappedMemoryRanges(device, memoryRangeCount, pMemoryRanges); }
VkResult WRAP_vkMapMemory(VkDevice device, VkDeviceMemory memory, VkDeviceSize offset, VkDeviceSize size, VkMemoryMapFlags flags, void** ppData) { return vkMapMemory(device, memory, offset, size, flags, ppData); }
VkResult WRAP_vkMergePipelineCaches(VkDevice device, VkPipelineCache dstCache, uint32_t srcCacheCount, const VkPipelineCache* pSrcCaches) { return vkMergePipelineCaches(device, dstCache, srcCacheCount, pSrcCaches); }
VkResult WRAP_vkQueueBindSparse(VkQueue queue, uint32_t bindInfoCount, const VkBindSparseInfo* pBindInfo, VkFence fence) { return vkQueueBindSparse(queue, bindInfoCount, pBindInfo, fence); }
VkResult WRAP_vkQueueSubmit(VkQueue queue, uint32_t submitCount, const VkSubmitInfo* pSubmits, VkFence fence) { return vkQueueSubmit(queue, submitCount, pSubmits, fence); }
VkResult WRAP_vkQueueWaitIdle(VkQueue queue) { return vkQueueWaitIdle(queue); }
VkResult WRAP_vkResetCommandBuffer(VkCommandBuffer commandBuffer, VkCommandBufferResetFlags flags) { return vkResetCommandBuffer(commandBuffer, flags); }
VkResult WRAP_vkResetCommandPool(VkDevice device, VkCommandPool commandPool, VkCommandPoolResetFlags flags) { return vkResetCommandPool(device, commandPool, flags); }
VkResult WRAP_vkResetDescriptorPool(VkDevice device, VkDescriptorPool descriptorPool, VkDescriptorPoolResetFlags flags) { return vkResetDescriptorPool(device, descriptorPool, flags); }
VkResult WRAP_vkResetEvent(VkDevice device, VkEvent event) { return vkResetEvent(device, event); }
VkResult WRAP_vkResetFences(VkDevice device, uint32_t fenceCount, const VkFence* pFences) { return vkResetFences(device, fenceCount, pFences); }
VkResult WRAP_vkSetEvent(VkDevice device, VkEvent event) { return vkSetEvent(device, event); }
void WRAP_vkUnmapMemory(VkDevice device, VkDeviceMemory memory) { vkUnmapMemory(device, memory); }
void WRAP_vkUpdateDescriptorSets(VkDevice device, uint32_t descriptorWriteCount, const VkWriteDescriptorSet* pDescriptorWrites, uint32_t descriptorCopyCount, const VkCopyDescriptorSet* pDescriptorCopies) { vkUpdateDescriptorSets(device, descriptorWriteCount, pDescriptorWrites, descriptorCopyCount, pDescriptorCopies); }
VkResult WRAP_vkWaitForFences(VkDevice device, uint32_t fenceCount, const VkFence* pFences, VkBool32 waitAll, uint64_t timeout) { return vkWaitForFences(device, fenceCount, pFences, waitAll, timeout); }
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_VERSION_1_1)
VkResult WRAP_vkBindBufferMemory2(VkDevice device, uint32_t bindInfoCount, const VkBindBufferMemoryInfo* pBindInfos) { return vkBindBufferMemory2(device, bindInfoCount, pBindInfos); }
VkResult WRAP_vkBindImageMemory2(VkDevice device, uint32_t bindInfoCount, const VkBindImageMemoryInfo* pBindInfos) { return vkBindImageMemory2(device, bindInfoCount, pBindInfos); }
void WRAP_vkCmdDispatchBase(VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ) { vkCmdDispatchBase(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ); }
void WRAP_vkCmdSetDeviceMask(VkCommandBuffer commandBuffer, uint32_t deviceMask) { vkCmdSetDeviceMask(commandBuffer, deviceMask); }
VkResult WRAP_vkCreateDescriptorUpdateTemplate(VkDevice device, 
            VkDescriptorUpdateTemplateCreateInfo& pCreateInfo, const VkAllocationCallbacks* pAllocator, 
        VkDescriptorUpdateTemplate& pDescriptorUpdateTemplate) { return vkCreateDescriptorUpdateTemplate(device, &pCreateInfo, pAllocator, &pDescriptorUpdateTemplate); }
VkResult WRAP_vkCreateSamplerYcbcrConversion(VkDevice device, 
            VkSamplerYcbcrConversionCreateInfo& pCreateInfo, const VkAllocationCallbacks* pAllocator, 
        VkSamplerYcbcrConversion& pYcbcrConversion) { return vkCreateSamplerYcbcrConversion(device, &pCreateInfo, pAllocator, &pYcbcrConversion); }
void WRAP_vkDestroyDescriptorUpdateTemplate(VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const VkAllocationCallbacks* pAllocator) { vkDestroyDescriptorUpdateTemplate(device, descriptorUpdateTemplate, pAllocator); }
void WRAP_vkDestroySamplerYcbcrConversion(VkDevice device, VkSamplerYcbcrConversion ycbcrConversion, const VkAllocationCallbacks* pAllocator) { vkDestroySamplerYcbcrConversion(device, ycbcrConversion, pAllocator); }
VkResult WRAP_vkEnumerateInstanceVersion(
        uint32_t& pApiVersion) { return vkEnumerateInstanceVersion(&pApiVersion); }
VkResult WRAP_vkEnumeratePhysicalDeviceGroups(VkInstance instance, 
            uint32_t& pPhysicalDeviceGroupCount, VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties) { return vkEnumeratePhysicalDeviceGroups(instance, &pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties); }
void WRAP_vkGetBufferMemoryRequirements2(VkDevice device, 
            VkBufferMemoryRequirementsInfo2& pInfo, 
        VkMemoryRequirements2& pMemoryRequirements) { vkGetBufferMemoryRequirements2(device, &pInfo, &pMemoryRequirements); }
void WRAP_vkGetDescriptorSetLayoutSupport(VkDevice device, 
            VkDescriptorSetLayoutCreateInfo& pCreateInfo, 
        VkDescriptorSetLayoutSupport& pSupport) { vkGetDescriptorSetLayoutSupport(device, &pCreateInfo, &pSupport); }
void WRAP_vkGetDeviceGroupPeerMemoryFeatures(VkDevice device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, 
        VkPeerMemoryFeatureFlags& pPeerMemoryFeatures) { vkGetDeviceGroupPeerMemoryFeatures(device, heapIndex, localDeviceIndex, remoteDeviceIndex, &pPeerMemoryFeatures); }
void WRAP_vkGetDeviceQueue2(VkDevice device, 
            VkDeviceQueueInfo2& pQueueInfo, 
        VkQueue& pQueue) { vkGetDeviceQueue2(device, &pQueueInfo, &pQueue); }
void WRAP_vkGetImageMemoryRequirements2(VkDevice device, 
            VkImageMemoryRequirementsInfo2& pInfo, 
        VkMemoryRequirements2& pMemoryRequirements) { vkGetImageMemoryRequirements2(device, &pInfo, &pMemoryRequirements); }
void WRAP_vkGetImageSparseMemoryRequirements2(VkDevice device, 
            VkImageSparseMemoryRequirementsInfo2& pInfo, 
            uint32_t& pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2* pSparseMemoryRequirements) { vkGetImageSparseMemoryRequirements2(device, &pInfo, &pSparseMemoryRequirementCount, pSparseMemoryRequirements); }
void WRAP_vkGetPhysicalDeviceExternalBufferProperties(VkPhysicalDevice physicalDevice, 
            VkPhysicalDeviceExternalBufferInfo& pExternalBufferInfo, 
        VkExternalBufferProperties& pExternalBufferProperties) { vkGetPhysicalDeviceExternalBufferProperties(physicalDevice, &pExternalBufferInfo, &pExternalBufferProperties); }
void WRAP_vkGetPhysicalDeviceExternalFenceProperties(VkPhysicalDevice physicalDevice, 
            VkPhysicalDeviceExternalFenceInfo& pExternalFenceInfo, 
        VkExternalFenceProperties& pExternalFenceProperties) { vkGetPhysicalDeviceExternalFenceProperties(physicalDevice, &pExternalFenceInfo, &pExternalFenceProperties); }
void WRAP_vkGetPhysicalDeviceExternalSemaphoreProperties(VkPhysicalDevice physicalDevice, 
            VkPhysicalDeviceExternalSemaphoreInfo& pExternalSemaphoreInfo, 
        VkExternalSemaphoreProperties& pExternalSemaphoreProperties) { vkGetPhysicalDeviceExternalSemaphoreProperties(physicalDevice, &pExternalSemaphoreInfo, &pExternalSemaphoreProperties); }
void WRAP_vkGetPhysicalDeviceFeatures2(VkPhysicalDevice physicalDevice, 
        VkPhysicalDeviceFeatures2& pFeatures) { vkGetPhysicalDeviceFeatures2(physicalDevice, &pFeatures); }
void WRAP_vkGetPhysicalDeviceFormatProperties2(VkPhysicalDevice physicalDevice, VkFormat format, 
        VkFormatProperties2& pFormatProperties) { vkGetPhysicalDeviceFormatProperties2(physicalDevice, format, &pFormatProperties); }
VkResult WRAP_vkGetPhysicalDeviceImageFormatProperties2(VkPhysicalDevice physicalDevice, 
            VkPhysicalDeviceImageFormatInfo2& pImageFormatInfo, 
        VkImageFormatProperties2& pImageFormatProperties) { return vkGetPhysicalDeviceImageFormatProperties2(physicalDevice, &pImageFormatInfo, &pImageFormatProperties); }
void WRAP_vkGetPhysicalDeviceMemoryProperties2(VkPhysicalDevice physicalDevice, 
        VkPhysicalDeviceMemoryProperties2& pMemoryProperties) { vkGetPhysicalDeviceMemoryProperties2(physicalDevice, &pMemoryProperties); }
void WRAP_vkGetPhysicalDeviceProperties2(VkPhysicalDevice physicalDevice, 
        VkPhysicalDeviceProperties2& pProperties) { vkGetPhysicalDeviceProperties2(physicalDevice, &pProperties); }
void WRAP_vkGetPhysicalDeviceQueueFamilyProperties2(VkPhysicalDevice physicalDevice, 
            uint32_t& pQueueFamilyPropertyCount, VkQueueFamilyProperties2* pQueueFamilyProperties) { vkGetPhysicalDeviceQueueFamilyProperties2(physicalDevice, &pQueueFamilyPropertyCount, pQueueFamilyProperties); }
void WRAP_vkGetPhysicalDeviceSparseImageFormatProperties2(VkPhysicalDevice physicalDevice, 
            VkPhysicalDeviceSparseImageFormatInfo2& pFormatInfo, 
            uint32_t& pPropertyCount, VkSparseImageFormatProperties2* pProperties) { vkGetPhysicalDeviceSparseImageFormatProperties2(physicalDevice, &pFormatInfo, &pPropertyCount, pProperties); }
void WRAP_vkTrimCommandPool(VkDevice device, VkCommandPool commandPool, VkCommandPoolTrimFlags flags) { vkTrimCommandPool(device, commandPool, flags); }
void WRAP_vkUpdateDescriptorSetWithTemplate(VkDevice device, VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const void* pData) { vkUpdateDescriptorSetWithTemplate(device, descriptorSet, descriptorUpdateTemplate, pData); }
#endif /* defined(VK_VERSION_1_1) */
#if defined(VK_VERSION_1_2)
void WRAP_vkCmdBeginRenderPass2(VkCommandBuffer commandBuffer, 
            VkRenderPassBeginInfo& pRenderPassBegin, 
        VkSubpassBeginInfo& pSubpassBeginInfo) { vkCmdBeginRenderPass2(commandBuffer, &pRenderPassBegin, &pSubpassBeginInfo); }
void WRAP_vkCmdDrawIndexedIndirectCount(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) { vkCmdDrawIndexedIndirectCount(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride); }
void WRAP_vkCmdDrawIndirectCount(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) { vkCmdDrawIndirectCount(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride); }
void WRAP_vkCmdEndRenderPass2(VkCommandBuffer commandBuffer, 
        VkSubpassEndInfo& pSubpassEndInfo) { vkCmdEndRenderPass2(commandBuffer, &pSubpassEndInfo); }
void WRAP_vkCmdNextSubpass2(VkCommandBuffer commandBuffer, 
            VkSubpassBeginInfo& pSubpassBeginInfo, 
        VkSubpassEndInfo& pSubpassEndInfo) { vkCmdNextSubpass2(commandBuffer, &pSubpassBeginInfo, &pSubpassEndInfo); }
VkResult WRAP_vkCreateRenderPass2(VkDevice device, 
            VkRenderPassCreateInfo2& pCreateInfo, const VkAllocationCallbacks* pAllocator, 
        VkRenderPass& pRenderPass) { return vkCreateRenderPass2(device, &pCreateInfo, pAllocator, &pRenderPass); }
VkDeviceAddress WRAP_vkGetBufferDeviceAddress(VkDevice device, 
        VkBufferDeviceAddressInfo& pInfo) { return vkGetBufferDeviceAddress(device, &pInfo); }
uint64_t WRAP_vkGetBufferOpaqueCaptureAddress(VkDevice device, 
        VkBufferDeviceAddressInfo& pInfo) { return vkGetBufferOpaqueCaptureAddress(device, &pInfo); }
uint64_t WRAP_vkGetDeviceMemoryOpaqueCaptureAddress(VkDevice device, 
        VkDeviceMemoryOpaqueCaptureAddressInfo& pInfo) { return vkGetDeviceMemoryOpaqueCaptureAddress(device, &pInfo); }
VkResult WRAP_vkGetSemaphoreCounterValue(VkDevice device, VkSemaphore semaphore, 
        uint64_t& pValue) { return vkGetSemaphoreCounterValue(device, semaphore, &pValue); }
void WRAP_vkResetQueryPool(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount) { vkResetQueryPool(device, queryPool, firstQuery, queryCount); }
VkResult WRAP_vkSignalSemaphore(VkDevice device, 
        VkSemaphoreSignalInfo& pSignalInfo) { return vkSignalSemaphore(device, &pSignalInfo); }
VkResult WRAP_vkWaitSemaphores(VkDevice device, 
            VkSemaphoreWaitInfo& pWaitInfo, uint64_t timeout) { return vkWaitSemaphores(device, &pWaitInfo, timeout); }
#endif /* defined(VK_VERSION_1_2) */
#if defined(VK_VERSION_1_3)
void WRAP_vkCmdBeginRendering(VkCommandBuffer                   commandBuffer, 
        VkRenderingInfo& pRenderingInfo) { vkCmdBeginRendering(commandBuffer, &pRenderingInfo); }
void WRAP_vkCmdBindVertexBuffers2(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer* pBuffers, const VkDeviceSize* pOffsets, const VkDeviceSize* pSizes, const VkDeviceSize* pStrides) { vkCmdBindVertexBuffers2(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes, pStrides); }
void WRAP_vkCmdBlitImage2(VkCommandBuffer commandBuffer, 
        VkBlitImageInfo2& pBlitImageInfo) { vkCmdBlitImage2(commandBuffer, &pBlitImageInfo); }
void WRAP_vkCmdCopyBuffer2(VkCommandBuffer commandBuffer, 
        VkCopyBufferInfo2& pCopyBufferInfo) { vkCmdCopyBuffer2(commandBuffer, &pCopyBufferInfo); }
void WRAP_vkCmdCopyBufferToImage2(VkCommandBuffer commandBuffer, 
        VkCopyBufferToImageInfo2& pCopyBufferToImageInfo) { vkCmdCopyBufferToImage2(commandBuffer, &pCopyBufferToImageInfo); }
void WRAP_vkCmdCopyImage2(VkCommandBuffer commandBuffer, 
        VkCopyImageInfo2& pCopyImageInfo) { vkCmdCopyImage2(commandBuffer, &pCopyImageInfo); }
void WRAP_vkCmdCopyImageToBuffer2(VkCommandBuffer commandBuffer, 
        VkCopyImageToBufferInfo2& pCopyImageToBufferInfo) { vkCmdCopyImageToBuffer2(commandBuffer, &pCopyImageToBufferInfo); }
void WRAP_vkCmdEndRendering(VkCommandBuffer                   commandBuffer) { vkCmdEndRendering(commandBuffer); }
void WRAP_vkCmdPipelineBarrier2(VkCommandBuffer                   commandBuffer, 
        VkDependencyInfo& pDependencyInfo) { vkCmdPipelineBarrier2(commandBuffer, &pDependencyInfo); }
void WRAP_vkCmdResetEvent2(VkCommandBuffer                   commandBuffer, VkEvent                                             event, VkPipelineStageFlags2               stageMask) { vkCmdResetEvent2(commandBuffer, event, stageMask); }
void WRAP_vkCmdResolveImage2(VkCommandBuffer commandBuffer, 
        VkResolveImageInfo2& pResolveImageInfo) { vkCmdResolveImage2(commandBuffer, &pResolveImageInfo); }
void WRAP_vkCmdSetCullMode(VkCommandBuffer commandBuffer, VkCullModeFlags cullMode) { vkCmdSetCullMode(commandBuffer, cullMode); }
void WRAP_vkCmdSetDepthBiasEnable(VkCommandBuffer commandBuffer, VkBool32 depthBiasEnable) { vkCmdSetDepthBiasEnable(commandBuffer, depthBiasEnable); }
void WRAP_vkCmdSetDepthBoundsTestEnable(VkCommandBuffer commandBuffer, VkBool32 depthBoundsTestEnable) { vkCmdSetDepthBoundsTestEnable(commandBuffer, depthBoundsTestEnable); }
void WRAP_vkCmdSetDepthCompareOp(VkCommandBuffer commandBuffer, VkCompareOp depthCompareOp) { vkCmdSetDepthCompareOp(commandBuffer, depthCompareOp); }
void WRAP_vkCmdSetDepthTestEnable(VkCommandBuffer commandBuffer, VkBool32 depthTestEnable) { vkCmdSetDepthTestEnable(commandBuffer, depthTestEnable); }
void WRAP_vkCmdSetDepthWriteEnable(VkCommandBuffer commandBuffer, VkBool32 depthWriteEnable) { vkCmdSetDepthWriteEnable(commandBuffer, depthWriteEnable); }
void WRAP_vkCmdSetEvent2(VkCommandBuffer                   commandBuffer, VkEvent                                             event, 
        VkDependencyInfo& pDependencyInfo) { vkCmdSetEvent2(commandBuffer, event, &pDependencyInfo); }
void WRAP_vkCmdSetFrontFace(VkCommandBuffer commandBuffer, VkFrontFace frontFace) { vkCmdSetFrontFace(commandBuffer, frontFace); }
void WRAP_vkCmdSetPrimitiveRestartEnable(VkCommandBuffer commandBuffer, VkBool32 primitiveRestartEnable) { vkCmdSetPrimitiveRestartEnable(commandBuffer, primitiveRestartEnable); }
void WRAP_vkCmdSetPrimitiveTopology(VkCommandBuffer commandBuffer, VkPrimitiveTopology primitiveTopology) { vkCmdSetPrimitiveTopology(commandBuffer, primitiveTopology); }
void WRAP_vkCmdSetRasterizerDiscardEnable(VkCommandBuffer commandBuffer, VkBool32 rasterizerDiscardEnable) { vkCmdSetRasterizerDiscardEnable(commandBuffer, rasterizerDiscardEnable); }
void WRAP_vkCmdSetScissorWithCount(VkCommandBuffer commandBuffer, uint32_t scissorCount, const VkRect2D* pScissors) { vkCmdSetScissorWithCount(commandBuffer, scissorCount, pScissors); }
void WRAP_vkCmdSetStencilOp(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, VkStencilOp failOp, VkStencilOp passOp, VkStencilOp depthFailOp, VkCompareOp compareOp) { vkCmdSetStencilOp(commandBuffer, faceMask, failOp, passOp, depthFailOp, compareOp); }
void WRAP_vkCmdSetStencilTestEnable(VkCommandBuffer commandBuffer, VkBool32 stencilTestEnable) { vkCmdSetStencilTestEnable(commandBuffer, stencilTestEnable); }
void WRAP_vkCmdSetViewportWithCount(VkCommandBuffer commandBuffer, uint32_t viewportCount, const VkViewport* pViewports) { vkCmdSetViewportWithCount(commandBuffer, viewportCount, pViewports); }
void WRAP_vkCmdWaitEvents2(VkCommandBuffer                   commandBuffer, uint32_t                                            eventCount, const VkEvent*                     pEvents, const VkDependencyInfo*            pDependencyInfos) { vkCmdWaitEvents2(commandBuffer, eventCount, pEvents, pDependencyInfos); }
void WRAP_vkCmdWriteTimestamp2(VkCommandBuffer                   commandBuffer, VkPipelineStageFlags2               stage, VkQueryPool                                         queryPool, uint32_t                                            query) { vkCmdWriteTimestamp2(commandBuffer, stage, queryPool, query); }
VkResult WRAP_vkCreatePrivateDataSlot(VkDevice device, 
            VkPrivateDataSlotCreateInfo& pCreateInfo, const VkAllocationCallbacks* pAllocator, 
        VkPrivateDataSlot& pPrivateDataSlot) { return vkCreatePrivateDataSlot(device, &pCreateInfo, pAllocator, &pPrivateDataSlot); }
void WRAP_vkDestroyPrivateDataSlot(VkDevice device, VkPrivateDataSlot privateDataSlot, const VkAllocationCallbacks* pAllocator) { vkDestroyPrivateDataSlot(device, privateDataSlot, pAllocator); }
void WRAP_vkGetDeviceBufferMemoryRequirements(VkDevice device, 
            VkDeviceBufferMemoryRequirements& pInfo, 
        VkMemoryRequirements2& pMemoryRequirements) { vkGetDeviceBufferMemoryRequirements(device, &pInfo, &pMemoryRequirements); }
void WRAP_vkGetDeviceImageMemoryRequirements(VkDevice device, 
            VkDeviceImageMemoryRequirements& pInfo, 
        VkMemoryRequirements2& pMemoryRequirements) { vkGetDeviceImageMemoryRequirements(device, &pInfo, &pMemoryRequirements); }
void WRAP_vkGetDeviceImageSparseMemoryRequirements(VkDevice device, 
            VkDeviceImageMemoryRequirements& pInfo, 
            uint32_t& pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2* pSparseMemoryRequirements) { vkGetDeviceImageSparseMemoryRequirements(device, &pInfo, &pSparseMemoryRequirementCount, pSparseMemoryRequirements); }
VkResult WRAP_vkGetPhysicalDeviceToolProperties(VkPhysicalDevice physicalDevice, 
            uint32_t& pToolCount, VkPhysicalDeviceToolProperties* pToolProperties) { return vkGetPhysicalDeviceToolProperties(physicalDevice, &pToolCount, pToolProperties); }
void WRAP_vkGetPrivateData(VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, 
        uint64_t& pData) { vkGetPrivateData(device, objectType, objectHandle, privateDataSlot, &pData); }
VkResult WRAP_vkQueueSubmit2(VkQueue                           queue, uint32_t                            submitCount, const VkSubmitInfo2*              pSubmits, VkFence           fence) { return vkQueueSubmit2(queue, submitCount, pSubmits, fence); }
VkResult WRAP_vkSetPrivateData(VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t data) { return vkSetPrivateData(device, objectType, objectHandle, privateDataSlot, data); }
#endif /* defined(VK_VERSION_1_3) */
#if defined(VK_VERSION_1_4)
void WRAP_vkCmdBindDescriptorSets2(VkCommandBuffer commandBuffer, 
        VkBindDescriptorSetsInfo& pBindDescriptorSetsInfo) { vkCmdBindDescriptorSets2(commandBuffer, &pBindDescriptorSetsInfo); }
void WRAP_vkCmdBindIndexBuffer2(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkDeviceSize size, VkIndexType indexType) { vkCmdBindIndexBuffer2(commandBuffer, buffer, offset, size, indexType); }
void WRAP_vkCmdPushConstants2(VkCommandBuffer commandBuffer, 
        VkPushConstantsInfo& pPushConstantsInfo) { vkCmdPushConstants2(commandBuffer, &pPushConstantsInfo); }
void WRAP_vkCmdPushDescriptorSet(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t set, uint32_t descriptorWriteCount, const VkWriteDescriptorSet* pDescriptorWrites) { vkCmdPushDescriptorSet(commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount, pDescriptorWrites); }
void WRAP_vkCmdPushDescriptorSet2(VkCommandBuffer commandBuffer, 
        VkPushDescriptorSetInfo& pPushDescriptorSetInfo) { vkCmdPushDescriptorSet2(commandBuffer, &pPushDescriptorSetInfo); }
void WRAP_vkCmdPushDescriptorSetWithTemplate(VkCommandBuffer commandBuffer, VkDescriptorUpdateTemplate descriptorUpdateTemplate, VkPipelineLayout layout, uint32_t set, const void* pData) { vkCmdPushDescriptorSetWithTemplate(commandBuffer, descriptorUpdateTemplate, layout, set, pData); }
void WRAP_vkCmdPushDescriptorSetWithTemplate2(VkCommandBuffer commandBuffer, 
        VkPushDescriptorSetWithTemplateInfo& pPushDescriptorSetWithTemplateInfo) { vkCmdPushDescriptorSetWithTemplate2(commandBuffer, &pPushDescriptorSetWithTemplateInfo); }
void WRAP_vkCmdSetLineStipple(VkCommandBuffer commandBuffer, uint32_t lineStippleFactor, uint16_t lineStipplePattern) { vkCmdSetLineStipple(commandBuffer, lineStippleFactor, lineStipplePattern); }
void WRAP_vkCmdSetRenderingAttachmentLocations(VkCommandBuffer commandBuffer, 
        VkRenderingAttachmentLocationInfo& pLocationInfo) { vkCmdSetRenderingAttachmentLocations(commandBuffer, &pLocationInfo); }
void WRAP_vkCmdSetRenderingInputAttachmentIndices(VkCommandBuffer commandBuffer, 
        VkRenderingInputAttachmentIndexInfo& pInputAttachmentIndexInfo) { vkCmdSetRenderingInputAttachmentIndices(commandBuffer, &pInputAttachmentIndexInfo); }
VkResult WRAP_vkCopyImageToImage(VkDevice device, 
        VkCopyImageToImageInfo& pCopyImageToImageInfo) { return vkCopyImageToImage(device, &pCopyImageToImageInfo); }
VkResult WRAP_vkCopyImageToMemory(VkDevice device, 
        VkCopyImageToMemoryInfo& pCopyImageToMemoryInfo) { return vkCopyImageToMemory(device, &pCopyImageToMemoryInfo); }
VkResult WRAP_vkCopyMemoryToImage(VkDevice device, 
        VkCopyMemoryToImageInfo& pCopyMemoryToImageInfo) { return vkCopyMemoryToImage(device, &pCopyMemoryToImageInfo); }
void WRAP_vkGetDeviceImageSubresourceLayout(VkDevice device, 
            VkDeviceImageSubresourceInfo& pInfo, 
        VkSubresourceLayout2& pLayout) { vkGetDeviceImageSubresourceLayout(device, &pInfo, &pLayout); }
void WRAP_vkGetImageSubresourceLayout2(VkDevice device, VkImage image, 
            VkImageSubresource2& pSubresource, 
        VkSubresourceLayout2& pLayout) { vkGetImageSubresourceLayout2(device, image, &pSubresource, &pLayout); }
void WRAP_vkGetRenderingAreaGranularity(VkDevice device, 
            VkRenderingAreaInfo& pRenderingAreaInfo, 
        VkExtent2D& pGranularity) { vkGetRenderingAreaGranularity(device, &pRenderingAreaInfo, &pGranularity); }
VkResult WRAP_vkMapMemory2(VkDevice device, 
            VkMemoryMapInfo& pMemoryMapInfo, void** ppData) { return vkMapMemory2(device, &pMemoryMapInfo, ppData); }
VkResult WRAP_vkTransitionImageLayout(VkDevice device, uint32_t transitionCount, const VkHostImageLayoutTransitionInfo*    pTransitions) { return vkTransitionImageLayout(device, transitionCount, pTransitions); }
VkResult WRAP_vkUnmapMemory2(VkDevice device, 
        VkMemoryUnmapInfo& pMemoryUnmapInfo) { return vkUnmapMemory2(device, &pMemoryUnmapInfo); }
#endif /* defined(VK_VERSION_1_4) */
#if defined(VK_AMDX_shader_enqueue)
void WRAP_vkCmdDispatchGraphAMDX(VkCommandBuffer                                 commandBuffer, VkDeviceAddress                                 scratch, VkDeviceSize                                    scratchSize, 
        VkDispatchGraphCountInfoAMDX& pCountInfo) { vkCmdDispatchGraphAMDX(commandBuffer, scratch, scratchSize, &pCountInfo); }
void WRAP_vkCmdDispatchGraphIndirectAMDX(VkCommandBuffer                                 commandBuffer, VkDeviceAddress                                 scratch, VkDeviceSize                                    scratchSize, 
        VkDispatchGraphCountInfoAMDX& pCountInfo) { vkCmdDispatchGraphIndirectAMDX(commandBuffer, scratch, scratchSize, &pCountInfo); }
void WRAP_vkCmdDispatchGraphIndirectCountAMDX(VkCommandBuffer                                 commandBuffer, VkDeviceAddress                                 scratch, VkDeviceSize                                    scratchSize, VkDeviceAddress                                 countInfo) { vkCmdDispatchGraphIndirectCountAMDX(commandBuffer, scratch, scratchSize, countInfo); }
void WRAP_vkCmdInitializeGraphScratchMemoryAMDX(VkCommandBuffer                                 commandBuffer, VkPipeline                                      executionGraph, VkDeviceAddress                                 scratch, VkDeviceSize                                    scratchSize) { vkCmdInitializeGraphScratchMemoryAMDX(commandBuffer, executionGraph, scratch, scratchSize); }
VkResult WRAP_vkCreateExecutionGraphPipelinesAMDX(VkDevice                                        device, VkPipelineCache                 pipelineCache, uint32_t                                        createInfoCount, const VkExecutionGraphPipelineCreateInfoAMDX* pCreateInfos, const VkAllocationCallbacks*    pAllocator, VkPipeline*               pPipelines) { return vkCreateExecutionGraphPipelinesAMDX(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines); }
VkResult WRAP_vkGetExecutionGraphPipelineNodeIndexAMDX(VkDevice                                        device, VkPipeline                                      executionGraph, 
            VkPipelineShaderStageNodeCreateInfoAMDX& pNodeInfo, 
        uint32_t& pNodeIndex) { return vkGetExecutionGraphPipelineNodeIndexAMDX(device, executionGraph, &pNodeInfo, &pNodeIndex); }
VkResult WRAP_vkGetExecutionGraphPipelineScratchSizeAMDX(VkDevice                                        device, VkPipeline                                      executionGraph, 
        VkExecutionGraphPipelineScratchSizeAMDX& pSizeInfo) { return vkGetExecutionGraphPipelineScratchSizeAMDX(device, executionGraph, &pSizeInfo); }
#endif /* defined(VK_AMDX_shader_enqueue) */
#if defined(VK_AMD_anti_lag)
void WRAP_vkAntiLagUpdateAMD(VkDevice device, 
        VkAntiLagDataAMD& pData) { vkAntiLagUpdateAMD(device, &pData); }
#endif /* defined(VK_AMD_anti_lag) */
#if defined(VK_AMD_buffer_marker)
void WRAP_vkCmdWriteBufferMarkerAMD(VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkBuffer dstBuffer, VkDeviceSize dstOffset, uint32_t marker) { vkCmdWriteBufferMarkerAMD(commandBuffer, pipelineStage, dstBuffer, dstOffset, marker); }
#endif /* defined(VK_AMD_buffer_marker) */
#if defined(VK_AMD_buffer_marker) && (defined(VK_VERSION_1_3) || defined(VK_KHR_synchronization2))
void WRAP_vkCmdWriteBufferMarker2AMD(VkCommandBuffer                   commandBuffer, VkPipelineStageFlags2               stage, VkBuffer                                            dstBuffer, VkDeviceSize                                        dstOffset, uint32_t                                            marker) { vkCmdWriteBufferMarker2AMD(commandBuffer, stage, dstBuffer, dstOffset, marker); }
#endif /* defined(VK_AMD_buffer_marker) && (defined(VK_VERSION_1_3) || defined(VK_KHR_synchronization2)) */
#if defined(VK_AMD_display_native_hdr)
void WRAP_vkSetLocalDimmingAMD(VkDevice device, VkSwapchainKHR swapChain, VkBool32 localDimmingEnable) { vkSetLocalDimmingAMD(device, swapChain, localDimmingEnable); }
#endif /* defined(VK_AMD_display_native_hdr) */
#if defined(VK_AMD_draw_indirect_count)
void WRAP_vkCmdDrawIndexedIndirectCountAMD(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) { vkCmdDrawIndexedIndirectCountAMD(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride); }
void WRAP_vkCmdDrawIndirectCountAMD(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) { vkCmdDrawIndirectCountAMD(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride); }
#endif /* defined(VK_AMD_draw_indirect_count) */
#if defined(VK_AMD_shader_info)
VkResult WRAP_vkGetShaderInfoAMD(VkDevice device, VkPipeline pipeline, VkShaderStageFlagBits shaderStage, VkShaderInfoTypeAMD infoType, 
            size_t& pInfoSize, void* pInfo) { return vkGetShaderInfoAMD(device, pipeline, shaderStage, infoType, &pInfoSize, pInfo); }
#endif /* defined(VK_AMD_shader_info) */
#if defined(VK_ANDROID_external_memory_android_hardware_buffer)
VkResult WRAP_vkGetAndroidHardwareBufferPropertiesANDROID(VkDevice device, 
            AHardwareBuffer& buffer, 
        VkAndroidHardwareBufferPropertiesANDROID& pProperties) { return vkGetAndroidHardwareBufferPropertiesANDROID(device, &buffer, &pProperties); }
VkResult WRAP_vkGetMemoryAndroidHardwareBufferANDROID(VkDevice device, 
            VkMemoryGetAndroidHardwareBufferInfoANDROID& pInfo, struct AHardwareBuffer** pBuffer) { return vkGetMemoryAndroidHardwareBufferANDROID(device, &pInfo, pBuffer); }
#endif /* defined(VK_ANDROID_external_memory_android_hardware_buffer) */
#if defined(VK_EXT_acquire_drm_display)
VkResult WRAP_vkAcquireDrmDisplayEXT(VkPhysicalDevice physicalDevice, int32_t drmFd, VkDisplayKHR display) { return vkAcquireDrmDisplayEXT(physicalDevice, drmFd, display); }
VkResult WRAP_vkGetDrmDisplayEXT(VkPhysicalDevice physicalDevice, int32_t drmFd, uint32_t connectorId, 
        VkDisplayKHR& display) { return vkGetDrmDisplayEXT(physicalDevice, drmFd, connectorId, &display); }
#endif /* defined(VK_EXT_acquire_drm_display) */
#if defined(VK_EXT_acquire_xlib_display)
VkResult WRAP_vkAcquireXlibDisplayEXT(VkPhysicalDevice physicalDevice, 
            Display& dpy, VkDisplayKHR display) { return vkAcquireXlibDisplayEXT(physicalDevice, &dpy, display); }
VkResult WRAP_vkGetRandROutputDisplayEXT(VkPhysicalDevice physicalDevice, 
            Display& dpy, RROutput rrOutput, 
        VkDisplayKHR& pDisplay) { return vkGetRandROutputDisplayEXT(physicalDevice, &dpy, rrOutput, &pDisplay); }
#endif /* defined(VK_EXT_acquire_xlib_display) */
#if defined(VK_EXT_attachment_feedback_loop_dynamic_state)
void WRAP_vkCmdSetAttachmentFeedbackLoopEnableEXT(VkCommandBuffer commandBuffer, VkImageAspectFlags aspectMask) { vkCmdSetAttachmentFeedbackLoopEnableEXT(commandBuffer, aspectMask); }
#endif /* defined(VK_EXT_attachment_feedback_loop_dynamic_state) */
#if defined(VK_EXT_buffer_device_address)
VkDeviceAddress WRAP_vkGetBufferDeviceAddressEXT(VkDevice device, 
        VkBufferDeviceAddressInfo& pInfo) { return vkGetBufferDeviceAddressEXT(device, &pInfo); }
#endif /* defined(VK_EXT_buffer_device_address) */
#if defined(VK_EXT_calibrated_timestamps)
VkResult WRAP_vkGetCalibratedTimestampsEXT(VkDevice device, uint32_t timestampCount, const VkCalibratedTimestampInfoKHR* pTimestampInfos, uint64_t* pTimestamps, 
        uint64_t& pMaxDeviation) { return vkGetCalibratedTimestampsEXT(device, timestampCount, pTimestampInfos, pTimestamps, &pMaxDeviation); }
VkResult WRAP_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(VkPhysicalDevice physicalDevice, 
            uint32_t& pTimeDomainCount, VkTimeDomainKHR* pTimeDomains) { return vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(physicalDevice, &pTimeDomainCount, pTimeDomains); }
#endif /* defined(VK_EXT_calibrated_timestamps) */
#if defined(VK_EXT_color_write_enable)
void WRAP_vkCmdSetColorWriteEnableEXT(VkCommandBuffer       commandBuffer, uint32_t                                attachmentCount, const VkBool32*   pColorWriteEnables) { vkCmdSetColorWriteEnableEXT(commandBuffer, attachmentCount, pColorWriteEnables); }
#endif /* defined(VK_EXT_color_write_enable) */
#if defined(VK_EXT_conditional_rendering)
void WRAP_vkCmdBeginConditionalRenderingEXT(VkCommandBuffer commandBuffer, 
        VkConditionalRenderingBeginInfoEXT& pConditionalRenderingBegin) { vkCmdBeginConditionalRenderingEXT(commandBuffer, &pConditionalRenderingBegin); }
void WRAP_vkCmdEndConditionalRenderingEXT(VkCommandBuffer commandBuffer) { vkCmdEndConditionalRenderingEXT(commandBuffer); }
#endif /* defined(VK_EXT_conditional_rendering) */
#if defined(VK_EXT_debug_marker)
void WRAP_vkCmdDebugMarkerBeginEXT(VkCommandBuffer commandBuffer, 
        VkDebugMarkerMarkerInfoEXT& pMarkerInfo) { vkCmdDebugMarkerBeginEXT(commandBuffer, &pMarkerInfo); }
void WRAP_vkCmdDebugMarkerEndEXT(VkCommandBuffer commandBuffer) { vkCmdDebugMarkerEndEXT(commandBuffer); }
void WRAP_vkCmdDebugMarkerInsertEXT(VkCommandBuffer commandBuffer, 
        VkDebugMarkerMarkerInfoEXT& pMarkerInfo) { vkCmdDebugMarkerInsertEXT(commandBuffer, &pMarkerInfo); }
VkResult WRAP_vkDebugMarkerSetObjectNameEXT(VkDevice device, 
        VkDebugMarkerObjectNameInfoEXT& pNameInfo) { return vkDebugMarkerSetObjectNameEXT(device, &pNameInfo); }
VkResult WRAP_vkDebugMarkerSetObjectTagEXT(VkDevice device, 
        VkDebugMarkerObjectTagInfoEXT& pTagInfo) { return vkDebugMarkerSetObjectTagEXT(device, &pTagInfo); }
#endif /* defined(VK_EXT_debug_marker) */
#if defined(VK_EXT_debug_report)
VkResult WRAP_vkCreateDebugReportCallbackEXT(VkInstance instance, 
            VkDebugReportCallbackCreateInfoEXT& pCreateInfo, const VkAllocationCallbacks* pAllocator, 
        VkDebugReportCallbackEXT& pCallback) { return vkCreateDebugReportCallbackEXT(instance, &pCreateInfo, pAllocator, &pCallback); }
void WRAP_vkDebugReportMessageEXT(VkInstance instance, VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objectType, uint64_t object, size_t location, int32_t messageCode, const char* pLayerPrefix, const char* pMessage) { vkDebugReportMessageEXT(instance, flags, objectType, object, location, messageCode, pLayerPrefix, pMessage); }
void WRAP_vkDestroyDebugReportCallbackEXT(VkInstance instance, VkDebugReportCallbackEXT callback, const VkAllocationCallbacks* pAllocator) { vkDestroyDebugReportCallbackEXT(instance, callback, pAllocator); }
#endif /* defined(VK_EXT_debug_report) */
#if defined(VK_EXT_debug_utils)
void WRAP_vkCmdBeginDebugUtilsLabelEXT(VkCommandBuffer commandBuffer, 
        VkDebugUtilsLabelEXT& pLabelInfo) { vkCmdBeginDebugUtilsLabelEXT(commandBuffer, &pLabelInfo); }
void WRAP_vkCmdEndDebugUtilsLabelEXT(VkCommandBuffer commandBuffer) { vkCmdEndDebugUtilsLabelEXT(commandBuffer); }
void WRAP_vkCmdInsertDebugUtilsLabelEXT(VkCommandBuffer commandBuffer, 
        VkDebugUtilsLabelEXT& pLabelInfo) { vkCmdInsertDebugUtilsLabelEXT(commandBuffer, &pLabelInfo); }
VkResult WRAP_vkCreateDebugUtilsMessengerEXT(VkInstance instance, 
            VkDebugUtilsMessengerCreateInfoEXT& pCreateInfo, const VkAllocationCallbacks* pAllocator, 
        VkDebugUtilsMessengerEXT& pMessenger) { return vkCreateDebugUtilsMessengerEXT(instance, &pCreateInfo, pAllocator, &pMessenger); }
void WRAP_vkDestroyDebugUtilsMessengerEXT(VkInstance instance, VkDebugUtilsMessengerEXT messenger, const VkAllocationCallbacks* pAllocator) { vkDestroyDebugUtilsMessengerEXT(instance, messenger, pAllocator); }
void WRAP_vkQueueBeginDebugUtilsLabelEXT(VkQueue queue, 
        VkDebugUtilsLabelEXT& pLabelInfo) { vkQueueBeginDebugUtilsLabelEXT(queue, &pLabelInfo); }
void WRAP_vkQueueEndDebugUtilsLabelEXT(VkQueue queue) { vkQueueEndDebugUtilsLabelEXT(queue); }
void WRAP_vkQueueInsertDebugUtilsLabelEXT(VkQueue queue, 
        VkDebugUtilsLabelEXT& pLabelInfo) { vkQueueInsertDebugUtilsLabelEXT(queue, &pLabelInfo); }
VkResult WRAP_vkSetDebugUtilsObjectNameEXT(VkDevice device, 
        VkDebugUtilsObjectNameInfoEXT& pNameInfo) { return vkSetDebugUtilsObjectNameEXT(device, &pNameInfo); }
VkResult WRAP_vkSetDebugUtilsObjectTagEXT(VkDevice device, 
        VkDebugUtilsObjectTagInfoEXT& pTagInfo) { return vkSetDebugUtilsObjectTagEXT(device, &pTagInfo); }
void WRAP_vkSubmitDebugUtilsMessageEXT(VkInstance instance, VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, VkDebugUtilsMessageTypeFlagsEXT messageTypes, 
        VkDebugUtilsMessengerCallbackDataEXT& pCallbackData) { vkSubmitDebugUtilsMessageEXT(instance, messageSeverity, messageTypes, &pCallbackData); }
#endif /* defined(VK_EXT_debug_utils) */
#if defined(VK_EXT_depth_bias_control)
void WRAP_vkCmdSetDepthBias2EXT(VkCommandBuffer commandBuffer, 
        VkDepthBiasInfoEXT& pDepthBiasInfo) { vkCmdSetDepthBias2EXT(commandBuffer, &pDepthBiasInfo); }
#endif /* defined(VK_EXT_depth_bias_control) */
#if defined(VK_EXT_descriptor_buffer)
void WRAP_vkCmdBindDescriptorBufferEmbeddedSamplersEXT(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t set) { vkCmdBindDescriptorBufferEmbeddedSamplersEXT(commandBuffer, pipelineBindPoint, layout, set); }
void WRAP_vkCmdBindDescriptorBuffersEXT(VkCommandBuffer commandBuffer, uint32_t bufferCount, const VkDescriptorBufferBindingInfoEXT* pBindingInfos) { vkCmdBindDescriptorBuffersEXT(commandBuffer, bufferCount, pBindingInfos); }
void WRAP_vkCmdSetDescriptorBufferOffsetsEXT(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t firstSet, uint32_t setCount, const uint32_t* pBufferIndices, const VkDeviceSize* pOffsets) { vkCmdSetDescriptorBufferOffsetsEXT(commandBuffer, pipelineBindPoint, layout, firstSet, setCount, pBufferIndices, pOffsets); }
VkResult WRAP_vkGetBufferOpaqueCaptureDescriptorDataEXT(VkDevice device, 
            VkBufferCaptureDescriptorDataInfoEXT& pInfo, void* pData) { return vkGetBufferOpaqueCaptureDescriptorDataEXT(device, &pInfo, pData); }
void WRAP_vkGetDescriptorEXT(VkDevice device, 
            VkDescriptorGetInfoEXT& pDescriptorInfo, size_t dataSize, void* pDescriptor) { vkGetDescriptorEXT(device, &pDescriptorInfo, dataSize, pDescriptor); }
void WRAP_vkGetDescriptorSetLayoutBindingOffsetEXT(VkDevice device, VkDescriptorSetLayout layout, uint32_t binding, 
        VkDeviceSize& pOffset) { vkGetDescriptorSetLayoutBindingOffsetEXT(device, layout, binding, &pOffset); }
void WRAP_vkGetDescriptorSetLayoutSizeEXT(VkDevice device, VkDescriptorSetLayout layout, 
        VkDeviceSize& pLayoutSizeInBytes) { vkGetDescriptorSetLayoutSizeEXT(device, layout, &pLayoutSizeInBytes); }
VkResult WRAP_vkGetImageOpaqueCaptureDescriptorDataEXT(VkDevice device, 
            VkImageCaptureDescriptorDataInfoEXT& pInfo, void* pData) { return vkGetImageOpaqueCaptureDescriptorDataEXT(device, &pInfo, pData); }
VkResult WRAP_vkGetImageViewOpaqueCaptureDescriptorDataEXT(VkDevice device, 
            VkImageViewCaptureDescriptorDataInfoEXT& pInfo, void* pData) { return vkGetImageViewOpaqueCaptureDescriptorDataEXT(device, &pInfo, pData); }
VkResult WRAP_vkGetSamplerOpaqueCaptureDescriptorDataEXT(VkDevice device, 
            VkSamplerCaptureDescriptorDataInfoEXT& pInfo, void* pData) { return vkGetSamplerOpaqueCaptureDescriptorDataEXT(device, &pInfo, pData); }
#endif /* defined(VK_EXT_descriptor_buffer) */
#if defined(VK_EXT_descriptor_buffer) && (defined(VK_KHR_acceleration_structure) || defined(VK_NV_ray_tracing))
VkResult WRAP_vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT(VkDevice device, 
            VkAccelerationStructureCaptureDescriptorDataInfoEXT& pInfo, void* pData) { return vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT(device, &pInfo, pData); }
#endif /* defined(VK_EXT_descriptor_buffer) && (defined(VK_KHR_acceleration_structure) || defined(VK_NV_ray_tracing)) */
#if defined(VK_EXT_device_fault)
VkResult WRAP_vkGetDeviceFaultInfoEXT(VkDevice device, 
            VkDeviceFaultCountsEXT& pFaultCounts, VkDeviceFaultInfoEXT* pFaultInfo) { return vkGetDeviceFaultInfoEXT(device, &pFaultCounts, pFaultInfo); }
#endif /* defined(VK_EXT_device_fault) */
#if defined(VK_EXT_device_generated_commands)
void WRAP_vkCmdExecuteGeneratedCommandsEXT(VkCommandBuffer commandBuffer, VkBool32 isPreprocessed, 
        VkGeneratedCommandsInfoEXT& pGeneratedCommandsInfo) { vkCmdExecuteGeneratedCommandsEXT(commandBuffer, isPreprocessed, &pGeneratedCommandsInfo); }
void WRAP_vkCmdPreprocessGeneratedCommandsEXT(VkCommandBuffer commandBuffer, 
            VkGeneratedCommandsInfoEXT& pGeneratedCommandsInfo, VkCommandBuffer stateCommandBuffer) { vkCmdPreprocessGeneratedCommandsEXT(commandBuffer, &pGeneratedCommandsInfo, stateCommandBuffer); }
VkResult WRAP_vkCreateIndirectCommandsLayoutEXT(VkDevice device, 
            VkIndirectCommandsLayoutCreateInfoEXT& pCreateInfo, const VkAllocationCallbacks* pAllocator, 
        VkIndirectCommandsLayoutEXT& pIndirectCommandsLayout) { return vkCreateIndirectCommandsLayoutEXT(device, &pCreateInfo, pAllocator, &pIndirectCommandsLayout); }
VkResult WRAP_vkCreateIndirectExecutionSetEXT(VkDevice device, 
            VkIndirectExecutionSetCreateInfoEXT& pCreateInfo, const VkAllocationCallbacks* pAllocator, 
        VkIndirectExecutionSetEXT& pIndirectExecutionSet) { return vkCreateIndirectExecutionSetEXT(device, &pCreateInfo, pAllocator, &pIndirectExecutionSet); }
void WRAP_vkDestroyIndirectCommandsLayoutEXT(VkDevice device, VkIndirectCommandsLayoutEXT indirectCommandsLayout, const VkAllocationCallbacks* pAllocator) { vkDestroyIndirectCommandsLayoutEXT(device, indirectCommandsLayout, pAllocator); }
void WRAP_vkDestroyIndirectExecutionSetEXT(VkDevice device, VkIndirectExecutionSetEXT indirectExecutionSet, const VkAllocationCallbacks* pAllocator) { vkDestroyIndirectExecutionSetEXT(device, indirectExecutionSet, pAllocator); }
void WRAP_vkGetGeneratedCommandsMemoryRequirementsEXT(VkDevice device, 
            VkGeneratedCommandsMemoryRequirementsInfoEXT& pInfo, 
        VkMemoryRequirements2& pMemoryRequirements) { vkGetGeneratedCommandsMemoryRequirementsEXT(device, &pInfo, &pMemoryRequirements); }
void WRAP_vkUpdateIndirectExecutionSetPipelineEXT(VkDevice device, VkIndirectExecutionSetEXT indirectExecutionSet, uint32_t executionSetWriteCount, const VkWriteIndirectExecutionSetPipelineEXT* pExecutionSetWrites) { vkUpdateIndirectExecutionSetPipelineEXT(device, indirectExecutionSet, executionSetWriteCount, pExecutionSetWrites); }
void WRAP_vkUpdateIndirectExecutionSetShaderEXT(VkDevice device, VkIndirectExecutionSetEXT indirectExecutionSet, uint32_t executionSetWriteCount, const VkWriteIndirectExecutionSetShaderEXT* pExecutionSetWrites) { vkUpdateIndirectExecutionSetShaderEXT(device, indirectExecutionSet, executionSetWriteCount, pExecutionSetWrites); }
#endif /* defined(VK_EXT_device_generated_commands) */
#if defined(VK_EXT_direct_mode_display)
VkResult WRAP_vkReleaseDisplayEXT(VkPhysicalDevice physicalDevice, VkDisplayKHR display) { return vkReleaseDisplayEXT(physicalDevice, display); }
#endif /* defined(VK_EXT_direct_mode_display) */
#if defined(VK_EXT_directfb_surface)
VkResult WRAP_vkCreateDirectFBSurfaceEXT(VkInstance instance, 
            VkDirectFBSurfaceCreateInfoEXT& pCreateInfo, const VkAllocationCallbacks* pAllocator, 
        VkSurfaceKHR& pSurface) { return vkCreateDirectFBSurfaceEXT(instance, &pCreateInfo, pAllocator, &pSurface); }
bool WRAP_vkGetPhysicalDeviceDirectFBPresentationSupportEXT(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, 
        IDirectFB& dfb) { return vkGetPhysicalDeviceDirectFBPresentationSupportEXT(physicalDevice, queueFamilyIndex, &dfb); }
#endif /* defined(VK_EXT_directfb_surface) */
#if defined(VK_EXT_discard_rectangles)
void WRAP_vkCmdSetDiscardRectangleEXT(VkCommandBuffer commandBuffer, uint32_t firstDiscardRectangle, uint32_t discardRectangleCount, const VkRect2D* pDiscardRectangles) { vkCmdSetDiscardRectangleEXT(commandBuffer, firstDiscardRectangle, discardRectangleCount, pDiscardRectangles); }
#endif /* defined(VK_EXT_discard_rectangles) */
#if defined(VK_EXT_discard_rectangles) && VK_EXT_DISCARD_RECTANGLES_SPEC_VERSION >= 2
void WRAP_vkCmdSetDiscardRectangleEnableEXT(VkCommandBuffer commandBuffer, VkBool32 discardRectangleEnable) { vkCmdSetDiscardRectangleEnableEXT(commandBuffer, discardRectangleEnable); }
void WRAP_vkCmdSetDiscardRectangleModeEXT(VkCommandBuffer commandBuffer, VkDiscardRectangleModeEXT discardRectangleMode) { vkCmdSetDiscardRectangleModeEXT(commandBuffer, discardRectangleMode); }
#endif /* defined(VK_EXT_discard_rectangles) && VK_EXT_DISCARD_RECTANGLES_SPEC_VERSION >= 2 */
#if defined(VK_EXT_display_control)
VkResult WRAP_vkDisplayPowerControlEXT(VkDevice device, VkDisplayKHR display, 
        VkDisplayPowerInfoEXT& pDisplayPowerInfo) { return vkDisplayPowerControlEXT(device, display, &pDisplayPowerInfo); }
VkResult WRAP_vkGetSwapchainCounterEXT(VkDevice device, VkSwapchainKHR swapchain, VkSurfaceCounterFlagBitsEXT counter, 
        uint64_t& pCounterValue) { return vkGetSwapchainCounterEXT(device, swapchain, counter, &pCounterValue); }
VkResult WRAP_vkRegisterDeviceEventEXT(VkDevice device, 
            VkDeviceEventInfoEXT& pDeviceEventInfo, const VkAllocationCallbacks* pAllocator, 
        VkFence& pFence) { return vkRegisterDeviceEventEXT(device, &pDeviceEventInfo, pAllocator, &pFence); }
VkResult WRAP_vkRegisterDisplayEventEXT(VkDevice device, VkDisplayKHR display, 
            VkDisplayEventInfoEXT& pDisplayEventInfo, const VkAllocationCallbacks* pAllocator, 
        VkFence& pFence) { return vkRegisterDisplayEventEXT(device, display, &pDisplayEventInfo, pAllocator, &pFence); }
#endif /* defined(VK_EXT_display_control) */
#if defined(VK_EXT_display_surface_counter)
VkResult WRAP_vkGetPhysicalDeviceSurfaceCapabilities2EXT(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, 
        VkSurfaceCapabilities2EXT& pSurfaceCapabilities) { return vkGetPhysicalDeviceSurfaceCapabilities2EXT(physicalDevice, surface, &pSurfaceCapabilities); }
#endif /* defined(VK_EXT_display_surface_counter) */
#if defined(VK_EXT_external_memory_host)
VkResult WRAP_vkGetMemoryHostPointerPropertiesEXT(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, const void* pHostPointer, 
        VkMemoryHostPointerPropertiesEXT& pMemoryHostPointerProperties) { return vkGetMemoryHostPointerPropertiesEXT(device, handleType, pHostPointer, &pMemoryHostPointerProperties); }
#endif /* defined(VK_EXT_external_memory_host) */
#if defined(VK_EXT_full_screen_exclusive)
VkResult WRAP_vkAcquireFullScreenExclusiveModeEXT(VkDevice device, VkSwapchainKHR swapchain) { return vkAcquireFullScreenExclusiveModeEXT(device, swapchain); }
VkResult WRAP_vkGetPhysicalDeviceSurfacePresentModes2EXT(VkPhysicalDevice physicalDevice, 
            VkPhysicalDeviceSurfaceInfo2KHR& pSurfaceInfo, 
            uint32_t& pPresentModeCount, VkPresentModeKHR* pPresentModes) { return vkGetPhysicalDeviceSurfacePresentModes2EXT(physicalDevice, &pSurfaceInfo, &pPresentModeCount, pPresentModes); }
VkResult WRAP_vkReleaseFullScreenExclusiveModeEXT(VkDevice device, VkSwapchainKHR swapchain) { return vkReleaseFullScreenExclusiveModeEXT(device, swapchain); }
#endif /* defined(VK_EXT_full_screen_exclusive) */
#if defined(VK_EXT_full_screen_exclusive) && (defined(VK_KHR_device_group) || defined(VK_VERSION_1_1))
VkResult WRAP_vkGetDeviceGroupSurfacePresentModes2EXT(VkDevice device, 
            VkPhysicalDeviceSurfaceInfo2KHR& pSurfaceInfo, 
        VkDeviceGroupPresentModeFlagsKHR& pModes) { return vkGetDeviceGroupSurfacePresentModes2EXT(device, &pSurfaceInfo, &pModes); }
#endif /* defined(VK_EXT_full_screen_exclusive) && (defined(VK_KHR_device_group) || defined(VK_VERSION_1_1)) */
#if defined(VK_EXT_hdr_metadata)
void WRAP_vkSetHdrMetadataEXT(VkDevice device, uint32_t swapchainCount, const VkSwapchainKHR* pSwapchains, const VkHdrMetadataEXT* pMetadata) { vkSetHdrMetadataEXT(device, swapchainCount, pSwapchains, pMetadata); }
#endif /* defined(VK_EXT_hdr_metadata) */
#if defined(VK_EXT_headless_surface)
VkResult WRAP_vkCreateHeadlessSurfaceEXT(VkInstance instance, 
            VkHeadlessSurfaceCreateInfoEXT& pCreateInfo, const VkAllocationCallbacks* pAllocator, 
        VkSurfaceKHR& pSurface) { return vkCreateHeadlessSurfaceEXT(instance, &pCreateInfo, pAllocator, &pSurface); }
#endif /* defined(VK_EXT_headless_surface) */
#if defined(VK_EXT_host_image_copy)
VkResult WRAP_vkCopyImageToImageEXT(VkDevice device, 
        VkCopyImageToImageInfo& pCopyImageToImageInfo) { return vkCopyImageToImageEXT(device, &pCopyImageToImageInfo); }
VkResult WRAP_vkCopyImageToMemoryEXT(VkDevice device, 
        VkCopyImageToMemoryInfo& pCopyImageToMemoryInfo) { return vkCopyImageToMemoryEXT(device, &pCopyImageToMemoryInfo); }
VkResult WRAP_vkCopyMemoryToImageEXT(VkDevice device, 
        VkCopyMemoryToImageInfo& pCopyMemoryToImageInfo) { return vkCopyMemoryToImageEXT(device, &pCopyMemoryToImageInfo); }
VkResult WRAP_vkTransitionImageLayoutEXT(VkDevice device, uint32_t transitionCount, const VkHostImageLayoutTransitionInfo*    pTransitions) { return vkTransitionImageLayoutEXT(device, transitionCount, pTransitions); }
#endif /* defined(VK_EXT_host_image_copy) */
#if defined(VK_EXT_host_query_reset)
void WRAP_vkResetQueryPoolEXT(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount) { vkResetQueryPoolEXT(device, queryPool, firstQuery, queryCount); }
#endif /* defined(VK_EXT_host_query_reset) */
#if defined(VK_EXT_image_drm_format_modifier)
VkResult WRAP_vkGetImageDrmFormatModifierPropertiesEXT(VkDevice device, VkImage image, 
        VkImageDrmFormatModifierPropertiesEXT& pProperties) { return vkGetImageDrmFormatModifierPropertiesEXT(device, image, &pProperties); }
#endif /* defined(VK_EXT_image_drm_format_modifier) */
#if defined(VK_EXT_line_rasterization)
void WRAP_vkCmdSetLineStippleEXT(VkCommandBuffer commandBuffer, uint32_t lineStippleFactor, uint16_t lineStipplePattern) { vkCmdSetLineStippleEXT(commandBuffer, lineStippleFactor, lineStipplePattern); }
#endif /* defined(VK_EXT_line_rasterization) */
#if defined(VK_EXT_mesh_shader)
void WRAP_vkCmdDrawMeshTasksEXT(VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ) { vkCmdDrawMeshTasksEXT(commandBuffer, groupCountX, groupCountY, groupCountZ); }
void WRAP_vkCmdDrawMeshTasksIndirectCountEXT(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) { vkCmdDrawMeshTasksIndirectCountEXT(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride); }
void WRAP_vkCmdDrawMeshTasksIndirectEXT(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride) { vkCmdDrawMeshTasksIndirectEXT(commandBuffer, buffer, offset, drawCount, stride); }
#endif /* defined(VK_EXT_mesh_shader) */
#if defined(VK_EXT_metal_objects)
void WRAP_vkExportMetalObjectsEXT(VkDevice device, 
        VkExportMetalObjectsInfoEXT& pMetalObjectsInfo) { vkExportMetalObjectsEXT(device, &pMetalObjectsInfo); }
#endif /* defined(VK_EXT_metal_objects) */
#if defined(VK_EXT_metal_surface)
VkResult WRAP_vkCreateMetalSurfaceEXT(VkInstance instance, 
            VkMetalSurfaceCreateInfoEXT& pCreateInfo, const VkAllocationCallbacks* pAllocator, 
        VkSurfaceKHR& pSurface) { return vkCreateMetalSurfaceEXT(instance, &pCreateInfo, pAllocator, &pSurface); }
#endif /* defined(VK_EXT_metal_surface) */
#if defined(VK_EXT_multi_draw)
void WRAP_vkCmdDrawMultiEXT(VkCommandBuffer commandBuffer, uint32_t drawCount, const VkMultiDrawInfoEXT* pVertexInfo, uint32_t instanceCount, uint32_t firstInstance, uint32_t stride) { vkCmdDrawMultiEXT(commandBuffer, drawCount, pVertexInfo, instanceCount, firstInstance, stride); }
void WRAP_vkCmdDrawMultiIndexedEXT(VkCommandBuffer commandBuffer, uint32_t drawCount, const VkMultiDrawIndexedInfoEXT* pIndexInfo, uint32_t instanceCount, uint32_t firstInstance, uint32_t stride, const int32_t* pVertexOffset) { vkCmdDrawMultiIndexedEXT(commandBuffer, drawCount, pIndexInfo, instanceCount, firstInstance, stride, pVertexOffset); }
#endif /* defined(VK_EXT_multi_draw) */
#if defined(VK_EXT_opacity_micromap)
VkResult WRAP_vkBuildMicromapsEXT(VkDevice                                           device, VkDeferredOperationKHR deferredOperation, uint32_t infoCount, const VkMicromapBuildInfoEXT* pInfos) { return vkBuildMicromapsEXT(device, deferredOperation, infoCount, pInfos); }
void WRAP_vkCmdBuildMicromapsEXT(VkCommandBuffer                                    commandBuffer, uint32_t infoCount, const VkMicromapBuildInfoEXT* pInfos) { vkCmdBuildMicromapsEXT(commandBuffer, infoCount, pInfos); }
void WRAP_vkCmdCopyMemoryToMicromapEXT(VkCommandBuffer commandBuffer, 
        VkCopyMemoryToMicromapInfoEXT& pInfo) { vkCmdCopyMemoryToMicromapEXT(commandBuffer, &pInfo); }
void WRAP_vkCmdCopyMicromapEXT(VkCommandBuffer commandBuffer, 
        VkCopyMicromapInfoEXT& pInfo) { vkCmdCopyMicromapEXT(commandBuffer, &pInfo); }
void WRAP_vkCmdCopyMicromapToMemoryEXT(VkCommandBuffer commandBuffer, 
        VkCopyMicromapToMemoryInfoEXT& pInfo) { vkCmdCopyMicromapToMemoryEXT(commandBuffer, &pInfo); }
void WRAP_vkCmdWriteMicromapsPropertiesEXT(VkCommandBuffer commandBuffer, uint32_t micromapCount, const VkMicromapEXT* pMicromaps, VkQueryType queryType, VkQueryPool queryPool, uint32_t firstQuery) { vkCmdWriteMicromapsPropertiesEXT(commandBuffer, micromapCount, pMicromaps, queryType, queryPool, firstQuery); }
VkResult WRAP_vkCopyMemoryToMicromapEXT(VkDevice device, VkDeferredOperationKHR deferredOperation, 
        VkCopyMemoryToMicromapInfoEXT& pInfo) { return vkCopyMemoryToMicromapEXT(device, deferredOperation, &pInfo); }
VkResult WRAP_vkCopyMicromapEXT(VkDevice device, VkDeferredOperationKHR deferredOperation, 
        VkCopyMicromapInfoEXT& pInfo) { return vkCopyMicromapEXT(device, deferredOperation, &pInfo); }
VkResult WRAP_vkCopyMicromapToMemoryEXT(VkDevice device, VkDeferredOperationKHR deferredOperation, 
        VkCopyMicromapToMemoryInfoEXT& pInfo) { return vkCopyMicromapToMemoryEXT(device, deferredOperation, &pInfo); }
VkResult WRAP_vkCreateMicromapEXT(VkDevice                                           device, 
            VkMicromapCreateInfoEXT& pCreateInfo, const VkAllocationCallbacks*       pAllocator, 
        VkMicromapEXT& pMicromap) { return vkCreateMicromapEXT(device, &pCreateInfo, pAllocator, &pMicromap); }
void WRAP_vkDestroyMicromapEXT(VkDevice device, VkMicromapEXT micromap, const VkAllocationCallbacks* pAllocator) { vkDestroyMicromapEXT(device, micromap, pAllocator); }
void WRAP_vkGetDeviceMicromapCompatibilityEXT(VkDevice device, 
            VkMicromapVersionInfoEXT& pVersionInfo, 
        VkAccelerationStructureCompatibilityKHR& pCompatibility) { vkGetDeviceMicromapCompatibilityEXT(device, &pVersionInfo, &pCompatibility); }
void WRAP_vkGetMicromapBuildSizesEXT(VkDevice                                            device, VkAccelerationStructureBuildTypeKHR                 buildType, 
            VkMicromapBuildInfoEXT& pBuildInfo, 
        VkMicromapBuildSizesInfoEXT& pSizeInfo) { vkGetMicromapBuildSizesEXT(device, buildType, &pBuildInfo, &pSizeInfo); }
VkResult WRAP_vkWriteMicromapsPropertiesEXT(VkDevice device, uint32_t micromapCount, const VkMicromapEXT* pMicromaps, VkQueryType  queryType, size_t       dataSize, void* pData, size_t stride) { return vkWriteMicromapsPropertiesEXT(device, micromapCount, pMicromaps, queryType, dataSize, pData, stride); }
#endif /* defined(VK_EXT_opacity_micromap) */
#if defined(VK_EXT_pageable_device_local_memory)
void WRAP_vkSetDeviceMemoryPriorityEXT(VkDevice       device, VkDeviceMemory memory, float          priority) { vkSetDeviceMemoryPriorityEXT(device, memory, priority); }
#endif /* defined(VK_EXT_pageable_device_local_memory) */
#if defined(VK_EXT_pipeline_properties)
VkResult WRAP_vkGetPipelinePropertiesEXT(VkDevice device, 
            VkPipelineInfoEXT& pPipelineInfo, 
        VkBaseOutStructure& pPipelineProperties) { return vkGetPipelinePropertiesEXT(device, &pPipelineInfo, &pPipelineProperties); }
#endif /* defined(VK_EXT_pipeline_properties) */
#if defined(VK_EXT_private_data)
VkResult WRAP_vkCreatePrivateDataSlotEXT(VkDevice device, 
            VkPrivateDataSlotCreateInfo& pCreateInfo, const VkAllocationCallbacks* pAllocator, 
        VkPrivateDataSlot& pPrivateDataSlot) { return vkCreatePrivateDataSlotEXT(device, &pCreateInfo, pAllocator, &pPrivateDataSlot); }
void WRAP_vkDestroyPrivateDataSlotEXT(VkDevice device, VkPrivateDataSlot privateDataSlot, const VkAllocationCallbacks* pAllocator) { vkDestroyPrivateDataSlotEXT(device, privateDataSlot, pAllocator); }
void WRAP_vkGetPrivateDataEXT(VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, 
        uint64_t& pData) { vkGetPrivateDataEXT(device, objectType, objectHandle, privateDataSlot, &pData); }
VkResult WRAP_vkSetPrivateDataEXT(VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t data) { return vkSetPrivateDataEXT(device, objectType, objectHandle, privateDataSlot, data); }
#endif /* defined(VK_EXT_private_data) */
#if defined(VK_EXT_sample_locations)
void WRAP_vkCmdSetSampleLocationsEXT(VkCommandBuffer commandBuffer, 
        VkSampleLocationsInfoEXT& pSampleLocationsInfo) { vkCmdSetSampleLocationsEXT(commandBuffer, &pSampleLocationsInfo); }
void WRAP_vkGetPhysicalDeviceMultisamplePropertiesEXT(VkPhysicalDevice physicalDevice, VkSampleCountFlagBits samples, 
        VkMultisamplePropertiesEXT& pMultisampleProperties) { vkGetPhysicalDeviceMultisamplePropertiesEXT(physicalDevice, samples, &pMultisampleProperties); }
#endif /* defined(VK_EXT_sample_locations) */
#if defined(VK_EXT_shader_module_identifier)
void WRAP_vkGetShaderModuleCreateInfoIdentifierEXT(VkDevice device, 
            VkShaderModuleCreateInfo& pCreateInfo, 
        VkShaderModuleIdentifierEXT& pIdentifier) { vkGetShaderModuleCreateInfoIdentifierEXT(device, &pCreateInfo, &pIdentifier); }
void WRAP_vkGetShaderModuleIdentifierEXT(VkDevice device, VkShaderModule shaderModule, 
        VkShaderModuleIdentifierEXT& pIdentifier) { vkGetShaderModuleIdentifierEXT(device, shaderModule, &pIdentifier); }
#endif /* defined(VK_EXT_shader_module_identifier) */
#if defined(VK_EXT_shader_object)
void WRAP_vkCmdBindShadersEXT(VkCommandBuffer commandBuffer, uint32_t stageCount, const VkShaderStageFlagBits* pStages, const VkShaderEXT* pShaders) { vkCmdBindShadersEXT(commandBuffer, stageCount, pStages, pShaders); }
VkResult WRAP_vkCreateShadersEXT(VkDevice device, uint32_t createInfoCount, const VkShaderCreateInfoEXT* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkShaderEXT* pShaders) { return vkCreateShadersEXT(device, createInfoCount, pCreateInfos, pAllocator, pShaders); }
void WRAP_vkDestroyShaderEXT(VkDevice device, VkShaderEXT shader, const VkAllocationCallbacks* pAllocator) { vkDestroyShaderEXT(device, shader, pAllocator); }
VkResult WRAP_vkGetShaderBinaryDataEXT(VkDevice device, VkShaderEXT shader, 
            size_t& pDataSize, void* pData) { return vkGetShaderBinaryDataEXT(device, shader, &pDataSize, pData); }
#endif /* defined(VK_EXT_shader_object) */
#if defined(VK_EXT_swapchain_maintenance1)
VkResult WRAP_vkReleaseSwapchainImagesEXT(VkDevice device, 
        VkReleaseSwapchainImagesInfoEXT& pReleaseInfo) { return vkReleaseSwapchainImagesEXT(device, &pReleaseInfo); }
#endif /* defined(VK_EXT_swapchain_maintenance1) */
#if defined(VK_EXT_tooling_info)
VkResult WRAP_vkGetPhysicalDeviceToolPropertiesEXT(VkPhysicalDevice physicalDevice, 
            uint32_t& pToolCount, VkPhysicalDeviceToolProperties* pToolProperties) { return vkGetPhysicalDeviceToolPropertiesEXT(physicalDevice, &pToolCount, pToolProperties); }
#endif /* defined(VK_EXT_tooling_info) */
#if defined(VK_EXT_transform_feedback)
void WRAP_vkCmdBeginQueryIndexedEXT(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, VkQueryControlFlags flags, uint32_t index) { vkCmdBeginQueryIndexedEXT(commandBuffer, queryPool, query, flags, index); }
void WRAP_vkCmdBeginTransformFeedbackEXT(VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer, uint32_t counterBufferCount, const VkBuffer* pCounterBuffers, const VkDeviceSize* pCounterBufferOffsets) { vkCmdBeginTransformFeedbackEXT(commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets); }
void WRAP_vkCmdBindTransformFeedbackBuffersEXT(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer* pBuffers, const VkDeviceSize* pOffsets, const VkDeviceSize* pSizes) { vkCmdBindTransformFeedbackBuffersEXT(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes); }
void WRAP_vkCmdDrawIndirectByteCountEXT(VkCommandBuffer commandBuffer, uint32_t instanceCount, uint32_t firstInstance, VkBuffer counterBuffer, VkDeviceSize counterBufferOffset, uint32_t counterOffset, uint32_t vertexStride) { vkCmdDrawIndirectByteCountEXT(commandBuffer, instanceCount, firstInstance, counterBuffer, counterBufferOffset, counterOffset, vertexStride); }
void WRAP_vkCmdEndQueryIndexedEXT(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, uint32_t index) { vkCmdEndQueryIndexedEXT(commandBuffer, queryPool, query, index); }
void WRAP_vkCmdEndTransformFeedbackEXT(VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer, uint32_t counterBufferCount, const VkBuffer* pCounterBuffers, const VkDeviceSize* pCounterBufferOffsets) { vkCmdEndTransformFeedbackEXT(commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets); }
#endif /* defined(VK_EXT_transform_feedback) */
#if defined(VK_EXT_validation_cache)
VkResult WRAP_vkCreateValidationCacheEXT(VkDevice device, 
            VkValidationCacheCreateInfoEXT& pCreateInfo, const VkAllocationCallbacks* pAllocator, 
        VkValidationCacheEXT& pValidationCache) { return vkCreateValidationCacheEXT(device, &pCreateInfo, pAllocator, &pValidationCache); }
void WRAP_vkDestroyValidationCacheEXT(VkDevice device, VkValidationCacheEXT validationCache, const VkAllocationCallbacks* pAllocator) { vkDestroyValidationCacheEXT(device, validationCache, pAllocator); }
VkResult WRAP_vkGetValidationCacheDataEXT(VkDevice device, VkValidationCacheEXT validationCache, 
            size_t& pDataSize, void* pData) { return vkGetValidationCacheDataEXT(device, validationCache, &pDataSize, pData); }
VkResult WRAP_vkMergeValidationCachesEXT(VkDevice device, VkValidationCacheEXT dstCache, uint32_t srcCacheCount, const VkValidationCacheEXT* pSrcCaches) { return vkMergeValidationCachesEXT(device, dstCache, srcCacheCount, pSrcCaches); }
#endif /* defined(VK_EXT_validation_cache) */
#if defined(VK_FUCHSIA_buffer_collection)
VkResult WRAP_vkCreateBufferCollectionFUCHSIA(VkDevice device, 
            VkBufferCollectionCreateInfoFUCHSIA& pCreateInfo, const VkAllocationCallbacks* pAllocator, 
        VkBufferCollectionFUCHSIA& pCollection) { return vkCreateBufferCollectionFUCHSIA(device, &pCreateInfo, pAllocator, &pCollection); }
void WRAP_vkDestroyBufferCollectionFUCHSIA(VkDevice device, VkBufferCollectionFUCHSIA collection, const VkAllocationCallbacks* pAllocator) { vkDestroyBufferCollectionFUCHSIA(device, collection, pAllocator); }
VkResult WRAP_vkGetBufferCollectionPropertiesFUCHSIA(VkDevice device, VkBufferCollectionFUCHSIA collection, 
        VkBufferCollectionPropertiesFUCHSIA& pProperties) { return vkGetBufferCollectionPropertiesFUCHSIA(device, collection, &pProperties); }
VkResult WRAP_vkSetBufferCollectionBufferConstraintsFUCHSIA(VkDevice device, VkBufferCollectionFUCHSIA collection, 
        VkBufferConstraintsInfoFUCHSIA& pBufferConstraintsInfo) { return vkSetBufferCollectionBufferConstraintsFUCHSIA(device, collection, &pBufferConstraintsInfo); }
VkResult WRAP_vkSetBufferCollectionImageConstraintsFUCHSIA(VkDevice device, VkBufferCollectionFUCHSIA collection, 
        VkImageConstraintsInfoFUCHSIA& pImageConstraintsInfo) { return vkSetBufferCollectionImageConstraintsFUCHSIA(device, collection, &pImageConstraintsInfo); }
#endif /* defined(VK_FUCHSIA_buffer_collection) */
#if defined(VK_FUCHSIA_external_memory)
VkResult WRAP_vkGetMemoryZirconHandleFUCHSIA(VkDevice device, 
            VkMemoryGetZirconHandleInfoFUCHSIA& pGetZirconHandleInfo, 
        zx_handle_t& pZirconHandle) { return vkGetMemoryZirconHandleFUCHSIA(device, &pGetZirconHandleInfo, &pZirconHandle); }
VkResult WRAP_vkGetMemoryZirconHandlePropertiesFUCHSIA(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, zx_handle_t zirconHandle, 
        VkMemoryZirconHandlePropertiesFUCHSIA& pMemoryZirconHandleProperties) { return vkGetMemoryZirconHandlePropertiesFUCHSIA(device, handleType, zirconHandle, &pMemoryZirconHandleProperties); }
#endif /* defined(VK_FUCHSIA_external_memory) */
#if defined(VK_FUCHSIA_external_semaphore)
VkResult WRAP_vkGetSemaphoreZirconHandleFUCHSIA(VkDevice device, 
            VkSemaphoreGetZirconHandleInfoFUCHSIA& pGetZirconHandleInfo, 
        zx_handle_t& pZirconHandle) { return vkGetSemaphoreZirconHandleFUCHSIA(device, &pGetZirconHandleInfo, &pZirconHandle); }
VkResult WRAP_vkImportSemaphoreZirconHandleFUCHSIA(VkDevice device, 
        VkImportSemaphoreZirconHandleInfoFUCHSIA& pImportSemaphoreZirconHandleInfo) { return vkImportSemaphoreZirconHandleFUCHSIA(device, &pImportSemaphoreZirconHandleInfo); }
#endif /* defined(VK_FUCHSIA_external_semaphore) */
#if defined(VK_FUCHSIA_imagepipe_surface)
VkResult WRAP_vkCreateImagePipeSurfaceFUCHSIA(VkInstance instance, 
            VkImagePipeSurfaceCreateInfoFUCHSIA& pCreateInfo, const VkAllocationCallbacks* pAllocator, 
        VkSurfaceKHR& pSurface) { return vkCreateImagePipeSurfaceFUCHSIA(instance, &pCreateInfo, pAllocator, &pSurface); }
#endif /* defined(VK_FUCHSIA_imagepipe_surface) */
#if defined(VK_GGP_stream_descriptor_surface)
VkResult WRAP_vkCreateStreamDescriptorSurfaceGGP(VkInstance instance, 
            VkStreamDescriptorSurfaceCreateInfoGGP& pCreateInfo, const VkAllocationCallbacks* pAllocator, 
        VkSurfaceKHR& pSurface) { return vkCreateStreamDescriptorSurfaceGGP(instance, &pCreateInfo, pAllocator, &pSurface); }
#endif /* defined(VK_GGP_stream_descriptor_surface) */
#if defined(VK_GOOGLE_display_timing)
VkResult WRAP_vkGetPastPresentationTimingGOOGLE(VkDevice device, VkSwapchainKHR swapchain, 
            uint32_t& pPresentationTimingCount, VkPastPresentationTimingGOOGLE* pPresentationTimings) { return vkGetPastPresentationTimingGOOGLE(device, swapchain, &pPresentationTimingCount, pPresentationTimings); }
VkResult WRAP_vkGetRefreshCycleDurationGOOGLE(VkDevice device, VkSwapchainKHR swapchain, 
        VkRefreshCycleDurationGOOGLE& pDisplayTimingProperties) { return vkGetRefreshCycleDurationGOOGLE(device, swapchain, &pDisplayTimingProperties); }
#endif /* defined(VK_GOOGLE_display_timing) */
#if defined(VK_HUAWEI_cluster_culling_shader)
void WRAP_vkCmdDrawClusterHUAWEI(VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ) { vkCmdDrawClusterHUAWEI(commandBuffer, groupCountX, groupCountY, groupCountZ); }
void WRAP_vkCmdDrawClusterIndirectHUAWEI(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset) { vkCmdDrawClusterIndirectHUAWEI(commandBuffer, buffer, offset); }
#endif /* defined(VK_HUAWEI_cluster_culling_shader) */
#if defined(VK_HUAWEI_invocation_mask)
void WRAP_vkCmdBindInvocationMaskHUAWEI(VkCommandBuffer commandBuffer, VkImageView imageView, VkImageLayout imageLayout) { vkCmdBindInvocationMaskHUAWEI(commandBuffer, imageView, imageLayout); }
#endif /* defined(VK_HUAWEI_invocation_mask) */
#if defined(VK_HUAWEI_subpass_shading)
void WRAP_vkCmdSubpassShadingHUAWEI(VkCommandBuffer commandBuffer) { vkCmdSubpassShadingHUAWEI(commandBuffer); }
VkResult WRAP_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(VkDevice device, VkRenderPass renderpass, VkExtent2D* pMaxWorkgroupSize) { return vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(device, renderpass, pMaxWorkgroupSize); }
#endif /* defined(VK_HUAWEI_subpass_shading) */
#if defined(VK_INTEL_performance_query)
VkResult WRAP_vkAcquirePerformanceConfigurationINTEL(VkDevice device, 
            VkPerformanceConfigurationAcquireInfoINTEL& pAcquireInfo, 
        VkPerformanceConfigurationINTEL& pConfiguration) { return vkAcquirePerformanceConfigurationINTEL(device, &pAcquireInfo, &pConfiguration); }
VkResult WRAP_vkCmdSetPerformanceMarkerINTEL(VkCommandBuffer commandBuffer, 
        VkPerformanceMarkerInfoINTEL& pMarkerInfo) { return vkCmdSetPerformanceMarkerINTEL(commandBuffer, &pMarkerInfo); }
VkResult WRAP_vkCmdSetPerformanceOverrideINTEL(VkCommandBuffer commandBuffer, 
        VkPerformanceOverrideInfoINTEL& pOverrideInfo) { return vkCmdSetPerformanceOverrideINTEL(commandBuffer, &pOverrideInfo); }
VkResult WRAP_vkCmdSetPerformanceStreamMarkerINTEL(VkCommandBuffer commandBuffer, 
        VkPerformanceStreamMarkerInfoINTEL& pMarkerInfo) { return vkCmdSetPerformanceStreamMarkerINTEL(commandBuffer, &pMarkerInfo); }
VkResult WRAP_vkGetPerformanceParameterINTEL(VkDevice device, VkPerformanceParameterTypeINTEL parameter, 
        VkPerformanceValueINTEL& pValue) { return vkGetPerformanceParameterINTEL(device, parameter, &pValue); }
VkResult WRAP_vkInitializePerformanceApiINTEL(VkDevice device, 
        VkInitializePerformanceApiInfoINTEL& pInitializeInfo) { return vkInitializePerformanceApiINTEL(device, &pInitializeInfo); }
VkResult WRAP_vkQueueSetPerformanceConfigurationINTEL(VkQueue queue, VkPerformanceConfigurationINTEL configuration) { return vkQueueSetPerformanceConfigurationINTEL(queue, configuration); }
VkResult WRAP_vkReleasePerformanceConfigurationINTEL(VkDevice device, VkPerformanceConfigurationINTEL configuration) { return vkReleasePerformanceConfigurationINTEL(device, configuration); }
void WRAP_vkUninitializePerformanceApiINTEL(VkDevice device) { vkUninitializePerformanceApiINTEL(device); }
#endif /* defined(VK_INTEL_performance_query) */
#if defined(VK_KHR_acceleration_structure)
VkResult WRAP_vkBuildAccelerationStructuresKHR(VkDevice                                           device, VkDeferredOperationKHR deferredOperation, uint32_t infoCount, const VkAccelerationStructureBuildGeometryInfoKHR* pInfos, const VkAccelerationStructureBuildRangeInfoKHR* const* ppBuildRangeInfos) { return vkBuildAccelerationStructuresKHR(device, deferredOperation, infoCount, pInfos, ppBuildRangeInfos); }
void WRAP_vkCmdBuildAccelerationStructuresIndirectKHR(VkCommandBuffer                  commandBuffer, uint32_t                                           infoCount, const VkAccelerationStructureBuildGeometryInfoKHR* pInfos, const VkDeviceAddress*             pIndirectDeviceAddresses, const uint32_t*                    pIndirectStrides, const uint32_t* const*             ppMaxPrimitiveCounts) { vkCmdBuildAccelerationStructuresIndirectKHR(commandBuffer, infoCount, pInfos, pIndirectDeviceAddresses, pIndirectStrides, ppMaxPrimitiveCounts); }
void WRAP_vkCmdBuildAccelerationStructuresKHR(VkCommandBuffer                                    commandBuffer, uint32_t infoCount, const VkAccelerationStructureBuildGeometryInfoKHR* pInfos, const VkAccelerationStructureBuildRangeInfoKHR* const* ppBuildRangeInfos) { vkCmdBuildAccelerationStructuresKHR(commandBuffer, infoCount, pInfos, ppBuildRangeInfos); }
void WRAP_vkCmdCopyAccelerationStructureKHR(VkCommandBuffer commandBuffer, 
        VkCopyAccelerationStructureInfoKHR& pInfo) { vkCmdCopyAccelerationStructureKHR(commandBuffer, &pInfo); }
void WRAP_vkCmdCopyAccelerationStructureToMemoryKHR(VkCommandBuffer commandBuffer, 
        VkCopyAccelerationStructureToMemoryInfoKHR& pInfo) { vkCmdCopyAccelerationStructureToMemoryKHR(commandBuffer, &pInfo); }
void WRAP_vkCmdCopyMemoryToAccelerationStructureKHR(VkCommandBuffer commandBuffer, 
        VkCopyMemoryToAccelerationStructureInfoKHR& pInfo) { vkCmdCopyMemoryToAccelerationStructureKHR(commandBuffer, &pInfo); }
void WRAP_vkCmdWriteAccelerationStructuresPropertiesKHR(VkCommandBuffer commandBuffer, uint32_t accelerationStructureCount, const VkAccelerationStructureKHR* pAccelerationStructures, VkQueryType queryType, VkQueryPool queryPool, uint32_t firstQuery) { vkCmdWriteAccelerationStructuresPropertiesKHR(commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery); }
VkResult WRAP_vkCopyAccelerationStructureKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, 
        VkCopyAccelerationStructureInfoKHR& pInfo) { return vkCopyAccelerationStructureKHR(device, deferredOperation, &pInfo); }
VkResult WRAP_vkCopyAccelerationStructureToMemoryKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, 
        VkCopyAccelerationStructureToMemoryInfoKHR& pInfo) { return vkCopyAccelerationStructureToMemoryKHR(device, deferredOperation, &pInfo); }
VkResult WRAP_vkCopyMemoryToAccelerationStructureKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, 
        VkCopyMemoryToAccelerationStructureInfoKHR& pInfo) { return vkCopyMemoryToAccelerationStructureKHR(device, deferredOperation, &pInfo); }
VkResult WRAP_vkCreateAccelerationStructureKHR(VkDevice                                           device, 
            VkAccelerationStructureCreateInfoKHR& pCreateInfo, const VkAllocationCallbacks*       pAllocator, 
        VkAccelerationStructureKHR& pAccelerationStructure) { return vkCreateAccelerationStructureKHR(device, &pCreateInfo, pAllocator, &pAccelerationStructure); }
void WRAP_vkDestroyAccelerationStructureKHR(VkDevice device, VkAccelerationStructureKHR accelerationStructure, const VkAllocationCallbacks* pAllocator) { vkDestroyAccelerationStructureKHR(device, accelerationStructure, pAllocator); }
void WRAP_vkGetAccelerationStructureBuildSizesKHR(VkDevice                                            device, VkAccelerationStructureBuildTypeKHR                 buildType, 
            VkAccelerationStructureBuildGeometryInfoKHR& pBuildInfo, const uint32_t*  pMaxPrimitiveCounts, 
        VkAccelerationStructureBuildSizesInfoKHR& pSizeInfo) { vkGetAccelerationStructureBuildSizesKHR(device, buildType, &pBuildInfo, pMaxPrimitiveCounts, &pSizeInfo); }
VkDeviceAddress WRAP_vkGetAccelerationStructureDeviceAddressKHR(VkDevice device, 
        VkAccelerationStructureDeviceAddressInfoKHR& pInfo) { return vkGetAccelerationStructureDeviceAddressKHR(device, &pInfo); }
void WRAP_vkGetDeviceAccelerationStructureCompatibilityKHR(VkDevice device, 
            VkAccelerationStructureVersionInfoKHR& pVersionInfo, 
        VkAccelerationStructureCompatibilityKHR& pCompatibility) { vkGetDeviceAccelerationStructureCompatibilityKHR(device, &pVersionInfo, &pCompatibility); }
VkResult WRAP_vkWriteAccelerationStructuresPropertiesKHR(VkDevice device, uint32_t accelerationStructureCount, const VkAccelerationStructureKHR* pAccelerationStructures, VkQueryType  queryType, size_t       dataSize, void* pData, size_t stride) { return vkWriteAccelerationStructuresPropertiesKHR(device, accelerationStructureCount, pAccelerationStructures, queryType, dataSize, pData, stride); }
#endif /* defined(VK_KHR_acceleration_structure) */
#if defined(VK_KHR_android_surface)
VkResult WRAP_vkCreateAndroidSurfaceKHR(VkInstance instance, 
            VkAndroidSurfaceCreateInfoKHR& pCreateInfo, const VkAllocationCallbacks* pAllocator, 
        VkSurfaceKHR& pSurface) { return vkCreateAndroidSurfaceKHR(instance, &pCreateInfo, pAllocator, &pSurface); }
#endif /* defined(VK_KHR_android_surface) */
#if defined(VK_KHR_bind_memory2)
VkResult WRAP_vkBindBufferMemory2KHR(VkDevice device, uint32_t bindInfoCount, const VkBindBufferMemoryInfo* pBindInfos) { return vkBindBufferMemory2KHR(device, bindInfoCount, pBindInfos); }
VkResult WRAP_vkBindImageMemory2KHR(VkDevice device, uint32_t bindInfoCount, const VkBindImageMemoryInfo* pBindInfos) { return vkBindImageMemory2KHR(device, bindInfoCount, pBindInfos); }
#endif /* defined(VK_KHR_bind_memory2) */
#if defined(VK_KHR_buffer_device_address)
VkDeviceAddress WRAP_vkGetBufferDeviceAddressKHR(VkDevice device, 
        VkBufferDeviceAddressInfo& pInfo) { return vkGetBufferDeviceAddressKHR(device, &pInfo); }
uint64_t WRAP_vkGetBufferOpaqueCaptureAddressKHR(VkDevice device, 
        VkBufferDeviceAddressInfo& pInfo) { return vkGetBufferOpaqueCaptureAddressKHR(device, &pInfo); }
uint64_t WRAP_vkGetDeviceMemoryOpaqueCaptureAddressKHR(VkDevice device, 
        VkDeviceMemoryOpaqueCaptureAddressInfo& pInfo) { return vkGetDeviceMemoryOpaqueCaptureAddressKHR(device, &pInfo); }
#endif /* defined(VK_KHR_buffer_device_address) */
#if defined(VK_KHR_calibrated_timestamps)
VkResult WRAP_vkGetCalibratedTimestampsKHR(VkDevice device, uint32_t timestampCount, const VkCalibratedTimestampInfoKHR* pTimestampInfos, uint64_t* pTimestamps, 
        uint64_t& pMaxDeviation) { return vkGetCalibratedTimestampsKHR(device, timestampCount, pTimestampInfos, pTimestamps, &pMaxDeviation); }
VkResult WRAP_vkGetPhysicalDeviceCalibrateableTimeDomainsKHR(VkPhysicalDevice physicalDevice, 
            uint32_t& pTimeDomainCount, VkTimeDomainKHR* pTimeDomains) { return vkGetPhysicalDeviceCalibrateableTimeDomainsKHR(physicalDevice, &pTimeDomainCount, pTimeDomains); }
#endif /* defined(VK_KHR_calibrated_timestamps) */
#if defined(VK_KHR_cooperative_matrix)
VkResult WRAP_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR(VkPhysicalDevice physicalDevice, 
            uint32_t& pPropertyCount, VkCooperativeMatrixPropertiesKHR* pProperties) { return vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR(physicalDevice, &pPropertyCount, pProperties); }
#endif /* defined(VK_KHR_cooperative_matrix) */
#if defined(VK_KHR_copy_commands2)
void WRAP_vkCmdBlitImage2KHR(VkCommandBuffer commandBuffer, 
        VkBlitImageInfo2& pBlitImageInfo) { vkCmdBlitImage2KHR(commandBuffer, &pBlitImageInfo); }
void WRAP_vkCmdCopyBuffer2KHR(VkCommandBuffer commandBuffer, 
        VkCopyBufferInfo2& pCopyBufferInfo) { vkCmdCopyBuffer2KHR(commandBuffer, &pCopyBufferInfo); }
void WRAP_vkCmdCopyBufferToImage2KHR(VkCommandBuffer commandBuffer, 
        VkCopyBufferToImageInfo2& pCopyBufferToImageInfo) { vkCmdCopyBufferToImage2KHR(commandBuffer, &pCopyBufferToImageInfo); }
void WRAP_vkCmdCopyImage2KHR(VkCommandBuffer commandBuffer, 
        VkCopyImageInfo2& pCopyImageInfo) { vkCmdCopyImage2KHR(commandBuffer, &pCopyImageInfo); }
void WRAP_vkCmdCopyImageToBuffer2KHR(VkCommandBuffer commandBuffer, 
        VkCopyImageToBufferInfo2& pCopyImageToBufferInfo) { vkCmdCopyImageToBuffer2KHR(commandBuffer, &pCopyImageToBufferInfo); }
void WRAP_vkCmdResolveImage2KHR(VkCommandBuffer commandBuffer, 
        VkResolveImageInfo2& pResolveImageInfo) { vkCmdResolveImage2KHR(commandBuffer, &pResolveImageInfo); }
#endif /* defined(VK_KHR_copy_commands2) */
#if defined(VK_KHR_create_renderpass2)
void WRAP_vkCmdBeginRenderPass2KHR(VkCommandBuffer commandBuffer, 
            VkRenderPassBeginInfo& pRenderPassBegin, 
        VkSubpassBeginInfo& pSubpassBeginInfo) { vkCmdBeginRenderPass2KHR(commandBuffer, &pRenderPassBegin, &pSubpassBeginInfo); }
void WRAP_vkCmdEndRenderPass2KHR(VkCommandBuffer commandBuffer, 
        VkSubpassEndInfo& pSubpassEndInfo) { vkCmdEndRenderPass2KHR(commandBuffer, &pSubpassEndInfo); }
void WRAP_vkCmdNextSubpass2KHR(VkCommandBuffer commandBuffer, 
            VkSubpassBeginInfo& pSubpassBeginInfo, 
        VkSubpassEndInfo& pSubpassEndInfo) { vkCmdNextSubpass2KHR(commandBuffer, &pSubpassBeginInfo, &pSubpassEndInfo); }
VkResult WRAP_vkCreateRenderPass2KHR(VkDevice device, 
            VkRenderPassCreateInfo2& pCreateInfo, const VkAllocationCallbacks* pAllocator, 
        VkRenderPass& pRenderPass) { return vkCreateRenderPass2KHR(device, &pCreateInfo, pAllocator, &pRenderPass); }
#endif /* defined(VK_KHR_create_renderpass2) */
#if defined(VK_KHR_deferred_host_operations)
VkResult WRAP_vkCreateDeferredOperationKHR(VkDevice device, const VkAllocationCallbacks* pAllocator, 
        VkDeferredOperationKHR& pDeferredOperation) { return vkCreateDeferredOperationKHR(device, pAllocator, &pDeferredOperation); }
VkResult WRAP_vkDeferredOperationJoinKHR(VkDevice device, VkDeferredOperationKHR operation) { return vkDeferredOperationJoinKHR(device, operation); }
void WRAP_vkDestroyDeferredOperationKHR(VkDevice device, VkDeferredOperationKHR operation, const VkAllocationCallbacks* pAllocator) { vkDestroyDeferredOperationKHR(device, operation, pAllocator); }
uint32_t WRAP_vkGetDeferredOperationMaxConcurrencyKHR(VkDevice device, VkDeferredOperationKHR operation) { return vkGetDeferredOperationMaxConcurrencyKHR(device, operation); }
VkResult WRAP_vkGetDeferredOperationResultKHR(VkDevice device, VkDeferredOperationKHR operation) { return vkGetDeferredOperationResultKHR(device, operation); }
#endif /* defined(VK_KHR_deferred_host_operations) */
#if defined(VK_KHR_descriptor_update_template)
VkResult WRAP_vkCreateDescriptorUpdateTemplateKHR(VkDevice device, 
            VkDescriptorUpdateTemplateCreateInfo& pCreateInfo, const VkAllocationCallbacks* pAllocator, 
        VkDescriptorUpdateTemplate& pDescriptorUpdateTemplate) { return vkCreateDescriptorUpdateTemplateKHR(device, &pCreateInfo, pAllocator, &pDescriptorUpdateTemplate); }
void WRAP_vkDestroyDescriptorUpdateTemplateKHR(VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const VkAllocationCallbacks* pAllocator) { vkDestroyDescriptorUpdateTemplateKHR(device, descriptorUpdateTemplate, pAllocator); }
void WRAP_vkUpdateDescriptorSetWithTemplateKHR(VkDevice device, VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const void* pData) { vkUpdateDescriptorSetWithTemplateKHR(device, descriptorSet, descriptorUpdateTemplate, pData); }
#endif /* defined(VK_KHR_descriptor_update_template) */
#if defined(VK_KHR_device_group)
void WRAP_vkCmdDispatchBaseKHR(VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ) { vkCmdDispatchBaseKHR(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ); }
void WRAP_vkCmdSetDeviceMaskKHR(VkCommandBuffer commandBuffer, uint32_t deviceMask) { vkCmdSetDeviceMaskKHR(commandBuffer, deviceMask); }
void WRAP_vkGetDeviceGroupPeerMemoryFeaturesKHR(VkDevice device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, 
        VkPeerMemoryFeatureFlags& pPeerMemoryFeatures) { vkGetDeviceGroupPeerMemoryFeaturesKHR(device, heapIndex, localDeviceIndex, remoteDeviceIndex, &pPeerMemoryFeatures); }
#endif /* defined(VK_KHR_device_group) */
#if defined(VK_KHR_device_group_creation)
VkResult WRAP_vkEnumeratePhysicalDeviceGroupsKHR(VkInstance instance, 
            uint32_t& pPhysicalDeviceGroupCount, VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties) { return vkEnumeratePhysicalDeviceGroupsKHR(instance, &pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties); }
#endif /* defined(VK_KHR_device_group_creation) */
#if defined(VK_KHR_display)
VkResult WRAP_vkCreateDisplayModeKHR(VkPhysicalDevice physicalDevice, VkDisplayKHR display, 
            VkDisplayModeCreateInfoKHR& pCreateInfo, const VkAllocationCallbacks* pAllocator, 
        VkDisplayModeKHR& pMode) { return vkCreateDisplayModeKHR(physicalDevice, display, &pCreateInfo, pAllocator, &pMode); }
VkResult WRAP_vkCreateDisplayPlaneSurfaceKHR(VkInstance instance, 
            VkDisplaySurfaceCreateInfoKHR& pCreateInfo, const VkAllocationCallbacks* pAllocator, 
        VkSurfaceKHR& pSurface) { return vkCreateDisplayPlaneSurfaceKHR(instance, &pCreateInfo, pAllocator, &pSurface); }
VkResult WRAP_vkGetDisplayModePropertiesKHR(VkPhysicalDevice physicalDevice, VkDisplayKHR display, 
            uint32_t& pPropertyCount, VkDisplayModePropertiesKHR* pProperties) { return vkGetDisplayModePropertiesKHR(physicalDevice, display, &pPropertyCount, pProperties); }
VkResult WRAP_vkGetDisplayPlaneCapabilitiesKHR(VkPhysicalDevice physicalDevice, VkDisplayModeKHR mode, uint32_t planeIndex, 
        VkDisplayPlaneCapabilitiesKHR& pCapabilities) { return vkGetDisplayPlaneCapabilitiesKHR(physicalDevice, mode, planeIndex, &pCapabilities); }
VkResult WRAP_vkGetDisplayPlaneSupportedDisplaysKHR(VkPhysicalDevice physicalDevice, uint32_t planeIndex, 
            uint32_t& pDisplayCount, VkDisplayKHR* pDisplays) { return vkGetDisplayPlaneSupportedDisplaysKHR(physicalDevice, planeIndex, &pDisplayCount, pDisplays); }
VkResult WRAP_vkGetPhysicalDeviceDisplayPlanePropertiesKHR(VkPhysicalDevice physicalDevice, 
            uint32_t& pPropertyCount, VkDisplayPlanePropertiesKHR* pProperties) { return vkGetPhysicalDeviceDisplayPlanePropertiesKHR(physicalDevice, &pPropertyCount, pProperties); }
VkResult WRAP_vkGetPhysicalDeviceDisplayPropertiesKHR(VkPhysicalDevice physicalDevice, 
            uint32_t& pPropertyCount, VkDisplayPropertiesKHR* pProperties) { return vkGetPhysicalDeviceDisplayPropertiesKHR(physicalDevice, &pPropertyCount, pProperties); }
#endif /* defined(VK_KHR_display) */
#if defined(VK_KHR_display_swapchain)
VkResult WRAP_vkCreateSharedSwapchainsKHR(VkDevice device, uint32_t swapchainCount, const VkSwapchainCreateInfoKHR* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkSwapchainKHR* pSwapchains) { return vkCreateSharedSwapchainsKHR(device, swapchainCount, pCreateInfos, pAllocator, pSwapchains); }
#endif /* defined(VK_KHR_display_swapchain) */
#if defined(VK_KHR_draw_indirect_count)
void WRAP_vkCmdDrawIndexedIndirectCountKHR(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) { vkCmdDrawIndexedIndirectCountKHR(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride); }
void WRAP_vkCmdDrawIndirectCountKHR(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) { vkCmdDrawIndirectCountKHR(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride); }
#endif /* defined(VK_KHR_draw_indirect_count) */
#if defined(VK_KHR_dynamic_rendering)
void WRAP_vkCmdBeginRenderingKHR(VkCommandBuffer                   commandBuffer, 
        VkRenderingInfo& pRenderingInfo) { vkCmdBeginRenderingKHR(commandBuffer, &pRenderingInfo); }
void WRAP_vkCmdEndRenderingKHR(VkCommandBuffer                   commandBuffer) { vkCmdEndRenderingKHR(commandBuffer); }
#endif /* defined(VK_KHR_dynamic_rendering) */
#if defined(VK_KHR_dynamic_rendering_local_read)
void WRAP_vkCmdSetRenderingAttachmentLocationsKHR(VkCommandBuffer commandBuffer, 
        VkRenderingAttachmentLocationInfo& pLocationInfo) { vkCmdSetRenderingAttachmentLocationsKHR(commandBuffer, &pLocationInfo); }
void WRAP_vkCmdSetRenderingInputAttachmentIndicesKHR(VkCommandBuffer commandBuffer, 
        VkRenderingInputAttachmentIndexInfo& pInputAttachmentIndexInfo) { vkCmdSetRenderingInputAttachmentIndicesKHR(commandBuffer, &pInputAttachmentIndexInfo); }
#endif /* defined(VK_KHR_dynamic_rendering_local_read) */
#if defined(VK_KHR_external_fence_capabilities)
void WRAP_vkGetPhysicalDeviceExternalFencePropertiesKHR(VkPhysicalDevice physicalDevice, 
            VkPhysicalDeviceExternalFenceInfo& pExternalFenceInfo, 
        VkExternalFenceProperties& pExternalFenceProperties) { vkGetPhysicalDeviceExternalFencePropertiesKHR(physicalDevice, &pExternalFenceInfo, &pExternalFenceProperties); }
#endif /* defined(VK_KHR_external_fence_capabilities) */
#if defined(VK_KHR_external_fence_fd)
VkResult WRAP_vkGetFenceFdKHR(VkDevice device, 
            VkFenceGetFdInfoKHR& pGetFdInfo, 
        int& pFd) { return vkGetFenceFdKHR(device, &pGetFdInfo, &pFd); }
VkResult WRAP_vkImportFenceFdKHR(VkDevice device, 
        VkImportFenceFdInfoKHR& pImportFenceFdInfo) { return vkImportFenceFdKHR(device, &pImportFenceFdInfo); }
#endif /* defined(VK_KHR_external_fence_fd) */
#if defined(VK_KHR_external_fence_win32)
VkResult WRAP_vkGetFenceWin32HandleKHR(VkDevice device, 
            VkFenceGetWin32HandleInfoKHR& pGetWin32HandleInfo, 
        HANDLE& pHandle) { return vkGetFenceWin32HandleKHR(device, &pGetWin32HandleInfo, &pHandle); }
VkResult WRAP_vkImportFenceWin32HandleKHR(VkDevice device, 
        VkImportFenceWin32HandleInfoKHR& pImportFenceWin32HandleInfo) { return vkImportFenceWin32HandleKHR(device, &pImportFenceWin32HandleInfo); }
#endif /* defined(VK_KHR_external_fence_win32) */
#if defined(VK_KHR_external_memory_capabilities)
void WRAP_vkGetPhysicalDeviceExternalBufferPropertiesKHR(VkPhysicalDevice physicalDevice, 
            VkPhysicalDeviceExternalBufferInfo& pExternalBufferInfo, 
        VkExternalBufferProperties& pExternalBufferProperties) { vkGetPhysicalDeviceExternalBufferPropertiesKHR(physicalDevice, &pExternalBufferInfo, &pExternalBufferProperties); }
#endif /* defined(VK_KHR_external_memory_capabilities) */
#if defined(VK_KHR_external_memory_fd)
VkResult WRAP_vkGetMemoryFdKHR(VkDevice device, 
            VkMemoryGetFdInfoKHR& pGetFdInfo, 
        int& pFd) { return vkGetMemoryFdKHR(device, &pGetFdInfo, &pFd); }
VkResult WRAP_vkGetMemoryFdPropertiesKHR(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, int fd, 
        VkMemoryFdPropertiesKHR& pMemoryFdProperties) { return vkGetMemoryFdPropertiesKHR(device, handleType, fd, &pMemoryFdProperties); }
#endif /* defined(VK_KHR_external_memory_fd) */
#if defined(VK_KHR_external_memory_win32)
VkResult WRAP_vkGetMemoryWin32HandleKHR(VkDevice device, 
            VkMemoryGetWin32HandleInfoKHR& pGetWin32HandleInfo, 
        HANDLE& pHandle) { return vkGetMemoryWin32HandleKHR(device, &pGetWin32HandleInfo, &pHandle); }
VkResult WRAP_vkGetMemoryWin32HandlePropertiesKHR(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, HANDLE handle, 
        VkMemoryWin32HandlePropertiesKHR& pMemoryWin32HandleProperties) { return vkGetMemoryWin32HandlePropertiesKHR(device, handleType, handle, &pMemoryWin32HandleProperties); }
#endif /* defined(VK_KHR_external_memory_win32) */
#if defined(VK_KHR_external_semaphore_capabilities)
void WRAP_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(VkPhysicalDevice physicalDevice, 
            VkPhysicalDeviceExternalSemaphoreInfo& pExternalSemaphoreInfo, 
        VkExternalSemaphoreProperties& pExternalSemaphoreProperties) { vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(physicalDevice, &pExternalSemaphoreInfo, &pExternalSemaphoreProperties); }
#endif /* defined(VK_KHR_external_semaphore_capabilities) */
#if defined(VK_KHR_external_semaphore_fd)
VkResult WRAP_vkGetSemaphoreFdKHR(VkDevice device, 
            VkSemaphoreGetFdInfoKHR& pGetFdInfo, 
        int& pFd) { return vkGetSemaphoreFdKHR(device, &pGetFdInfo, &pFd); }
VkResult WRAP_vkImportSemaphoreFdKHR(VkDevice device, 
        VkImportSemaphoreFdInfoKHR& pImportSemaphoreFdInfo) { return vkImportSemaphoreFdKHR(device, &pImportSemaphoreFdInfo); }
#endif /* defined(VK_KHR_external_semaphore_fd) */
#if defined(VK_KHR_external_semaphore_win32)
VkResult WRAP_vkGetSemaphoreWin32HandleKHR(VkDevice device, 
            VkSemaphoreGetWin32HandleInfoKHR& pGetWin32HandleInfo, 
        HANDLE& pHandle) { return vkGetSemaphoreWin32HandleKHR(device, &pGetWin32HandleInfo, &pHandle); }
VkResult WRAP_vkImportSemaphoreWin32HandleKHR(VkDevice device, 
        VkImportSemaphoreWin32HandleInfoKHR& pImportSemaphoreWin32HandleInfo) { return vkImportSemaphoreWin32HandleKHR(device, &pImportSemaphoreWin32HandleInfo); }
#endif /* defined(VK_KHR_external_semaphore_win32) */
#if defined(VK_KHR_fragment_shading_rate)
void WRAP_vkCmdSetFragmentShadingRateKHR(VkCommandBuffer           commandBuffer, 
            VkExtent2D& pFragmentSize, const VkFragmentShadingRateCombinerOpKHR    combinerOps[2]) { vkCmdSetFragmentShadingRateKHR(commandBuffer, &pFragmentSize, combinerOps); }
VkResult WRAP_vkGetPhysicalDeviceFragmentShadingRatesKHR(VkPhysicalDevice physicalDevice, 
            uint32_t& pFragmentShadingRateCount, VkPhysicalDeviceFragmentShadingRateKHR* pFragmentShadingRates) { return vkGetPhysicalDeviceFragmentShadingRatesKHR(physicalDevice, &pFragmentShadingRateCount, pFragmentShadingRates); }
#endif /* defined(VK_KHR_fragment_shading_rate) */
#if defined(VK_KHR_get_display_properties2)
VkResult WRAP_vkGetDisplayModeProperties2KHR(VkPhysicalDevice physicalDevice, VkDisplayKHR display, 
            uint32_t& pPropertyCount, VkDisplayModeProperties2KHR* pProperties) { return vkGetDisplayModeProperties2KHR(physicalDevice, display, &pPropertyCount, pProperties); }
VkResult WRAP_vkGetDisplayPlaneCapabilities2KHR(VkPhysicalDevice physicalDevice, 
            VkDisplayPlaneInfo2KHR& pDisplayPlaneInfo, 
        VkDisplayPlaneCapabilities2KHR& pCapabilities) { return vkGetDisplayPlaneCapabilities2KHR(physicalDevice, &pDisplayPlaneInfo, &pCapabilities); }
VkResult WRAP_vkGetPhysicalDeviceDisplayPlaneProperties2KHR(VkPhysicalDevice physicalDevice, 
            uint32_t& pPropertyCount, VkDisplayPlaneProperties2KHR* pProperties) { return vkGetPhysicalDeviceDisplayPlaneProperties2KHR(physicalDevice, &pPropertyCount, pProperties); }
VkResult WRAP_vkGetPhysicalDeviceDisplayProperties2KHR(VkPhysicalDevice physicalDevice, 
            uint32_t& pPropertyCount, VkDisplayProperties2KHR* pProperties) { return vkGetPhysicalDeviceDisplayProperties2KHR(physicalDevice, &pPropertyCount, pProperties); }
#endif /* defined(VK_KHR_get_display_properties2) */
#if defined(VK_KHR_get_memory_requirements2)
void WRAP_vkGetBufferMemoryRequirements2KHR(VkDevice device, 
            VkBufferMemoryRequirementsInfo2& pInfo, 
        VkMemoryRequirements2& pMemoryRequirements) { vkGetBufferMemoryRequirements2KHR(device, &pInfo, &pMemoryRequirements); }
void WRAP_vkGetImageMemoryRequirements2KHR(VkDevice device, 
            VkImageMemoryRequirementsInfo2& pInfo, 
        VkMemoryRequirements2& pMemoryRequirements) { vkGetImageMemoryRequirements2KHR(device, &pInfo, &pMemoryRequirements); }
void WRAP_vkGetImageSparseMemoryRequirements2KHR(VkDevice device, 
            VkImageSparseMemoryRequirementsInfo2& pInfo, 
            uint32_t& pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2* pSparseMemoryRequirements) { vkGetImageSparseMemoryRequirements2KHR(device, &pInfo, &pSparseMemoryRequirementCount, pSparseMemoryRequirements); }
#endif /* defined(VK_KHR_get_memory_requirements2) */
#if defined(VK_KHR_get_physical_device_properties2)
void WRAP_vkGetPhysicalDeviceFeatures2KHR(VkPhysicalDevice physicalDevice, 
        VkPhysicalDeviceFeatures2& pFeatures) { vkGetPhysicalDeviceFeatures2KHR(physicalDevice, &pFeatures); }
void WRAP_vkGetPhysicalDeviceFormatProperties2KHR(VkPhysicalDevice physicalDevice, VkFormat format, 
        VkFormatProperties2& pFormatProperties) { vkGetPhysicalDeviceFormatProperties2KHR(physicalDevice, format, &pFormatProperties); }
VkResult WRAP_vkGetPhysicalDeviceImageFormatProperties2KHR(VkPhysicalDevice physicalDevice, 
            VkPhysicalDeviceImageFormatInfo2& pImageFormatInfo, 
        VkImageFormatProperties2& pImageFormatProperties) { return vkGetPhysicalDeviceImageFormatProperties2KHR(physicalDevice, &pImageFormatInfo, &pImageFormatProperties); }
void WRAP_vkGetPhysicalDeviceMemoryProperties2KHR(VkPhysicalDevice physicalDevice, 
        VkPhysicalDeviceMemoryProperties2& pMemoryProperties) { vkGetPhysicalDeviceMemoryProperties2KHR(physicalDevice, &pMemoryProperties); }
void WRAP_vkGetPhysicalDeviceProperties2KHR(VkPhysicalDevice physicalDevice, 
        VkPhysicalDeviceProperties2& pProperties) { vkGetPhysicalDeviceProperties2KHR(physicalDevice, &pProperties); }
void WRAP_vkGetPhysicalDeviceQueueFamilyProperties2KHR(VkPhysicalDevice physicalDevice, 
            uint32_t& pQueueFamilyPropertyCount, VkQueueFamilyProperties2* pQueueFamilyProperties) { vkGetPhysicalDeviceQueueFamilyProperties2KHR(physicalDevice, &pQueueFamilyPropertyCount, pQueueFamilyProperties); }
void WRAP_vkGetPhysicalDeviceSparseImageFormatProperties2KHR(VkPhysicalDevice physicalDevice, 
            VkPhysicalDeviceSparseImageFormatInfo2& pFormatInfo, 
            uint32_t& pPropertyCount, VkSparseImageFormatProperties2* pProperties) { vkGetPhysicalDeviceSparseImageFormatProperties2KHR(physicalDevice, &pFormatInfo, &pPropertyCount, pProperties); }
#endif /* defined(VK_KHR_get_physical_device_properties2) */
#if defined(VK_KHR_get_surface_capabilities2)
VkResult WRAP_vkGetPhysicalDeviceSurfaceCapabilities2KHR(VkPhysicalDevice physicalDevice, 
            VkPhysicalDeviceSurfaceInfo2KHR& pSurfaceInfo, 
        VkSurfaceCapabilities2KHR& pSurfaceCapabilities) { return vkGetPhysicalDeviceSurfaceCapabilities2KHR(physicalDevice, &pSurfaceInfo, &pSurfaceCapabilities); }
VkResult WRAP_vkGetPhysicalDeviceSurfaceFormats2KHR(VkPhysicalDevice physicalDevice, 
            VkPhysicalDeviceSurfaceInfo2KHR& pSurfaceInfo, 
            uint32_t& pSurfaceFormatCount, VkSurfaceFormat2KHR* pSurfaceFormats) { return vkGetPhysicalDeviceSurfaceFormats2KHR(physicalDevice, &pSurfaceInfo, &pSurfaceFormatCount, pSurfaceFormats); }
#endif /* defined(VK_KHR_get_surface_capabilities2) */
#if defined(VK_KHR_line_rasterization)
void WRAP_vkCmdSetLineStippleKHR(VkCommandBuffer commandBuffer, uint32_t lineStippleFactor, uint16_t lineStipplePattern) { vkCmdSetLineStippleKHR(commandBuffer, lineStippleFactor, lineStipplePattern); }
#endif /* defined(VK_KHR_line_rasterization) */
#if defined(VK_KHR_maintenance1)
void WRAP_vkTrimCommandPoolKHR(VkDevice device, VkCommandPool commandPool, VkCommandPoolTrimFlags flags) { vkTrimCommandPoolKHR(device, commandPool, flags); }
#endif /* defined(VK_KHR_maintenance1) */
#if defined(VK_KHR_maintenance3)
void WRAP_vkGetDescriptorSetLayoutSupportKHR(VkDevice device, 
            VkDescriptorSetLayoutCreateInfo& pCreateInfo, 
        VkDescriptorSetLayoutSupport& pSupport) { vkGetDescriptorSetLayoutSupportKHR(device, &pCreateInfo, &pSupport); }
#endif /* defined(VK_KHR_maintenance3) */
#if defined(VK_KHR_maintenance4)
void WRAP_vkGetDeviceBufferMemoryRequirementsKHR(VkDevice device, 
            VkDeviceBufferMemoryRequirements& pInfo, 
        VkMemoryRequirements2& pMemoryRequirements) { vkGetDeviceBufferMemoryRequirementsKHR(device, &pInfo, &pMemoryRequirements); }
void WRAP_vkGetDeviceImageMemoryRequirementsKHR(VkDevice device, 
            VkDeviceImageMemoryRequirements& pInfo, 
        VkMemoryRequirements2& pMemoryRequirements) { vkGetDeviceImageMemoryRequirementsKHR(device, &pInfo, &pMemoryRequirements); }
void WRAP_vkGetDeviceImageSparseMemoryRequirementsKHR(VkDevice device, 
            VkDeviceImageMemoryRequirements& pInfo, 
            uint32_t& pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2* pSparseMemoryRequirements) { vkGetDeviceImageSparseMemoryRequirementsKHR(device, &pInfo, &pSparseMemoryRequirementCount, pSparseMemoryRequirements); }
#endif /* defined(VK_KHR_maintenance4) */
#if defined(VK_KHR_maintenance5)
void WRAP_vkCmdBindIndexBuffer2KHR(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkDeviceSize size, VkIndexType indexType) { vkCmdBindIndexBuffer2KHR(commandBuffer, buffer, offset, size, indexType); }
void WRAP_vkGetDeviceImageSubresourceLayoutKHR(VkDevice device, 
            VkDeviceImageSubresourceInfo& pInfo, 
        VkSubresourceLayout2& pLayout) { vkGetDeviceImageSubresourceLayoutKHR(device, &pInfo, &pLayout); }
void WRAP_vkGetImageSubresourceLayout2KHR(VkDevice device, VkImage image, 
            VkImageSubresource2& pSubresource, 
        VkSubresourceLayout2& pLayout) { vkGetImageSubresourceLayout2KHR(device, image, &pSubresource, &pLayout); }
void WRAP_vkGetRenderingAreaGranularityKHR(VkDevice device, 
            VkRenderingAreaInfo& pRenderingAreaInfo, 
        VkExtent2D& pGranularity) { vkGetRenderingAreaGranularityKHR(device, &pRenderingAreaInfo, &pGranularity); }
#endif /* defined(VK_KHR_maintenance5) */
#if defined(VK_KHR_maintenance6)
void WRAP_vkCmdBindDescriptorSets2KHR(VkCommandBuffer commandBuffer, 
        VkBindDescriptorSetsInfo& pBindDescriptorSetsInfo) { vkCmdBindDescriptorSets2KHR(commandBuffer, &pBindDescriptorSetsInfo); }
void WRAP_vkCmdPushConstants2KHR(VkCommandBuffer commandBuffer, 
        VkPushConstantsInfo& pPushConstantsInfo) { vkCmdPushConstants2KHR(commandBuffer, &pPushConstantsInfo); }
#endif /* defined(VK_KHR_maintenance6) */
#if defined(VK_KHR_maintenance6) && defined(VK_KHR_push_descriptor)
void WRAP_vkCmdPushDescriptorSet2KHR(VkCommandBuffer commandBuffer, 
        VkPushDescriptorSetInfo& pPushDescriptorSetInfo) { vkCmdPushDescriptorSet2KHR(commandBuffer, &pPushDescriptorSetInfo); }
void WRAP_vkCmdPushDescriptorSetWithTemplate2KHR(VkCommandBuffer commandBuffer, 
        VkPushDescriptorSetWithTemplateInfo& pPushDescriptorSetWithTemplateInfo) { vkCmdPushDescriptorSetWithTemplate2KHR(commandBuffer, &pPushDescriptorSetWithTemplateInfo); }
#endif /* defined(VK_KHR_maintenance6) && defined(VK_KHR_push_descriptor) */
#if defined(VK_KHR_maintenance6) && defined(VK_EXT_descriptor_buffer)
void WRAP_vkCmdBindDescriptorBufferEmbeddedSamplers2EXT(VkCommandBuffer commandBuffer, 
        VkBindDescriptorBufferEmbeddedSamplersInfoEXT& pBindDescriptorBufferEmbeddedSamplersInfo) { vkCmdBindDescriptorBufferEmbeddedSamplers2EXT(commandBuffer, &pBindDescriptorBufferEmbeddedSamplersInfo); }
void WRAP_vkCmdSetDescriptorBufferOffsets2EXT(VkCommandBuffer commandBuffer, 
        VkSetDescriptorBufferOffsetsInfoEXT& pSetDescriptorBufferOffsetsInfo) { vkCmdSetDescriptorBufferOffsets2EXT(commandBuffer, &pSetDescriptorBufferOffsetsInfo); }
#endif /* defined(VK_KHR_maintenance6) && defined(VK_EXT_descriptor_buffer) */
#if defined(VK_KHR_map_memory2)
VkResult WRAP_vkMapMemory2KHR(VkDevice device, 
            VkMemoryMapInfo& pMemoryMapInfo, void** ppData) { return vkMapMemory2KHR(device, &pMemoryMapInfo, ppData); }
VkResult WRAP_vkUnmapMemory2KHR(VkDevice device, 
        VkMemoryUnmapInfo& pMemoryUnmapInfo) { return vkUnmapMemory2KHR(device, &pMemoryUnmapInfo); }
#endif /* defined(VK_KHR_map_memory2) */
#if defined(VK_KHR_performance_query)
VkResult WRAP_vkAcquireProfilingLockKHR(VkDevice device, 
        VkAcquireProfilingLockInfoKHR& pInfo) { return vkAcquireProfilingLockKHR(device, &pInfo); }
VkResult WRAP_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, 
            uint32_t& pCounterCount, VkPerformanceCounterKHR* pCounters, VkPerformanceCounterDescriptionKHR* pCounterDescriptions) { return vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(physicalDevice, queueFamilyIndex, &pCounterCount, pCounters, pCounterDescriptions); }
void WRAP_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(VkPhysicalDevice physicalDevice, 
            VkQueryPoolPerformanceCreateInfoKHR& pPerformanceQueryCreateInfo, 
        uint32_t& pNumPasses) { vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(physicalDevice, &pPerformanceQueryCreateInfo, &pNumPasses); }
void WRAP_vkReleaseProfilingLockKHR(VkDevice device) { vkReleaseProfilingLockKHR(device); }
#endif /* defined(VK_KHR_performance_query) */
#if defined(VK_KHR_pipeline_binary)
VkResult WRAP_vkCreatePipelineBinariesKHR(VkDevice device, 
            VkPipelineBinaryCreateInfoKHR& pCreateInfo, const VkAllocationCallbacks* pAllocator, 
        VkPipelineBinaryHandlesInfoKHR& pBinaries) { return vkCreatePipelineBinariesKHR(device, &pCreateInfo, pAllocator, &pBinaries); }
void WRAP_vkDestroyPipelineBinaryKHR(VkDevice device, VkPipelineBinaryKHR pipelineBinary, const VkAllocationCallbacks* pAllocator) { vkDestroyPipelineBinaryKHR(device, pipelineBinary, pAllocator); }
VkResult WRAP_vkGetPipelineBinaryDataKHR(VkDevice device, 
            VkPipelineBinaryDataInfoKHR& pInfo, 
            VkPipelineBinaryKeyKHR& pPipelineBinaryKey, 
            size_t& pPipelineBinaryDataSize, void* pPipelineBinaryData) { return vkGetPipelineBinaryDataKHR(device, &pInfo, &pPipelineBinaryKey, &pPipelineBinaryDataSize, pPipelineBinaryData); }
VkResult WRAP_vkGetPipelineKeyKHR(VkDevice device, const VkPipelineCreateInfoKHR* pPipelineCreateInfo, 
        VkPipelineBinaryKeyKHR& pPipelineKey) { return vkGetPipelineKeyKHR(device, pPipelineCreateInfo, &pPipelineKey); }
VkResult WRAP_vkReleaseCapturedPipelineDataKHR(VkDevice device, 
            VkReleaseCapturedPipelineDataInfoKHR& pInfo, const VkAllocationCallbacks* pAllocator) { return vkReleaseCapturedPipelineDataKHR(device, &pInfo, pAllocator); }
#endif /* defined(VK_KHR_pipeline_binary) */
#if defined(VK_KHR_pipeline_executable_properties)
VkResult WRAP_vkGetPipelineExecutableInternalRepresentationsKHR(VkDevice                        device, 
            VkPipelineExecutableInfoKHR& pExecutableInfo, 
            uint32_t& pInternalRepresentationCount, VkPipelineExecutableInternalRepresentationKHR* pInternalRepresentations) { return vkGetPipelineExecutableInternalRepresentationsKHR(device, &pExecutableInfo, &pInternalRepresentationCount, pInternalRepresentations); }
VkResult WRAP_vkGetPipelineExecutablePropertiesKHR(VkDevice                        device, 
            VkPipelineInfoKHR& pPipelineInfo, 
            uint32_t& pExecutableCount, VkPipelineExecutablePropertiesKHR* pProperties) { return vkGetPipelineExecutablePropertiesKHR(device, &pPipelineInfo, &pExecutableCount, pProperties); }
VkResult WRAP_vkGetPipelineExecutableStatisticsKHR(VkDevice                        device, 
            VkPipelineExecutableInfoKHR& pExecutableInfo, 
            uint32_t& pStatisticCount, VkPipelineExecutableStatisticKHR* pStatistics) { return vkGetPipelineExecutableStatisticsKHR(device, &pExecutableInfo, &pStatisticCount, pStatistics); }
#endif /* defined(VK_KHR_pipeline_executable_properties) */
#if defined(VK_KHR_present_wait)
VkResult WRAP_vkWaitForPresentKHR(VkDevice device, VkSwapchainKHR swapchain, uint64_t presentId, uint64_t timeout) { return vkWaitForPresentKHR(device, swapchain, presentId, timeout); }
#endif /* defined(VK_KHR_present_wait) */
#if defined(VK_KHR_push_descriptor)
void WRAP_vkCmdPushDescriptorSetKHR(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t set, uint32_t descriptorWriteCount, const VkWriteDescriptorSet* pDescriptorWrites) { vkCmdPushDescriptorSetKHR(commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount, pDescriptorWrites); }
#endif /* defined(VK_KHR_push_descriptor) */
#if defined(VK_KHR_ray_tracing_maintenance1) && defined(VK_KHR_ray_tracing_pipeline)
void WRAP_vkCmdTraceRaysIndirect2KHR(VkCommandBuffer commandBuffer, VkDeviceAddress indirectDeviceAddress) { vkCmdTraceRaysIndirect2KHR(commandBuffer, indirectDeviceAddress); }
#endif /* defined(VK_KHR_ray_tracing_maintenance1) && defined(VK_KHR_ray_tracing_pipeline) */
#if defined(VK_KHR_ray_tracing_pipeline)
void WRAP_vkCmdSetRayTracingPipelineStackSizeKHR(VkCommandBuffer commandBuffer, uint32_t pipelineStackSize) { vkCmdSetRayTracingPipelineStackSizeKHR(commandBuffer, pipelineStackSize); }
void WRAP_vkCmdTraceRaysIndirectKHR(VkCommandBuffer commandBuffer, 
            VkStridedDeviceAddressRegionKHR& pRaygenShaderBindingTable, 
            VkStridedDeviceAddressRegionKHR& pMissShaderBindingTable, 
            VkStridedDeviceAddressRegionKHR& pHitShaderBindingTable, 
            VkStridedDeviceAddressRegionKHR& pCallableShaderBindingTable, VkDeviceAddress indirectDeviceAddress) { vkCmdTraceRaysIndirectKHR(commandBuffer, &pRaygenShaderBindingTable, &pMissShaderBindingTable, &pHitShaderBindingTable, &pCallableShaderBindingTable, indirectDeviceAddress); }
void WRAP_vkCmdTraceRaysKHR(VkCommandBuffer commandBuffer, 
            VkStridedDeviceAddressRegionKHR& pRaygenShaderBindingTable, 
            VkStridedDeviceAddressRegionKHR& pMissShaderBindingTable, 
            VkStridedDeviceAddressRegionKHR& pHitShaderBindingTable, 
            VkStridedDeviceAddressRegionKHR& pCallableShaderBindingTable, uint32_t width, uint32_t height, uint32_t depth) { vkCmdTraceRaysKHR(commandBuffer, &pRaygenShaderBindingTable, &pMissShaderBindingTable, &pHitShaderBindingTable, &pCallableShaderBindingTable, width, height, depth); }
VkResult WRAP_vkCreateRayTracingPipelinesKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkRayTracingPipelineCreateInfoKHR* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines) { return vkCreateRayTracingPipelinesKHR(device, deferredOperation, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines); }
VkResult WRAP_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR(VkDevice device, VkPipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void* pData) { return vkGetRayTracingCaptureReplayShaderGroupHandlesKHR(device, pipeline, firstGroup, groupCount, dataSize, pData); }
VkResult WRAP_vkGetRayTracingShaderGroupHandlesKHR(VkDevice device, VkPipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void* pData) { return vkGetRayTracingShaderGroupHandlesKHR(device, pipeline, firstGroup, groupCount, dataSize, pData); }
VkDeviceSize WRAP_vkGetRayTracingShaderGroupStackSizeKHR(VkDevice device, VkPipeline pipeline, uint32_t group, VkShaderGroupShaderKHR groupShader) { return vkGetRayTracingShaderGroupStackSizeKHR(device, pipeline, group, groupShader); }
#endif /* defined(VK_KHR_ray_tracing_pipeline) */
#if defined(VK_KHR_sampler_ycbcr_conversion)
VkResult WRAP_vkCreateSamplerYcbcrConversionKHR(VkDevice device, 
            VkSamplerYcbcrConversionCreateInfo& pCreateInfo, const VkAllocationCallbacks* pAllocator, 
        VkSamplerYcbcrConversion& pYcbcrConversion) { return vkCreateSamplerYcbcrConversionKHR(device, &pCreateInfo, pAllocator, &pYcbcrConversion); }
void WRAP_vkDestroySamplerYcbcrConversionKHR(VkDevice device, VkSamplerYcbcrConversion ycbcrConversion, const VkAllocationCallbacks* pAllocator) { vkDestroySamplerYcbcrConversionKHR(device, ycbcrConversion, pAllocator); }
#endif /* defined(VK_KHR_sampler_ycbcr_conversion) */
#if defined(VK_KHR_shared_presentable_image)
VkResult WRAP_vkGetSwapchainStatusKHR(VkDevice device, VkSwapchainKHR swapchain) { return vkGetSwapchainStatusKHR(device, swapchain); }
#endif /* defined(VK_KHR_shared_presentable_image) */
#if defined(VK_KHR_surface)
void WRAP_vkDestroySurfaceKHR(VkInstance instance, VkSurfaceKHR surface, const VkAllocationCallbacks* pAllocator) { vkDestroySurfaceKHR(instance, surface, pAllocator); }
VkResult WRAP_vkGetPhysicalDeviceSurfaceCapabilitiesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, 
        VkSurfaceCapabilitiesKHR& pSurfaceCapabilities) { return vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, &pSurfaceCapabilities); }
VkResult WRAP_vkGetPhysicalDeviceSurfaceFormatsKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, 
            uint32_t& pSurfaceFormatCount, VkSurfaceFormatKHR* pSurfaceFormats) { return vkGetPhysicalDeviceSurfaceFormatsKHR(physicalDevice, surface, &pSurfaceFormatCount, pSurfaceFormats); }
VkResult WRAP_vkGetPhysicalDeviceSurfacePresentModesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, 
            uint32_t& pPresentModeCount, VkPresentModeKHR* pPresentModes) { return vkGetPhysicalDeviceSurfacePresentModesKHR(physicalDevice, surface, &pPresentModeCount, pPresentModes); }
VkResult WRAP_vkGetPhysicalDeviceSurfaceSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, VkSurfaceKHR surface, 
        VkBool32& pSupported) { return vkGetPhysicalDeviceSurfaceSupportKHR(physicalDevice, queueFamilyIndex, surface, &pSupported); }
#endif /* defined(VK_KHR_surface) */
#if defined(VK_KHR_swapchain)
VkResult WRAP_vkAcquireNextImageKHR(VkDevice device, VkSwapchainKHR swapchain, uint64_t timeout, VkSemaphore semaphore, VkFence fence, 
        uint32_t& pImageIndex) { return vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, &pImageIndex); }
VkResult WRAP_vkCreateSwapchainKHR(VkDevice device, 
            VkSwapchainCreateInfoKHR& pCreateInfo, const VkAllocationCallbacks* pAllocator, 
        VkSwapchainKHR& pSwapchain) { return vkCreateSwapchainKHR(device, &pCreateInfo, pAllocator, &pSwapchain); }
void WRAP_vkDestroySwapchainKHR(VkDevice device, VkSwapchainKHR swapchain, const VkAllocationCallbacks* pAllocator) { vkDestroySwapchainKHR(device, swapchain, pAllocator); }
VkResult WRAP_vkGetSwapchainImagesKHR(VkDevice device, VkSwapchainKHR swapchain, 
            uint32_t& pSwapchainImageCount, VkImage* pSwapchainImages) { return vkGetSwapchainImagesKHR(device, swapchain, &pSwapchainImageCount, pSwapchainImages); }
VkResult WRAP_vkQueuePresentKHR(VkQueue queue, 
        VkPresentInfoKHR& pPresentInfo) { return vkQueuePresentKHR(queue, &pPresentInfo); }
#endif /* defined(VK_KHR_swapchain) */
#if defined(VK_KHR_synchronization2)
void WRAP_vkCmdPipelineBarrier2KHR(VkCommandBuffer                   commandBuffer, 
        VkDependencyInfo& pDependencyInfo) { vkCmdPipelineBarrier2KHR(commandBuffer, &pDependencyInfo); }
void WRAP_vkCmdResetEvent2KHR(VkCommandBuffer                   commandBuffer, VkEvent                                             event, VkPipelineStageFlags2               stageMask) { vkCmdResetEvent2KHR(commandBuffer, event, stageMask); }
void WRAP_vkCmdSetEvent2KHR(VkCommandBuffer                   commandBuffer, VkEvent                                             event, 
        VkDependencyInfo& pDependencyInfo) { vkCmdSetEvent2KHR(commandBuffer, event, &pDependencyInfo); }
void WRAP_vkCmdWaitEvents2KHR(VkCommandBuffer                   commandBuffer, uint32_t                                            eventCount, const VkEvent*                     pEvents, const VkDependencyInfo*            pDependencyInfos) { vkCmdWaitEvents2KHR(commandBuffer, eventCount, pEvents, pDependencyInfos); }
void WRAP_vkCmdWriteTimestamp2KHR(VkCommandBuffer                   commandBuffer, VkPipelineStageFlags2               stage, VkQueryPool                                         queryPool, uint32_t                                            query) { vkCmdWriteTimestamp2KHR(commandBuffer, stage, queryPool, query); }
VkResult WRAP_vkQueueSubmit2KHR(VkQueue                           queue, uint32_t                            submitCount, const VkSubmitInfo2*              pSubmits, VkFence           fence) { return vkQueueSubmit2KHR(queue, submitCount, pSubmits, fence); }
#endif /* defined(VK_KHR_synchronization2) */
#if defined(VK_KHR_timeline_semaphore)
VkResult WRAP_vkGetSemaphoreCounterValueKHR(VkDevice device, VkSemaphore semaphore, 
        uint64_t& pValue) { return vkGetSemaphoreCounterValueKHR(device, semaphore, &pValue); }
VkResult WRAP_vkSignalSemaphoreKHR(VkDevice device, 
        VkSemaphoreSignalInfo& pSignalInfo) { return vkSignalSemaphoreKHR(device, &pSignalInfo); }
VkResult WRAP_vkWaitSemaphoresKHR(VkDevice device, 
            VkSemaphoreWaitInfo& pWaitInfo, uint64_t timeout) { return vkWaitSemaphoresKHR(device, &pWaitInfo, timeout); }
#endif /* defined(VK_KHR_timeline_semaphore) */
#if defined(VK_KHR_video_decode_queue)
void WRAP_vkCmdDecodeVideoKHR(VkCommandBuffer commandBuffer, 
        VkVideoDecodeInfoKHR& pDecodeInfo) { vkCmdDecodeVideoKHR(commandBuffer, &pDecodeInfo); }
#endif /* defined(VK_KHR_video_decode_queue) */
#if defined(VK_KHR_video_encode_queue)
void WRAP_vkCmdEncodeVideoKHR(VkCommandBuffer commandBuffer, 
        VkVideoEncodeInfoKHR& pEncodeInfo) { vkCmdEncodeVideoKHR(commandBuffer, &pEncodeInfo); }
VkResult WRAP_vkGetEncodedVideoSessionParametersKHR(VkDevice device, 
            VkVideoEncodeSessionParametersGetInfoKHR& pVideoSessionParametersInfo, VkVideoEncodeSessionParametersFeedbackInfoKHR* pFeedbackInfo, 
            size_t& pDataSize, void* pData) { return vkGetEncodedVideoSessionParametersKHR(device, &pVideoSessionParametersInfo, pFeedbackInfo, &pDataSize, pData); }
VkResult WRAP_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR(VkPhysicalDevice physicalDevice, 
            VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR& pQualityLevelInfo, 
        VkVideoEncodeQualityLevelPropertiesKHR& pQualityLevelProperties) { return vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR(physicalDevice, &pQualityLevelInfo, &pQualityLevelProperties); }
#endif /* defined(VK_KHR_video_encode_queue) */
#if defined(VK_KHR_video_queue)
VkResult WRAP_vkBindVideoSessionMemoryKHR(VkDevice device, VkVideoSessionKHR videoSession, uint32_t bindSessionMemoryInfoCount, const VkBindVideoSessionMemoryInfoKHR* pBindSessionMemoryInfos) { return vkBindVideoSessionMemoryKHR(device, videoSession, bindSessionMemoryInfoCount, pBindSessionMemoryInfos); }
void WRAP_vkCmdBeginVideoCodingKHR(VkCommandBuffer commandBuffer, 
        VkVideoBeginCodingInfoKHR& pBeginInfo) { vkCmdBeginVideoCodingKHR(commandBuffer, &pBeginInfo); }
void WRAP_vkCmdControlVideoCodingKHR(VkCommandBuffer commandBuffer, 
        VkVideoCodingControlInfoKHR& pCodingControlInfo) { vkCmdControlVideoCodingKHR(commandBuffer, &pCodingControlInfo); }
void WRAP_vkCmdEndVideoCodingKHR(VkCommandBuffer commandBuffer, 
        VkVideoEndCodingInfoKHR& pEndCodingInfo) { vkCmdEndVideoCodingKHR(commandBuffer, &pEndCodingInfo); }
VkResult WRAP_vkCreateVideoSessionKHR(VkDevice device, 
            VkVideoSessionCreateInfoKHR& pCreateInfo, const VkAllocationCallbacks* pAllocator, 
        VkVideoSessionKHR& pVideoSession) { return vkCreateVideoSessionKHR(device, &pCreateInfo, pAllocator, &pVideoSession); }
VkResult WRAP_vkCreateVideoSessionParametersKHR(VkDevice device, 
            VkVideoSessionParametersCreateInfoKHR& pCreateInfo, const VkAllocationCallbacks* pAllocator, 
        VkVideoSessionParametersKHR& pVideoSessionParameters) { return vkCreateVideoSessionParametersKHR(device, &pCreateInfo, pAllocator, &pVideoSessionParameters); }
void WRAP_vkDestroyVideoSessionKHR(VkDevice device, VkVideoSessionKHR videoSession, const VkAllocationCallbacks* pAllocator) { vkDestroyVideoSessionKHR(device, videoSession, pAllocator); }
void WRAP_vkDestroyVideoSessionParametersKHR(VkDevice device, VkVideoSessionParametersKHR videoSessionParameters, const VkAllocationCallbacks* pAllocator) { vkDestroyVideoSessionParametersKHR(device, videoSessionParameters, pAllocator); }
VkResult WRAP_vkGetPhysicalDeviceVideoCapabilitiesKHR(VkPhysicalDevice physicalDevice, 
            VkVideoProfileInfoKHR& pVideoProfile, 
        VkVideoCapabilitiesKHR& pCapabilities) { return vkGetPhysicalDeviceVideoCapabilitiesKHR(physicalDevice, &pVideoProfile, &pCapabilities); }
VkResult WRAP_vkGetPhysicalDeviceVideoFormatPropertiesKHR(VkPhysicalDevice physicalDevice, 
            VkPhysicalDeviceVideoFormatInfoKHR& pVideoFormatInfo, 
            uint32_t& pVideoFormatPropertyCount, VkVideoFormatPropertiesKHR* pVideoFormatProperties) { return vkGetPhysicalDeviceVideoFormatPropertiesKHR(physicalDevice, &pVideoFormatInfo, &pVideoFormatPropertyCount, pVideoFormatProperties); }
VkResult WRAP_vkGetVideoSessionMemoryRequirementsKHR(VkDevice device, VkVideoSessionKHR videoSession, 
            uint32_t& pMemoryRequirementsCount, VkVideoSessionMemoryRequirementsKHR* pMemoryRequirements) { return vkGetVideoSessionMemoryRequirementsKHR(device, videoSession, &pMemoryRequirementsCount, pMemoryRequirements); }
VkResult WRAP_vkUpdateVideoSessionParametersKHR(VkDevice device, VkVideoSessionParametersKHR videoSessionParameters, 
        VkVideoSessionParametersUpdateInfoKHR& pUpdateInfo) { return vkUpdateVideoSessionParametersKHR(device, videoSessionParameters, &pUpdateInfo); }
#endif /* defined(VK_KHR_video_queue) */
#if defined(VK_KHR_wayland_surface)
VkResult WRAP_vkCreateWaylandSurfaceKHR(VkInstance instance, 
            VkWaylandSurfaceCreateInfoKHR& pCreateInfo, const VkAllocationCallbacks* pAllocator, 
        VkSurfaceKHR& pSurface) { return vkCreateWaylandSurfaceKHR(instance, &pCreateInfo, pAllocator, &pSurface); }
bool WRAP_vkGetPhysicalDeviceWaylandPresentationSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, 
        wl_display& display) { return vkGetPhysicalDeviceWaylandPresentationSupportKHR(physicalDevice, queueFamilyIndex, &display); }
#endif /* defined(VK_KHR_wayland_surface) */
#if defined(VK_KHR_win32_surface)
VkResult WRAP_vkCreateWin32SurfaceKHR(VkInstance instance, 
            VkWin32SurfaceCreateInfoKHR& pCreateInfo, const VkAllocationCallbacks* pAllocator, 
        VkSurfaceKHR& pSurface) { return vkCreateWin32SurfaceKHR(instance, &pCreateInfo, pAllocator, &pSurface); }
bool WRAP_vkGetPhysicalDeviceWin32PresentationSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex) { return vkGetPhysicalDeviceWin32PresentationSupportKHR(physicalDevice, queueFamilyIndex); }
#endif /* defined(VK_KHR_win32_surface) */
#if defined(VK_KHR_xcb_surface)
VkResult WRAP_vkCreateXcbSurfaceKHR(VkInstance instance, 
            VkXcbSurfaceCreateInfoKHR& pCreateInfo, const VkAllocationCallbacks* pAllocator, 
        VkSurfaceKHR& pSurface) { return vkCreateXcbSurfaceKHR(instance, &pCreateInfo, pAllocator, &pSurface); }
bool WRAP_vkGetPhysicalDeviceXcbPresentationSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, 
            xcb_connection_t& connection, xcb_visualid_t visual_id) { return vkGetPhysicalDeviceXcbPresentationSupportKHR(physicalDevice, queueFamilyIndex, &connection, visual_id); }
#endif /* defined(VK_KHR_xcb_surface) */
#if defined(VK_KHR_xlib_surface)
VkResult WRAP_vkCreateXlibSurfaceKHR(VkInstance instance, 
            VkXlibSurfaceCreateInfoKHR& pCreateInfo, const VkAllocationCallbacks* pAllocator, 
        VkSurfaceKHR& pSurface) { return vkCreateXlibSurfaceKHR(instance, &pCreateInfo, pAllocator, &pSurface); }
bool WRAP_vkGetPhysicalDeviceXlibPresentationSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, 
            Display& dpy, VisualID visualID) { return vkGetPhysicalDeviceXlibPresentationSupportKHR(physicalDevice, queueFamilyIndex, &dpy, visualID); }
#endif /* defined(VK_KHR_xlib_surface) */
#if defined(VK_MVK_ios_surface)
VkResult WRAP_vkCreateIOSSurfaceMVK(VkInstance instance, 
            VkIOSSurfaceCreateInfoMVK& pCreateInfo, const VkAllocationCallbacks* pAllocator, 
        VkSurfaceKHR& pSurface) { return vkCreateIOSSurfaceMVK(instance, &pCreateInfo, pAllocator, &pSurface); }
#endif /* defined(VK_MVK_ios_surface) */
#if defined(VK_MVK_macos_surface)
VkResult WRAP_vkCreateMacOSSurfaceMVK(VkInstance instance, 
            VkMacOSSurfaceCreateInfoMVK& pCreateInfo, const VkAllocationCallbacks* pAllocator, 
        VkSurfaceKHR& pSurface) { return vkCreateMacOSSurfaceMVK(instance, &pCreateInfo, pAllocator, &pSurface); }
#endif /* defined(VK_MVK_macos_surface) */
#if defined(VK_NN_vi_surface)
VkResult WRAP_vkCreateViSurfaceNN(VkInstance instance, 
            VkViSurfaceCreateInfoNN& pCreateInfo, const VkAllocationCallbacks* pAllocator, 
        VkSurfaceKHR& pSurface) { return vkCreateViSurfaceNN(instance, &pCreateInfo, pAllocator, &pSurface); }
#endif /* defined(VK_NN_vi_surface) */
#if defined(VK_NVX_binary_import)
void WRAP_vkCmdCuLaunchKernelNVX(VkCommandBuffer commandBuffer, 
        VkCuLaunchInfoNVX& pLaunchInfo) { vkCmdCuLaunchKernelNVX(commandBuffer, &pLaunchInfo); }
VkResult WRAP_vkCreateCuFunctionNVX(VkDevice device, 
            VkCuFunctionCreateInfoNVX& pCreateInfo, const VkAllocationCallbacks* pAllocator, 
        VkCuFunctionNVX& pFunction) { return vkCreateCuFunctionNVX(device, &pCreateInfo, pAllocator, &pFunction); }
VkResult WRAP_vkCreateCuModuleNVX(VkDevice device, 
            VkCuModuleCreateInfoNVX& pCreateInfo, const VkAllocationCallbacks* pAllocator, 
        VkCuModuleNVX& pModule) { return vkCreateCuModuleNVX(device, &pCreateInfo, pAllocator, &pModule); }
void WRAP_vkDestroyCuFunctionNVX(VkDevice device, VkCuFunctionNVX function, const VkAllocationCallbacks* pAllocator) { vkDestroyCuFunctionNVX(device, function, pAllocator); }
void WRAP_vkDestroyCuModuleNVX(VkDevice device, VkCuModuleNVX module, const VkAllocationCallbacks* pAllocator) { vkDestroyCuModuleNVX(device, module, pAllocator); }
#endif /* defined(VK_NVX_binary_import) */
#if defined(VK_NVX_image_view_handle)
VkResult WRAP_vkGetImageViewAddressNVX(VkDevice device, VkImageView imageView, 
        VkImageViewAddressPropertiesNVX& pProperties) { return vkGetImageViewAddressNVX(device, imageView, &pProperties); }
uint64_t WRAP_vkGetImageViewHandle64NVX(VkDevice device, 
        VkImageViewHandleInfoNVX& pInfo) { return vkGetImageViewHandle64NVX(device, &pInfo); }
uint32_t WRAP_vkGetImageViewHandleNVX(VkDevice device, 
        VkImageViewHandleInfoNVX& pInfo) { return vkGetImageViewHandleNVX(device, &pInfo); }
#endif /* defined(VK_NVX_image_view_handle) */
#if defined(VK_NV_acquire_winrt_display)
VkResult WRAP_vkAcquireWinrtDisplayNV(VkPhysicalDevice physicalDevice, VkDisplayKHR display) { return vkAcquireWinrtDisplayNV(physicalDevice, display); }
VkResult WRAP_vkGetWinrtDisplayNV(VkPhysicalDevice physicalDevice, uint32_t deviceRelativeId, 
        VkDisplayKHR& pDisplay) { return vkGetWinrtDisplayNV(physicalDevice, deviceRelativeId, &pDisplay); }
#endif /* defined(VK_NV_acquire_winrt_display) */
#if defined(VK_NV_clip_space_w_scaling)
void WRAP_vkCmdSetViewportWScalingNV(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewportWScalingNV* pViewportWScalings) { vkCmdSetViewportWScalingNV(commandBuffer, firstViewport, viewportCount, pViewportWScalings); }
#endif /* defined(VK_NV_clip_space_w_scaling) */
#if defined(VK_NV_cooperative_matrix)
VkResult WRAP_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(VkPhysicalDevice physicalDevice, 
            uint32_t& pPropertyCount, VkCooperativeMatrixPropertiesNV* pProperties) { return vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(physicalDevice, &pPropertyCount, pProperties); }
#endif /* defined(VK_NV_cooperative_matrix) */
#if defined(VK_NV_cooperative_matrix2)
VkResult WRAP_vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV(VkPhysicalDevice physicalDevice, 
            uint32_t& pPropertyCount, VkCooperativeMatrixFlexibleDimensionsPropertiesNV* pProperties) { return vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV(physicalDevice, &pPropertyCount, pProperties); }
#endif /* defined(VK_NV_cooperative_matrix2) */
#if defined(VK_NV_copy_memory_indirect)
void WRAP_vkCmdCopyMemoryIndirectNV(VkCommandBuffer commandBuffer, VkDeviceAddress copyBufferAddress, uint32_t copyCount, uint32_t stride) { vkCmdCopyMemoryIndirectNV(commandBuffer, copyBufferAddress, copyCount, stride); }
void WRAP_vkCmdCopyMemoryToImageIndirectNV(VkCommandBuffer commandBuffer, VkDeviceAddress copyBufferAddress, uint32_t copyCount, uint32_t stride, VkImage dstImage, VkImageLayout dstImageLayout, const VkImageSubresourceLayers* pImageSubresources) { vkCmdCopyMemoryToImageIndirectNV(commandBuffer, copyBufferAddress, copyCount, stride, dstImage, dstImageLayout, pImageSubresources); }
#endif /* defined(VK_NV_copy_memory_indirect) */
#if defined(VK_NV_coverage_reduction_mode)
VkResult WRAP_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(VkPhysicalDevice physicalDevice, 
            uint32_t& pCombinationCount, VkFramebufferMixedSamplesCombinationNV* pCombinations) { return vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(physicalDevice, &pCombinationCount, pCombinations); }
#endif /* defined(VK_NV_coverage_reduction_mode) */
#if defined(VK_NV_cuda_kernel_launch)
void WRAP_vkCmdCudaLaunchKernelNV(VkCommandBuffer commandBuffer, 
        VkCudaLaunchInfoNV& pLaunchInfo) { vkCmdCudaLaunchKernelNV(commandBuffer, &pLaunchInfo); }
VkResult WRAP_vkCreateCudaFunctionNV(VkDevice device, 
            VkCudaFunctionCreateInfoNV& pCreateInfo, const VkAllocationCallbacks* pAllocator, 
        VkCudaFunctionNV& pFunction) { return vkCreateCudaFunctionNV(device, &pCreateInfo, pAllocator, &pFunction); }
VkResult WRAP_vkCreateCudaModuleNV(VkDevice device, 
            VkCudaModuleCreateInfoNV& pCreateInfo, const VkAllocationCallbacks* pAllocator, 
        VkCudaModuleNV& pModule) { return vkCreateCudaModuleNV(device, &pCreateInfo, pAllocator, &pModule); }
void WRAP_vkDestroyCudaFunctionNV(VkDevice device, VkCudaFunctionNV function, const VkAllocationCallbacks* pAllocator) { vkDestroyCudaFunctionNV(device, function, pAllocator); }
void WRAP_vkDestroyCudaModuleNV(VkDevice device, VkCudaModuleNV module, const VkAllocationCallbacks* pAllocator) { vkDestroyCudaModuleNV(device, module, pAllocator); }
VkResult WRAP_vkGetCudaModuleCacheNV(VkDevice device, VkCudaModuleNV module, 
            size_t& pCacheSize, void* pCacheData) { return vkGetCudaModuleCacheNV(device, module, &pCacheSize, pCacheData); }
#endif /* defined(VK_NV_cuda_kernel_launch) */
#if defined(VK_NV_device_diagnostic_checkpoints)
void WRAP_vkCmdSetCheckpointNV(VkCommandBuffer commandBuffer, const void* pCheckpointMarker) { vkCmdSetCheckpointNV(commandBuffer, pCheckpointMarker); }
void WRAP_vkGetQueueCheckpointDataNV(VkQueue queue, 
            uint32_t& pCheckpointDataCount, VkCheckpointDataNV* pCheckpointData) { vkGetQueueCheckpointDataNV(queue, &pCheckpointDataCount, pCheckpointData); }
#endif /* defined(VK_NV_device_diagnostic_checkpoints) */
#if defined(VK_NV_device_diagnostic_checkpoints) && (defined(VK_VERSION_1_3) || defined(VK_KHR_synchronization2))
void WRAP_vkGetQueueCheckpointData2NV(VkQueue queue, 
            uint32_t& pCheckpointDataCount, VkCheckpointData2NV* pCheckpointData) { vkGetQueueCheckpointData2NV(queue, &pCheckpointDataCount, pCheckpointData); }
#endif /* defined(VK_NV_device_diagnostic_checkpoints) && (defined(VK_VERSION_1_3) || defined(VK_KHR_synchronization2)) */
#if defined(VK_NV_device_generated_commands)
void WRAP_vkCmdBindPipelineShaderGroupNV(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline, uint32_t groupIndex) { vkCmdBindPipelineShaderGroupNV(commandBuffer, pipelineBindPoint, pipeline, groupIndex); }
void WRAP_vkCmdExecuteGeneratedCommandsNV(VkCommandBuffer commandBuffer, VkBool32 isPreprocessed, 
        VkGeneratedCommandsInfoNV& pGeneratedCommandsInfo) { vkCmdExecuteGeneratedCommandsNV(commandBuffer, isPreprocessed, &pGeneratedCommandsInfo); }
void WRAP_vkCmdPreprocessGeneratedCommandsNV(VkCommandBuffer commandBuffer, 
        VkGeneratedCommandsInfoNV& pGeneratedCommandsInfo) { vkCmdPreprocessGeneratedCommandsNV(commandBuffer, &pGeneratedCommandsInfo); }
VkResult WRAP_vkCreateIndirectCommandsLayoutNV(VkDevice device, 
            VkIndirectCommandsLayoutCreateInfoNV& pCreateInfo, const VkAllocationCallbacks* pAllocator, 
        VkIndirectCommandsLayoutNV& pIndirectCommandsLayout) { return vkCreateIndirectCommandsLayoutNV(device, &pCreateInfo, pAllocator, &pIndirectCommandsLayout); }
void WRAP_vkDestroyIndirectCommandsLayoutNV(VkDevice device, VkIndirectCommandsLayoutNV indirectCommandsLayout, const VkAllocationCallbacks* pAllocator) { vkDestroyIndirectCommandsLayoutNV(device, indirectCommandsLayout, pAllocator); }
void WRAP_vkGetGeneratedCommandsMemoryRequirementsNV(VkDevice device, 
            VkGeneratedCommandsMemoryRequirementsInfoNV& pInfo, 
        VkMemoryRequirements2& pMemoryRequirements) { vkGetGeneratedCommandsMemoryRequirementsNV(device, &pInfo, &pMemoryRequirements); }
#endif /* defined(VK_NV_device_generated_commands) */
#if defined(VK_NV_device_generated_commands_compute)
void WRAP_vkCmdUpdatePipelineIndirectBufferNV(VkCommandBuffer commandBuffer, VkPipelineBindPoint           pipelineBindPoint, VkPipeline                    pipeline) { vkCmdUpdatePipelineIndirectBufferNV(commandBuffer, pipelineBindPoint, pipeline); }
VkDeviceAddress WRAP_vkGetPipelineIndirectDeviceAddressNV(VkDevice device, 
        VkPipelineIndirectDeviceAddressInfoNV& pInfo) { return vkGetPipelineIndirectDeviceAddressNV(device, &pInfo); }
void WRAP_vkGetPipelineIndirectMemoryRequirementsNV(VkDevice device, 
            VkComputePipelineCreateInfo& pCreateInfo, 
        VkMemoryRequirements2& pMemoryRequirements) { vkGetPipelineIndirectMemoryRequirementsNV(device, &pCreateInfo, &pMemoryRequirements); }
#endif /* defined(VK_NV_device_generated_commands_compute) */
#if defined(VK_NV_external_memory_capabilities)
VkResult WRAP_vkGetPhysicalDeviceExternalImageFormatPropertiesNV(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkExternalMemoryHandleTypeFlagsNV externalHandleType, 
        VkExternalImageFormatPropertiesNV& pExternalImageFormatProperties) { return vkGetPhysicalDeviceExternalImageFormatPropertiesNV(physicalDevice, format, type, tiling, usage, flags, externalHandleType, &pExternalImageFormatProperties); }
#endif /* defined(VK_NV_external_memory_capabilities) */
#if defined(VK_NV_external_memory_rdma)
VkResult WRAP_vkGetMemoryRemoteAddressNV(VkDevice device, 
            VkMemoryGetRemoteAddressInfoNV& pMemoryGetRemoteAddressInfo, 
        VkRemoteAddressNV& pAddress) { return vkGetMemoryRemoteAddressNV(device, &pMemoryGetRemoteAddressInfo, &pAddress); }
#endif /* defined(VK_NV_external_memory_rdma) */
#if defined(VK_NV_external_memory_win32)
VkResult WRAP_vkGetMemoryWin32HandleNV(VkDevice device, VkDeviceMemory memory, VkExternalMemoryHandleTypeFlagsNV handleType, 
        HANDLE& pHandle) { return vkGetMemoryWin32HandleNV(device, memory, handleType, &pHandle); }
#endif /* defined(VK_NV_external_memory_win32) */
#if defined(VK_NV_fragment_shading_rate_enums)
void WRAP_vkCmdSetFragmentShadingRateEnumNV(VkCommandBuffer           commandBuffer, VkFragmentShadingRateNV                     shadingRate, const VkFragmentShadingRateCombinerOpKHR    combinerOps[2]) { vkCmdSetFragmentShadingRateEnumNV(commandBuffer, shadingRate, combinerOps); }
#endif /* defined(VK_NV_fragment_shading_rate_enums) */
#if defined(VK_NV_low_latency2)
void WRAP_vkGetLatencyTimingsNV(VkDevice device, VkSwapchainKHR swapchain, 
        VkGetLatencyMarkerInfoNV& pLatencyMarkerInfo) { vkGetLatencyTimingsNV(device, swapchain, &pLatencyMarkerInfo); }
VkResult WRAP_vkLatencySleepNV(VkDevice device, VkSwapchainKHR swapchain, 
        VkLatencySleepInfoNV& pSleepInfo) { return vkLatencySleepNV(device, swapchain, &pSleepInfo); }
void WRAP_vkQueueNotifyOutOfBandNV(VkQueue queue, 
        VkOutOfBandQueueTypeInfoNV& pQueueTypeInfo) { vkQueueNotifyOutOfBandNV(queue, &pQueueTypeInfo); }
void WRAP_vkSetLatencyMarkerNV(VkDevice device, VkSwapchainKHR swapchain, 
        VkSetLatencyMarkerInfoNV& pLatencyMarkerInfo) { vkSetLatencyMarkerNV(device, swapchain, &pLatencyMarkerInfo); }
VkResult WRAP_vkSetLatencySleepModeNV(VkDevice device, VkSwapchainKHR swapchain, 
        VkLatencySleepModeInfoNV& pSleepModeInfo) { return vkSetLatencySleepModeNV(device, swapchain, &pSleepModeInfo); }
#endif /* defined(VK_NV_low_latency2) */
#if defined(VK_NV_memory_decompression)
void WRAP_vkCmdDecompressMemoryIndirectCountNV(VkCommandBuffer commandBuffer, VkDeviceAddress indirectCommandsAddress, VkDeviceAddress indirectCommandsCountAddress, uint32_t stride) { vkCmdDecompressMemoryIndirectCountNV(commandBuffer, indirectCommandsAddress, indirectCommandsCountAddress, stride); }
void WRAP_vkCmdDecompressMemoryNV(VkCommandBuffer commandBuffer, uint32_t decompressRegionCount, const VkDecompressMemoryRegionNV* pDecompressMemoryRegions) { vkCmdDecompressMemoryNV(commandBuffer, decompressRegionCount, pDecompressMemoryRegions); }
#endif /* defined(VK_NV_memory_decompression) */
#if defined(VK_NV_mesh_shader)
void WRAP_vkCmdDrawMeshTasksIndirectCountNV(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) { vkCmdDrawMeshTasksIndirectCountNV(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride); }
void WRAP_vkCmdDrawMeshTasksIndirectNV(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride) { vkCmdDrawMeshTasksIndirectNV(commandBuffer, buffer, offset, drawCount, stride); }
void WRAP_vkCmdDrawMeshTasksNV(VkCommandBuffer commandBuffer, uint32_t taskCount, uint32_t firstTask) { vkCmdDrawMeshTasksNV(commandBuffer, taskCount, firstTask); }
#endif /* defined(VK_NV_mesh_shader) */
#if defined(VK_NV_optical_flow)
VkResult WRAP_vkBindOpticalFlowSessionImageNV(VkDevice device, VkOpticalFlowSessionNV session, VkOpticalFlowSessionBindingPointNV bindingPoint, VkImageView view, VkImageLayout layout) { return vkBindOpticalFlowSessionImageNV(device, session, bindingPoint, view, layout); }
void WRAP_vkCmdOpticalFlowExecuteNV(VkCommandBuffer commandBuffer, VkOpticalFlowSessionNV session, 
        VkOpticalFlowExecuteInfoNV& pExecuteInfo) { vkCmdOpticalFlowExecuteNV(commandBuffer, session, &pExecuteInfo); }
VkResult WRAP_vkCreateOpticalFlowSessionNV(VkDevice device, 
            VkOpticalFlowSessionCreateInfoNV& pCreateInfo, const VkAllocationCallbacks* pAllocator, 
        VkOpticalFlowSessionNV& pSession) { return vkCreateOpticalFlowSessionNV(device, &pCreateInfo, pAllocator, &pSession); }
void WRAP_vkDestroyOpticalFlowSessionNV(VkDevice device, VkOpticalFlowSessionNV session, const VkAllocationCallbacks* pAllocator) { vkDestroyOpticalFlowSessionNV(device, session, pAllocator); }
VkResult WRAP_vkGetPhysicalDeviceOpticalFlowImageFormatsNV(VkPhysicalDevice physicalDevice, 
            VkOpticalFlowImageFormatInfoNV& pOpticalFlowImageFormatInfo, 
            uint32_t& pFormatCount, VkOpticalFlowImageFormatPropertiesNV* pImageFormatProperties) { return vkGetPhysicalDeviceOpticalFlowImageFormatsNV(physicalDevice, &pOpticalFlowImageFormatInfo, &pFormatCount, pImageFormatProperties); }
#endif /* defined(VK_NV_optical_flow) */
#if defined(VK_NV_ray_tracing)
VkResult WRAP_vkBindAccelerationStructureMemoryNV(VkDevice device, uint32_t bindInfoCount, const VkBindAccelerationStructureMemoryInfoNV* pBindInfos) { return vkBindAccelerationStructureMemoryNV(device, bindInfoCount, pBindInfos); }
void WRAP_vkCmdBuildAccelerationStructureNV(VkCommandBuffer commandBuffer, 
            VkAccelerationStructureInfoNV& pInfo, VkBuffer instanceData, VkDeviceSize instanceOffset, VkBool32 update, VkAccelerationStructureNV dst, VkAccelerationStructureNV src, VkBuffer scratch, VkDeviceSize scratchOffset) { vkCmdBuildAccelerationStructureNV(commandBuffer, &pInfo, instanceData, instanceOffset, update, dst, src, scratch, scratchOffset); }
void WRAP_vkCmdCopyAccelerationStructureNV(VkCommandBuffer commandBuffer, VkAccelerationStructureNV dst, VkAccelerationStructureNV src, VkCopyAccelerationStructureModeKHR mode) { vkCmdCopyAccelerationStructureNV(commandBuffer, dst, src, mode); }
void WRAP_vkCmdTraceRaysNV(VkCommandBuffer commandBuffer, VkBuffer raygenShaderBindingTableBuffer, VkDeviceSize raygenShaderBindingOffset, VkBuffer missShaderBindingTableBuffer, VkDeviceSize missShaderBindingOffset, VkDeviceSize missShaderBindingStride, VkBuffer hitShaderBindingTableBuffer, VkDeviceSize hitShaderBindingOffset, VkDeviceSize hitShaderBindingStride, VkBuffer callableShaderBindingTableBuffer, VkDeviceSize callableShaderBindingOffset, VkDeviceSize callableShaderBindingStride, uint32_t width, uint32_t height, uint32_t depth) { vkCmdTraceRaysNV(commandBuffer, raygenShaderBindingTableBuffer, raygenShaderBindingOffset, missShaderBindingTableBuffer, missShaderBindingOffset, missShaderBindingStride, hitShaderBindingTableBuffer, hitShaderBindingOffset, hitShaderBindingStride, callableShaderBindingTableBuffer, callableShaderBindingOffset, callableShaderBindingStride, width, height, depth); }
void WRAP_vkCmdWriteAccelerationStructuresPropertiesNV(VkCommandBuffer commandBuffer, uint32_t accelerationStructureCount, const VkAccelerationStructureNV* pAccelerationStructures, VkQueryType queryType, VkQueryPool queryPool, uint32_t firstQuery) { vkCmdWriteAccelerationStructuresPropertiesNV(commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery); }
VkResult WRAP_vkCompileDeferredNV(VkDevice device, VkPipeline pipeline, uint32_t shader) { return vkCompileDeferredNV(device, pipeline, shader); }
VkResult WRAP_vkCreateAccelerationStructureNV(VkDevice device, 
            VkAccelerationStructureCreateInfoNV& pCreateInfo, const VkAllocationCallbacks* pAllocator, 
        VkAccelerationStructureNV& pAccelerationStructure) { return vkCreateAccelerationStructureNV(device, &pCreateInfo, pAllocator, &pAccelerationStructure); }
VkResult WRAP_vkCreateRayTracingPipelinesNV(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkRayTracingPipelineCreateInfoNV* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines) { return vkCreateRayTracingPipelinesNV(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines); }
void WRAP_vkDestroyAccelerationStructureNV(VkDevice device, VkAccelerationStructureNV accelerationStructure, const VkAllocationCallbacks* pAllocator) { vkDestroyAccelerationStructureNV(device, accelerationStructure, pAllocator); }
VkResult WRAP_vkGetAccelerationStructureHandleNV(VkDevice device, VkAccelerationStructureNV accelerationStructure, size_t dataSize, void* pData) { return vkGetAccelerationStructureHandleNV(device, accelerationStructure, dataSize, pData); }
void WRAP_vkGetAccelerationStructureMemoryRequirementsNV(VkDevice device, 
            VkAccelerationStructureMemoryRequirementsInfoNV& pInfo, 
        VkMemoryRequirements2KHR& pMemoryRequirements) { vkGetAccelerationStructureMemoryRequirementsNV(device, &pInfo, &pMemoryRequirements); }
VkResult WRAP_vkGetRayTracingShaderGroupHandlesNV(VkDevice device, VkPipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void* pData) { return vkGetRayTracingShaderGroupHandlesNV(device, pipeline, firstGroup, groupCount, dataSize, pData); }
#endif /* defined(VK_NV_ray_tracing) */
#if defined(VK_NV_scissor_exclusive) && VK_NV_SCISSOR_EXCLUSIVE_SPEC_VERSION >= 2
void WRAP_vkCmdSetExclusiveScissorEnableNV(VkCommandBuffer commandBuffer, uint32_t firstExclusiveScissor, uint32_t exclusiveScissorCount, const VkBool32* pExclusiveScissorEnables) { vkCmdSetExclusiveScissorEnableNV(commandBuffer, firstExclusiveScissor, exclusiveScissorCount, pExclusiveScissorEnables); }
#endif /* defined(VK_NV_scissor_exclusive) && VK_NV_SCISSOR_EXCLUSIVE_SPEC_VERSION >= 2 */
#if defined(VK_NV_scissor_exclusive)
void WRAP_vkCmdSetExclusiveScissorNV(VkCommandBuffer commandBuffer, uint32_t firstExclusiveScissor, uint32_t exclusiveScissorCount, const VkRect2D* pExclusiveScissors) { vkCmdSetExclusiveScissorNV(commandBuffer, firstExclusiveScissor, exclusiveScissorCount, pExclusiveScissors); }
#endif /* defined(VK_NV_scissor_exclusive) */
#if defined(VK_NV_shading_rate_image)
void WRAP_vkCmdBindShadingRateImageNV(VkCommandBuffer commandBuffer, VkImageView imageView, VkImageLayout imageLayout) { vkCmdBindShadingRateImageNV(commandBuffer, imageView, imageLayout); }
void WRAP_vkCmdSetCoarseSampleOrderNV(VkCommandBuffer commandBuffer, VkCoarseSampleOrderTypeNV sampleOrderType, uint32_t customSampleOrderCount, const VkCoarseSampleOrderCustomNV* pCustomSampleOrders) { vkCmdSetCoarseSampleOrderNV(commandBuffer, sampleOrderType, customSampleOrderCount, pCustomSampleOrders); }
void WRAP_vkCmdSetViewportShadingRatePaletteNV(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkShadingRatePaletteNV* pShadingRatePalettes) { vkCmdSetViewportShadingRatePaletteNV(commandBuffer, firstViewport, viewportCount, pShadingRatePalettes); }
#endif /* defined(VK_NV_shading_rate_image) */
#if defined(VK_QCOM_tile_properties)
VkResult WRAP_vkGetDynamicRenderingTilePropertiesQCOM(VkDevice device, 
            VkRenderingInfo& pRenderingInfo, 
        VkTilePropertiesQCOM& pProperties) { return vkGetDynamicRenderingTilePropertiesQCOM(device, &pRenderingInfo, &pProperties); }
VkResult WRAP_vkGetFramebufferTilePropertiesQCOM(VkDevice device, VkFramebuffer framebuffer, 
            uint32_t& pPropertiesCount, VkTilePropertiesQCOM* pProperties) { return vkGetFramebufferTilePropertiesQCOM(device, framebuffer, &pPropertiesCount, pProperties); }
#endif /* defined(VK_QCOM_tile_properties) */
#if defined(VK_QNX_external_memory_screen_buffer)
VkResult WRAP_vkGetScreenBufferPropertiesQNX(VkDevice device, 
            _screen_buffer& buffer, 
        VkScreenBufferPropertiesQNX& pProperties) { return vkGetScreenBufferPropertiesQNX(device, &buffer, &pProperties); }
#endif /* defined(VK_QNX_external_memory_screen_buffer) */
#if defined(VK_QNX_screen_surface)
VkResult WRAP_vkCreateScreenSurfaceQNX(VkInstance instance, 
            VkScreenSurfaceCreateInfoQNX& pCreateInfo, const VkAllocationCallbacks* pAllocator, 
        VkSurfaceKHR& pSurface) { return vkCreateScreenSurfaceQNX(instance, &pCreateInfo, pAllocator, &pSurface); }
bool WRAP_vkGetPhysicalDeviceScreenPresentationSupportQNX(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, 
        _screen_window& window) { return vkGetPhysicalDeviceScreenPresentationSupportQNX(physicalDevice, queueFamilyIndex, &window); }
#endif /* defined(VK_QNX_screen_surface) */
#if defined(VK_VALVE_descriptor_set_host_mapping)
void WRAP_vkGetDescriptorSetHostMappingVALVE(VkDevice device, VkDescriptorSet descriptorSet, void** ppData) { vkGetDescriptorSetHostMappingVALVE(device, descriptorSet, ppData); }
void WRAP_vkGetDescriptorSetLayoutHostMappingInfoVALVE(VkDevice device, 
            VkDescriptorSetBindingReferenceVALVE& pBindingReference, 
        VkDescriptorSetLayoutHostMappingInfoVALVE& pHostMapping) { vkGetDescriptorSetLayoutHostMappingInfoVALVE(device, &pBindingReference, &pHostMapping); }
#endif /* defined(VK_VALVE_descriptor_set_host_mapping) */
#if (defined(VK_EXT_depth_clamp_control)) || (defined(VK_EXT_shader_object) && defined(VK_EXT_depth_clamp_control))
void WRAP_vkCmdSetDepthClampRangeEXT(VkCommandBuffer commandBuffer, VkDepthClampModeEXT depthClampMode, const VkDepthClampRangeEXT* pDepthClampRange) { vkCmdSetDepthClampRangeEXT(commandBuffer, depthClampMode, pDepthClampRange); }
#endif /* (defined(VK_EXT_depth_clamp_control)) || (defined(VK_EXT_shader_object) && defined(VK_EXT_depth_clamp_control)) */
#if (defined(VK_EXT_extended_dynamic_state)) || (defined(VK_EXT_shader_object))
void WRAP_vkCmdBindVertexBuffers2EXT(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer* pBuffers, const VkDeviceSize* pOffsets, const VkDeviceSize* pSizes, const VkDeviceSize* pStrides) { vkCmdBindVertexBuffers2EXT(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes, pStrides); }
void WRAP_vkCmdSetCullModeEXT(VkCommandBuffer commandBuffer, VkCullModeFlags cullMode) { vkCmdSetCullModeEXT(commandBuffer, cullMode); }
void WRAP_vkCmdSetDepthBoundsTestEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthBoundsTestEnable) { vkCmdSetDepthBoundsTestEnableEXT(commandBuffer, depthBoundsTestEnable); }
void WRAP_vkCmdSetDepthCompareOpEXT(VkCommandBuffer commandBuffer, VkCompareOp depthCompareOp) { vkCmdSetDepthCompareOpEXT(commandBuffer, depthCompareOp); }
void WRAP_vkCmdSetDepthTestEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthTestEnable) { vkCmdSetDepthTestEnableEXT(commandBuffer, depthTestEnable); }
void WRAP_vkCmdSetDepthWriteEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthWriteEnable) { vkCmdSetDepthWriteEnableEXT(commandBuffer, depthWriteEnable); }
void WRAP_vkCmdSetFrontFaceEXT(VkCommandBuffer commandBuffer, VkFrontFace frontFace) { vkCmdSetFrontFaceEXT(commandBuffer, frontFace); }
void WRAP_vkCmdSetPrimitiveTopologyEXT(VkCommandBuffer commandBuffer, VkPrimitiveTopology primitiveTopology) { vkCmdSetPrimitiveTopologyEXT(commandBuffer, primitiveTopology); }
void WRAP_vkCmdSetScissorWithCountEXT(VkCommandBuffer commandBuffer, uint32_t scissorCount, const VkRect2D* pScissors) { vkCmdSetScissorWithCountEXT(commandBuffer, scissorCount, pScissors); }
void WRAP_vkCmdSetStencilOpEXT(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, VkStencilOp failOp, VkStencilOp passOp, VkStencilOp depthFailOp, VkCompareOp compareOp) { vkCmdSetStencilOpEXT(commandBuffer, faceMask, failOp, passOp, depthFailOp, compareOp); }
void WRAP_vkCmdSetStencilTestEnableEXT(VkCommandBuffer commandBuffer, VkBool32 stencilTestEnable) { vkCmdSetStencilTestEnableEXT(commandBuffer, stencilTestEnable); }
void WRAP_vkCmdSetViewportWithCountEXT(VkCommandBuffer commandBuffer, uint32_t viewportCount, const VkViewport* pViewports) { vkCmdSetViewportWithCountEXT(commandBuffer, viewportCount, pViewports); }
#endif /* (defined(VK_EXT_extended_dynamic_state)) || (defined(VK_EXT_shader_object)) */
#if (defined(VK_EXT_extended_dynamic_state2)) || (defined(VK_EXT_shader_object))
void WRAP_vkCmdSetDepthBiasEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthBiasEnable) { vkCmdSetDepthBiasEnableEXT(commandBuffer, depthBiasEnable); }
void WRAP_vkCmdSetLogicOpEXT(VkCommandBuffer commandBuffer, VkLogicOp logicOp) { vkCmdSetLogicOpEXT(commandBuffer, logicOp); }
void WRAP_vkCmdSetPatchControlPointsEXT(VkCommandBuffer commandBuffer, uint32_t patchControlPoints) { vkCmdSetPatchControlPointsEXT(commandBuffer, patchControlPoints); }
void WRAP_vkCmdSetPrimitiveRestartEnableEXT(VkCommandBuffer commandBuffer, VkBool32 primitiveRestartEnable) { vkCmdSetPrimitiveRestartEnableEXT(commandBuffer, primitiveRestartEnable); }
void WRAP_vkCmdSetRasterizerDiscardEnableEXT(VkCommandBuffer commandBuffer, VkBool32 rasterizerDiscardEnable) { vkCmdSetRasterizerDiscardEnableEXT(commandBuffer, rasterizerDiscardEnable); }
#endif /* (defined(VK_EXT_extended_dynamic_state2)) || (defined(VK_EXT_shader_object)) */
#if (defined(VK_EXT_extended_dynamic_state3)) || (defined(VK_EXT_shader_object))
void WRAP_vkCmdSetAlphaToCoverageEnableEXT(VkCommandBuffer commandBuffer, VkBool32 alphaToCoverageEnable) { vkCmdSetAlphaToCoverageEnableEXT(commandBuffer, alphaToCoverageEnable); }
void WRAP_vkCmdSetAlphaToOneEnableEXT(VkCommandBuffer commandBuffer, VkBool32 alphaToOneEnable) { vkCmdSetAlphaToOneEnableEXT(commandBuffer, alphaToOneEnable); }
void WRAP_vkCmdSetColorBlendEnableEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkBool32* pColorBlendEnables) { vkCmdSetColorBlendEnableEXT(commandBuffer, firstAttachment, attachmentCount, pColorBlendEnables); }
void WRAP_vkCmdSetColorBlendEquationEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkColorBlendEquationEXT* pColorBlendEquations) { vkCmdSetColorBlendEquationEXT(commandBuffer, firstAttachment, attachmentCount, pColorBlendEquations); }
void WRAP_vkCmdSetColorWriteMaskEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkColorComponentFlags* pColorWriteMasks) { vkCmdSetColorWriteMaskEXT(commandBuffer, firstAttachment, attachmentCount, pColorWriteMasks); }
void WRAP_vkCmdSetDepthClampEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthClampEnable) { vkCmdSetDepthClampEnableEXT(commandBuffer, depthClampEnable); }
void WRAP_vkCmdSetLogicOpEnableEXT(VkCommandBuffer commandBuffer, VkBool32 logicOpEnable) { vkCmdSetLogicOpEnableEXT(commandBuffer, logicOpEnable); }
void WRAP_vkCmdSetPolygonModeEXT(VkCommandBuffer commandBuffer, VkPolygonMode polygonMode) { vkCmdSetPolygonModeEXT(commandBuffer, polygonMode); }
void WRAP_vkCmdSetRasterizationSamplesEXT(VkCommandBuffer commandBuffer, VkSampleCountFlagBits  rasterizationSamples) { vkCmdSetRasterizationSamplesEXT(commandBuffer, rasterizationSamples); }
void WRAP_vkCmdSetSampleMaskEXT(VkCommandBuffer commandBuffer, VkSampleCountFlagBits  samples, const VkSampleMask*    pSampleMask) { vkCmdSetSampleMaskEXT(commandBuffer, samples, pSampleMask); }
#endif /* (defined(VK_EXT_extended_dynamic_state3)) || (defined(VK_EXT_shader_object)) */
#if (defined(VK_EXT_extended_dynamic_state3) && (defined(VK_KHR_maintenance2) || defined(VK_VERSION_1_1))) || (defined(VK_EXT_shader_object))
void WRAP_vkCmdSetTessellationDomainOriginEXT(VkCommandBuffer commandBuffer, VkTessellationDomainOrigin domainOrigin) { vkCmdSetTessellationDomainOriginEXT(commandBuffer, domainOrigin); }
#endif /* (defined(VK_EXT_extended_dynamic_state3) && (defined(VK_KHR_maintenance2) || defined(VK_VERSION_1_1))) || (defined(VK_EXT_shader_object)) */
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_EXT_transform_feedback)) || (defined(VK_EXT_shader_object) && defined(VK_EXT_transform_feedback))
void WRAP_vkCmdSetRasterizationStreamEXT(VkCommandBuffer commandBuffer, uint32_t rasterizationStream) { vkCmdSetRasterizationStreamEXT(commandBuffer, rasterizationStream); }
#endif /* (defined(VK_EXT_extended_dynamic_state3) && defined(VK_EXT_transform_feedback)) || (defined(VK_EXT_shader_object) && defined(VK_EXT_transform_feedback)) */
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_EXT_conservative_rasterization)) || (defined(VK_EXT_shader_object) && defined(VK_EXT_conservative_rasterization))
void WRAP_vkCmdSetConservativeRasterizationModeEXT(VkCommandBuffer commandBuffer, VkConservativeRasterizationModeEXT conservativeRasterizationMode) { vkCmdSetConservativeRasterizationModeEXT(commandBuffer, conservativeRasterizationMode); }
void WRAP_vkCmdSetExtraPrimitiveOverestimationSizeEXT(VkCommandBuffer commandBuffer, float extraPrimitiveOverestimationSize) { vkCmdSetExtraPrimitiveOverestimationSizeEXT(commandBuffer, extraPrimitiveOverestimationSize); }
#endif /* (defined(VK_EXT_extended_dynamic_state3) && defined(VK_EXT_conservative_rasterization)) || (defined(VK_EXT_shader_object) && defined(VK_EXT_conservative_rasterization)) */
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_EXT_depth_clip_enable)) || (defined(VK_EXT_shader_object) && defined(VK_EXT_depth_clip_enable))
void WRAP_vkCmdSetDepthClipEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthClipEnable) { vkCmdSetDepthClipEnableEXT(commandBuffer, depthClipEnable); }
#endif /* (defined(VK_EXT_extended_dynamic_state3) && defined(VK_EXT_depth_clip_enable)) || (defined(VK_EXT_shader_object) && defined(VK_EXT_depth_clip_enable)) */
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_EXT_sample_locations)) || (defined(VK_EXT_shader_object) && defined(VK_EXT_sample_locations))
void WRAP_vkCmdSetSampleLocationsEnableEXT(VkCommandBuffer commandBuffer, VkBool32 sampleLocationsEnable) { vkCmdSetSampleLocationsEnableEXT(commandBuffer, sampleLocationsEnable); }
#endif /* (defined(VK_EXT_extended_dynamic_state3) && defined(VK_EXT_sample_locations)) || (defined(VK_EXT_shader_object) && defined(VK_EXT_sample_locations)) */
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_EXT_blend_operation_advanced)) || (defined(VK_EXT_shader_object) && defined(VK_EXT_blend_operation_advanced))
void WRAP_vkCmdSetColorBlendAdvancedEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkColorBlendAdvancedEXT* pColorBlendAdvanced) { vkCmdSetColorBlendAdvancedEXT(commandBuffer, firstAttachment, attachmentCount, pColorBlendAdvanced); }
#endif /* (defined(VK_EXT_extended_dynamic_state3) && defined(VK_EXT_blend_operation_advanced)) || (defined(VK_EXT_shader_object) && defined(VK_EXT_blend_operation_advanced)) */
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_EXT_provoking_vertex)) || (defined(VK_EXT_shader_object) && defined(VK_EXT_provoking_vertex))
void WRAP_vkCmdSetProvokingVertexModeEXT(VkCommandBuffer commandBuffer, VkProvokingVertexModeEXT provokingVertexMode) { vkCmdSetProvokingVertexModeEXT(commandBuffer, provokingVertexMode); }
#endif /* (defined(VK_EXT_extended_dynamic_state3) && defined(VK_EXT_provoking_vertex)) || (defined(VK_EXT_shader_object) && defined(VK_EXT_provoking_vertex)) */
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_EXT_line_rasterization)) || (defined(VK_EXT_shader_object) && defined(VK_EXT_line_rasterization))
void WRAP_vkCmdSetLineRasterizationModeEXT(VkCommandBuffer commandBuffer, VkLineRasterizationModeEXT lineRasterizationMode) { vkCmdSetLineRasterizationModeEXT(commandBuffer, lineRasterizationMode); }
void WRAP_vkCmdSetLineStippleEnableEXT(VkCommandBuffer commandBuffer, VkBool32 stippledLineEnable) { vkCmdSetLineStippleEnableEXT(commandBuffer, stippledLineEnable); }
#endif /* (defined(VK_EXT_extended_dynamic_state3) && defined(VK_EXT_line_rasterization)) || (defined(VK_EXT_shader_object) && defined(VK_EXT_line_rasterization)) */
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_EXT_depth_clip_control)) || (defined(VK_EXT_shader_object) && defined(VK_EXT_depth_clip_control))
void WRAP_vkCmdSetDepthClipNegativeOneToOneEXT(VkCommandBuffer commandBuffer, VkBool32 negativeOneToOne) { vkCmdSetDepthClipNegativeOneToOneEXT(commandBuffer, negativeOneToOne); }
#endif /* (defined(VK_EXT_extended_dynamic_state3) && defined(VK_EXT_depth_clip_control)) || (defined(VK_EXT_shader_object) && defined(VK_EXT_depth_clip_control)) */
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_NV_clip_space_w_scaling)) || (defined(VK_EXT_shader_object) && defined(VK_NV_clip_space_w_scaling))
void WRAP_vkCmdSetViewportWScalingEnableNV(VkCommandBuffer commandBuffer, VkBool32 viewportWScalingEnable) { vkCmdSetViewportWScalingEnableNV(commandBuffer, viewportWScalingEnable); }
#endif /* (defined(VK_EXT_extended_dynamic_state3) && defined(VK_NV_clip_space_w_scaling)) || (defined(VK_EXT_shader_object) && defined(VK_NV_clip_space_w_scaling)) */
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_NV_viewport_swizzle)) || (defined(VK_EXT_shader_object) && defined(VK_NV_viewport_swizzle))
void WRAP_vkCmdSetViewportSwizzleNV(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewportSwizzleNV* pViewportSwizzles) { vkCmdSetViewportSwizzleNV(commandBuffer, firstViewport, viewportCount, pViewportSwizzles); }
#endif /* (defined(VK_EXT_extended_dynamic_state3) && defined(VK_NV_viewport_swizzle)) || (defined(VK_EXT_shader_object) && defined(VK_NV_viewport_swizzle)) */
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_NV_fragment_coverage_to_color)) || (defined(VK_EXT_shader_object) && defined(VK_NV_fragment_coverage_to_color))
void WRAP_vkCmdSetCoverageToColorEnableNV(VkCommandBuffer commandBuffer, VkBool32 coverageToColorEnable) { vkCmdSetCoverageToColorEnableNV(commandBuffer, coverageToColorEnable); }
void WRAP_vkCmdSetCoverageToColorLocationNV(VkCommandBuffer commandBuffer, uint32_t coverageToColorLocation) { vkCmdSetCoverageToColorLocationNV(commandBuffer, coverageToColorLocation); }
#endif /* (defined(VK_EXT_extended_dynamic_state3) && defined(VK_NV_fragment_coverage_to_color)) || (defined(VK_EXT_shader_object) && defined(VK_NV_fragment_coverage_to_color)) */
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_NV_framebuffer_mixed_samples)) || (defined(VK_EXT_shader_object) && defined(VK_NV_framebuffer_mixed_samples))
void WRAP_vkCmdSetCoverageModulationModeNV(VkCommandBuffer commandBuffer, VkCoverageModulationModeNV coverageModulationMode) { vkCmdSetCoverageModulationModeNV(commandBuffer, coverageModulationMode); }
void WRAP_vkCmdSetCoverageModulationTableEnableNV(VkCommandBuffer commandBuffer, VkBool32 coverageModulationTableEnable) { vkCmdSetCoverageModulationTableEnableNV(commandBuffer, coverageModulationTableEnable); }
void WRAP_vkCmdSetCoverageModulationTableNV(VkCommandBuffer commandBuffer, uint32_t coverageModulationTableCount, const float* pCoverageModulationTable) { vkCmdSetCoverageModulationTableNV(commandBuffer, coverageModulationTableCount, pCoverageModulationTable); }
#endif /* (defined(VK_EXT_extended_dynamic_state3) && defined(VK_NV_framebuffer_mixed_samples)) || (defined(VK_EXT_shader_object) && defined(VK_NV_framebuffer_mixed_samples)) */
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_NV_shading_rate_image)) || (defined(VK_EXT_shader_object) && defined(VK_NV_shading_rate_image))
void WRAP_vkCmdSetShadingRateImageEnableNV(VkCommandBuffer commandBuffer, VkBool32 shadingRateImageEnable) { vkCmdSetShadingRateImageEnableNV(commandBuffer, shadingRateImageEnable); }
#endif /* (defined(VK_EXT_extended_dynamic_state3) && defined(VK_NV_shading_rate_image)) || (defined(VK_EXT_shader_object) && defined(VK_NV_shading_rate_image)) */
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_NV_representative_fragment_test)) || (defined(VK_EXT_shader_object) && defined(VK_NV_representative_fragment_test))
void WRAP_vkCmdSetRepresentativeFragmentTestEnableNV(VkCommandBuffer commandBuffer, VkBool32 representativeFragmentTestEnable) { vkCmdSetRepresentativeFragmentTestEnableNV(commandBuffer, representativeFragmentTestEnable); }
#endif /* (defined(VK_EXT_extended_dynamic_state3) && defined(VK_NV_representative_fragment_test)) || (defined(VK_EXT_shader_object) && defined(VK_NV_representative_fragment_test)) */
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_NV_coverage_reduction_mode)) || (defined(VK_EXT_shader_object) && defined(VK_NV_coverage_reduction_mode))
void WRAP_vkCmdSetCoverageReductionModeNV(VkCommandBuffer commandBuffer, VkCoverageReductionModeNV coverageReductionMode) { vkCmdSetCoverageReductionModeNV(commandBuffer, coverageReductionMode); }
#endif /* (defined(VK_EXT_extended_dynamic_state3) && defined(VK_NV_coverage_reduction_mode)) || (defined(VK_EXT_shader_object) && defined(VK_NV_coverage_reduction_mode)) */
#if (defined(VK_EXT_host_image_copy)) || (defined(VK_EXT_image_compression_control))
void WRAP_vkGetImageSubresourceLayout2EXT(VkDevice device, VkImage image, 
            VkImageSubresource2& pSubresource, 
        VkSubresourceLayout2& pLayout) { vkGetImageSubresourceLayout2EXT(device, image, &pSubresource, &pLayout); }
#endif /* (defined(VK_EXT_host_image_copy)) || (defined(VK_EXT_image_compression_control)) */
#if (defined(VK_EXT_shader_object)) || (defined(VK_EXT_vertex_input_dynamic_state))
void WRAP_vkCmdSetVertexInputEXT(VkCommandBuffer commandBuffer, uint32_t vertexBindingDescriptionCount, const VkVertexInputBindingDescription2EXT* pVertexBindingDescriptions, uint32_t vertexAttributeDescriptionCount, const VkVertexInputAttributeDescription2EXT* pVertexAttributeDescriptions) { vkCmdSetVertexInputEXT(commandBuffer, vertexBindingDescriptionCount, pVertexBindingDescriptions, vertexAttributeDescriptionCount, pVertexAttributeDescriptions); }
#endif /* (defined(VK_EXT_shader_object)) || (defined(VK_EXT_vertex_input_dynamic_state)) */
#if (defined(VK_KHR_descriptor_update_template) && defined(VK_KHR_push_descriptor)) || (defined(VK_KHR_push_descriptor) && (defined(VK_VERSION_1_1) || defined(VK_KHR_descriptor_update_template)))
void WRAP_vkCmdPushDescriptorSetWithTemplateKHR(VkCommandBuffer commandBuffer, VkDescriptorUpdateTemplate descriptorUpdateTemplate, VkPipelineLayout layout, uint32_t set, const void* pData) { vkCmdPushDescriptorSetWithTemplateKHR(commandBuffer, descriptorUpdateTemplate, layout, set, pData); }
#endif /* (defined(VK_KHR_descriptor_update_template) && defined(VK_KHR_push_descriptor)) || (defined(VK_KHR_push_descriptor) && (defined(VK_VERSION_1_1) || defined(VK_KHR_descriptor_update_template))) */
#if (defined(VK_KHR_device_group) && defined(VK_KHR_surface)) || (defined(VK_KHR_swapchain) && defined(VK_VERSION_1_1))
VkResult WRAP_vkGetDeviceGroupPresentCapabilitiesKHR(VkDevice device, 
        VkDeviceGroupPresentCapabilitiesKHR& pDeviceGroupPresentCapabilities) { return vkGetDeviceGroupPresentCapabilitiesKHR(device, &pDeviceGroupPresentCapabilities); }
VkResult WRAP_vkGetDeviceGroupSurfacePresentModesKHR(VkDevice device, VkSurfaceKHR surface, 
        VkDeviceGroupPresentModeFlagsKHR& pModes) { return vkGetDeviceGroupSurfacePresentModesKHR(device, surface, &pModes); }
VkResult WRAP_vkGetPhysicalDevicePresentRectanglesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, 
            uint32_t& pRectCount, VkRect2D* pRects) { return vkGetPhysicalDevicePresentRectanglesKHR(physicalDevice, surface, &pRectCount, pRects); }
#endif /* (defined(VK_KHR_device_group) && defined(VK_KHR_surface)) || (defined(VK_KHR_swapchain) && defined(VK_VERSION_1_1)) */
#if (defined(VK_KHR_device_group) && defined(VK_KHR_swapchain)) || (defined(VK_KHR_swapchain) && defined(VK_VERSION_1_1))
VkResult WRAP_vkAcquireNextImage2KHR(VkDevice device, 
            VkAcquireNextImageInfoKHR& pAcquireInfo, 
        uint32_t& pImageIndex) { return vkAcquireNextImage2KHR(device, &pAcquireInfo, &pImageIndex); }
#endif /* (defined(VK_KHR_device_group) && defined(VK_KHR_swapchain)) || (defined(VK_KHR_swapchain) && defined(VK_VERSION_1_1)) */
/* VOLK_GENERATE_WRAP_FUNC */

void Module_dasVulkan::bindFunctions(ModuleLibrary &lib)
{
  /* VOLK_GENERATE_BIND_FUNC */
#if defined(VK_VERSION_1_0)
addExtern<DAS_BIND_FUN(WRAP_vkAllocateCommandBuffers)>(*this, lib, "vkAllocateCommandBuffers", SideEffects::worstDefault, "WRAP_vkAllocateCommandBuffers")
  ->args({"device", "pAllocateInfo", "pCommandBuffers"});
addExtern<DAS_BIND_FUN(WRAP_vkAllocateDescriptorSets)>(*this, lib, "vkAllocateDescriptorSets", SideEffects::worstDefault, "WRAP_vkAllocateDescriptorSets")
  ->args({"device", "pAllocateInfo", "pDescriptorSets"});
addExtern<DAS_BIND_FUN(WRAP_vkAllocateMemory)>(*this, lib, "vkAllocateMemory", SideEffects::worstDefault, "WRAP_vkAllocateMemory")
  ->args({"device", "pAllocateInfo", "pAllocator", "pMemory"});
addExtern<DAS_BIND_FUN(WRAP_vkBeginCommandBuffer)>(*this, lib, "vkBeginCommandBuffer", SideEffects::worstDefault, "WRAP_vkBeginCommandBuffer")
  ->args({"commandBuffer", "pBeginInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkBindBufferMemory)>(*this, lib, "vkBindBufferMemory", SideEffects::worstDefault, "WRAP_vkBindBufferMemory")
  ->args({"device", "buffer", "memory", "memoryOffset"});
addExtern<DAS_BIND_FUN(WRAP_vkBindImageMemory)>(*this, lib, "vkBindImageMemory", SideEffects::worstDefault, "WRAP_vkBindImageMemory")
  ->args({"device", "image", "memory", "memoryOffset"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdBeginQuery)>(*this, lib, "vkCmdBeginQuery", SideEffects::worstDefault, "WRAP_vkCmdBeginQuery")
  ->args({"commandBuffer", "queryPool", "query", "flags"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdBeginRenderPass)>(*this, lib, "vkCmdBeginRenderPass", SideEffects::worstDefault, "WRAP_vkCmdBeginRenderPass")
  ->args({"commandBuffer", "pRenderPassBegin", "contents"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdBindDescriptorSets)>(*this, lib, "vkCmdBindDescriptorSets", SideEffects::worstDefault, "WRAP_vkCmdBindDescriptorSets")
  ->args({"commandBuffer", "pipelineBindPoint", "layout", "firstSet", "descriptorSetCount", "pDescriptorSets", "dynamicOffsetCount", "pDynamicOffsets"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdBindIndexBuffer)>(*this, lib, "vkCmdBindIndexBuffer", SideEffects::worstDefault, "WRAP_vkCmdBindIndexBuffer")
  ->args({"commandBuffer", "buffer", "offset", "indexType"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdBindPipeline)>(*this, lib, "vkCmdBindPipeline", SideEffects::worstDefault, "WRAP_vkCmdBindPipeline")
  ->args({"commandBuffer", "pipelineBindPoint", "pipeline"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdBindVertexBuffers)>(*this, lib, "vkCmdBindVertexBuffers", SideEffects::worstDefault, "WRAP_vkCmdBindVertexBuffers")
  ->args({"commandBuffer", "firstBinding", "bindingCount", "pBuffers", "pOffsets"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdBlitImage)>(*this, lib, "vkCmdBlitImage", SideEffects::worstDefault, "WRAP_vkCmdBlitImage")
  ->args({"commandBuffer", "srcImage", "srcImageLayout", "dstImage", "dstImageLayout", "regionCount", "pRegions", "filter"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdClearAttachments)>(*this, lib, "vkCmdClearAttachments", SideEffects::worstDefault, "WRAP_vkCmdClearAttachments")
  ->args({"commandBuffer", "attachmentCount", "pAttachments", "rectCount", "pRects"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdClearColorImage)>(*this, lib, "vkCmdClearColorImage", SideEffects::worstDefault, "WRAP_vkCmdClearColorImage")
  ->args({"commandBuffer", "image", "imageLayout", "pColor", "rangeCount", "pRanges"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdClearDepthStencilImage)>(*this, lib, "vkCmdClearDepthStencilImage", SideEffects::worstDefault, "WRAP_vkCmdClearDepthStencilImage")
  ->args({"commandBuffer", "image", "imageLayout", "pDepthStencil", "rangeCount", "pRanges"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdCopyBuffer)>(*this, lib, "vkCmdCopyBuffer", SideEffects::worstDefault, "WRAP_vkCmdCopyBuffer")
  ->args({"commandBuffer", "srcBuffer", "dstBuffer", "regionCount", "pRegions"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdCopyBufferToImage)>(*this, lib, "vkCmdCopyBufferToImage", SideEffects::worstDefault, "WRAP_vkCmdCopyBufferToImage")
  ->args({"commandBuffer", "srcBuffer", "dstImage", "dstImageLayout", "regionCount", "pRegions"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdCopyImage)>(*this, lib, "vkCmdCopyImage", SideEffects::worstDefault, "WRAP_vkCmdCopyImage")
  ->args({"commandBuffer", "srcImage", "srcImageLayout", "dstImage", "dstImageLayout", "regionCount", "pRegions"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdCopyImageToBuffer)>(*this, lib, "vkCmdCopyImageToBuffer", SideEffects::worstDefault, "WRAP_vkCmdCopyImageToBuffer")
  ->args({"commandBuffer", "srcImage", "srcImageLayout", "dstBuffer", "regionCount", "pRegions"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdCopyQueryPoolResults)>(*this, lib, "vkCmdCopyQueryPoolResults", SideEffects::worstDefault, "WRAP_vkCmdCopyQueryPoolResults")
  ->args({"commandBuffer", "queryPool", "firstQuery", "queryCount", "dstBuffer", "dstOffset", "stride", "flags"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdDispatch)>(*this, lib, "vkCmdDispatch", SideEffects::worstDefault, "WRAP_vkCmdDispatch")
  ->args({"commandBuffer", "groupCountX", "groupCountY", "groupCountZ"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdDispatchIndirect)>(*this, lib, "vkCmdDispatchIndirect", SideEffects::worstDefault, "WRAP_vkCmdDispatchIndirect")
  ->args({"commandBuffer", "buffer", "offset"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdDraw)>(*this, lib, "vkCmdDraw", SideEffects::worstDefault, "WRAP_vkCmdDraw")
  ->args({"commandBuffer", "vertexCount", "instanceCount", "firstVertex", "firstInstance"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdDrawIndexed)>(*this, lib, "vkCmdDrawIndexed", SideEffects::worstDefault, "WRAP_vkCmdDrawIndexed")
  ->args({"commandBuffer", "indexCount", "instanceCount", "firstIndex", "vertexOffset", "firstInstance"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdDrawIndexedIndirect)>(*this, lib, "vkCmdDrawIndexedIndirect", SideEffects::worstDefault, "WRAP_vkCmdDrawIndexedIndirect")
  ->args({"commandBuffer", "buffer", "offset", "drawCount", "stride"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdDrawIndirect)>(*this, lib, "vkCmdDrawIndirect", SideEffects::worstDefault, "WRAP_vkCmdDrawIndirect")
  ->args({"commandBuffer", "buffer", "offset", "drawCount", "stride"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdEndQuery)>(*this, lib, "vkCmdEndQuery", SideEffects::worstDefault, "WRAP_vkCmdEndQuery")
  ->args({"commandBuffer", "queryPool", "query"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdEndRenderPass)>(*this, lib, "vkCmdEndRenderPass", SideEffects::worstDefault, "WRAP_vkCmdEndRenderPass")
  ->args({"commandBuffer"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdExecuteCommands)>(*this, lib, "vkCmdExecuteCommands", SideEffects::worstDefault, "WRAP_vkCmdExecuteCommands")
  ->args({"commandBuffer", "commandBufferCount", "pCommandBuffers"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdFillBuffer)>(*this, lib, "vkCmdFillBuffer", SideEffects::worstDefault, "WRAP_vkCmdFillBuffer")
  ->args({"commandBuffer", "dstBuffer", "dstOffset", "size", "data"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdNextSubpass)>(*this, lib, "vkCmdNextSubpass", SideEffects::worstDefault, "WRAP_vkCmdNextSubpass")
  ->args({"commandBuffer", "contents"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdPipelineBarrier)>(*this, lib, "vkCmdPipelineBarrier", SideEffects::worstDefault, "WRAP_vkCmdPipelineBarrier")
  ->args({"commandBuffer", "srcStageMask", "dstStageMask", "dependencyFlags", "memoryBarrierCount", "pMemoryBarriers", "bufferMemoryBarrierCount", "pBufferMemoryBarriers", "imageMemoryBarrierCount", "pImageMemoryBarriers"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdPushConstants)>(*this, lib, "vkCmdPushConstants", SideEffects::worstDefault, "WRAP_vkCmdPushConstants")
  ->args({"commandBuffer", "layout", "stageFlags", "offset", "size", "pValues"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdResetEvent)>(*this, lib, "vkCmdResetEvent", SideEffects::worstDefault, "WRAP_vkCmdResetEvent")
  ->args({"commandBuffer", "event", "stageMask"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdResetQueryPool)>(*this, lib, "vkCmdResetQueryPool", SideEffects::worstDefault, "WRAP_vkCmdResetQueryPool")
  ->args({"commandBuffer", "queryPool", "firstQuery", "queryCount"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdResolveImage)>(*this, lib, "vkCmdResolveImage", SideEffects::worstDefault, "WRAP_vkCmdResolveImage")
  ->args({"commandBuffer", "srcImage", "srcImageLayout", "dstImage", "dstImageLayout", "regionCount", "pRegions"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetBlendConstants)>(*this, lib, "vkCmdSetBlendConstants", SideEffects::worstDefault, "WRAP_vkCmdSetBlendConstants")
  ->args({"commandBuffer", "blendConstants"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetDepthBias)>(*this, lib, "vkCmdSetDepthBias", SideEffects::worstDefault, "WRAP_vkCmdSetDepthBias")
  ->args({"commandBuffer", "depthBiasConstantFactor", "depthBiasClamp", "depthBiasSlopeFactor"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetDepthBounds)>(*this, lib, "vkCmdSetDepthBounds", SideEffects::worstDefault, "WRAP_vkCmdSetDepthBounds")
  ->args({"commandBuffer", "minDepthBounds", "maxDepthBounds"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetEvent)>(*this, lib, "vkCmdSetEvent", SideEffects::worstDefault, "WRAP_vkCmdSetEvent")
  ->args({"commandBuffer", "event", "stageMask"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetLineWidth)>(*this, lib, "vkCmdSetLineWidth", SideEffects::worstDefault, "WRAP_vkCmdSetLineWidth")
  ->args({"commandBuffer", "lineWidth"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetScissor)>(*this, lib, "vkCmdSetScissor", SideEffects::worstDefault, "WRAP_vkCmdSetScissor")
  ->args({"commandBuffer", "firstScissor", "scissorCount", "pScissors"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetStencilCompareMask)>(*this, lib, "vkCmdSetStencilCompareMask", SideEffects::worstDefault, "WRAP_vkCmdSetStencilCompareMask")
  ->args({"commandBuffer", "faceMask", "compareMask"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetStencilReference)>(*this, lib, "vkCmdSetStencilReference", SideEffects::worstDefault, "WRAP_vkCmdSetStencilReference")
  ->args({"commandBuffer", "faceMask", "reference"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetStencilWriteMask)>(*this, lib, "vkCmdSetStencilWriteMask", SideEffects::worstDefault, "WRAP_vkCmdSetStencilWriteMask")
  ->args({"commandBuffer", "faceMask", "writeMask"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetViewport)>(*this, lib, "vkCmdSetViewport", SideEffects::worstDefault, "WRAP_vkCmdSetViewport")
  ->args({"commandBuffer", "firstViewport", "viewportCount", "pViewports"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdUpdateBuffer)>(*this, lib, "vkCmdUpdateBuffer", SideEffects::worstDefault, "WRAP_vkCmdUpdateBuffer")
  ->args({"commandBuffer", "dstBuffer", "dstOffset", "dataSize", "pData"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdWaitEvents)>(*this, lib, "vkCmdWaitEvents", SideEffects::worstDefault, "WRAP_vkCmdWaitEvents")
  ->args({"commandBuffer", "eventCount", "pEvents", "srcStageMask", "dstStageMask", "memoryBarrierCount", "pMemoryBarriers", "bufferMemoryBarrierCount", "pBufferMemoryBarriers", "imageMemoryBarrierCount", "pImageMemoryBarriers"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdWriteTimestamp)>(*this, lib, "vkCmdWriteTimestamp", SideEffects::worstDefault, "WRAP_vkCmdWriteTimestamp")
  ->args({"commandBuffer", "pipelineStage", "queryPool", "query"});
addExtern<DAS_BIND_FUN(WRAP_vkCreateBuffer)>(*this, lib, "vkCreateBuffer", SideEffects::worstDefault, "WRAP_vkCreateBuffer")
  ->args({"device", "pCreateInfo", "pAllocator", "pBuffer"});
addExtern<DAS_BIND_FUN(WRAP_vkCreateBufferView)>(*this, lib, "vkCreateBufferView", SideEffects::worstDefault, "WRAP_vkCreateBufferView")
  ->args({"device", "pCreateInfo", "pAllocator", "pView"});
addExtern<DAS_BIND_FUN(WRAP_vkCreateCommandPool)>(*this, lib, "vkCreateCommandPool", SideEffects::worstDefault, "WRAP_vkCreateCommandPool")
  ->args({"device", "pCreateInfo", "pAllocator", "pCommandPool"});
addExtern<DAS_BIND_FUN(WRAP_vkCreateComputePipelines)>(*this, lib, "vkCreateComputePipelines", SideEffects::worstDefault, "WRAP_vkCreateComputePipelines")
  ->args({"device", "pipelineCache", "createInfoCount", "pCreateInfos", "pAllocator", "pPipelines"});
addExtern<DAS_BIND_FUN(WRAP_vkCreateDescriptorPool)>(*this, lib, "vkCreateDescriptorPool", SideEffects::worstDefault, "WRAP_vkCreateDescriptorPool")
  ->args({"device", "pCreateInfo", "pAllocator", "pDescriptorPool"});
addExtern<DAS_BIND_FUN(WRAP_vkCreateDescriptorSetLayout)>(*this, lib, "vkCreateDescriptorSetLayout", SideEffects::worstDefault, "WRAP_vkCreateDescriptorSetLayout")
  ->args({"device", "pCreateInfo", "pAllocator", "pSetLayout"});
addExtern<DAS_BIND_FUN(WRAP_vkCreateDevice)>(*this, lib, "vkCreateDevice", SideEffects::worstDefault, "WRAP_vkCreateDevice")
  ->args({"physicalDevice", "pCreateInfo", "pAllocator", "pDevice"});
addExtern<DAS_BIND_FUN(WRAP_vkCreateEvent)>(*this, lib, "vkCreateEvent", SideEffects::worstDefault, "WRAP_vkCreateEvent")
  ->args({"device", "pCreateInfo", "pAllocator", "pEvent"});
addExtern<DAS_BIND_FUN(WRAP_vkCreateFence)>(*this, lib, "vkCreateFence", SideEffects::worstDefault, "WRAP_vkCreateFence")
  ->args({"device", "pCreateInfo", "pAllocator", "pFence"});
addExtern<DAS_BIND_FUN(WRAP_vkCreateFramebuffer)>(*this, lib, "vkCreateFramebuffer", SideEffects::worstDefault, "WRAP_vkCreateFramebuffer")
  ->args({"device", "pCreateInfo", "pAllocator", "pFramebuffer"});
addExtern<DAS_BIND_FUN(WRAP_vkCreateGraphicsPipelines)>(*this, lib, "vkCreateGraphicsPipelines", SideEffects::worstDefault, "WRAP_vkCreateGraphicsPipelines")
  ->args({"device", "pipelineCache", "createInfoCount", "pCreateInfos", "pAllocator", "pPipelines"});
addExtern<DAS_BIND_FUN(WRAP_vkCreateImage)>(*this, lib, "vkCreateImage", SideEffects::worstDefault, "WRAP_vkCreateImage")
  ->args({"device", "pCreateInfo", "pAllocator", "pImage"});
addExtern<DAS_BIND_FUN(WRAP_vkCreateImageView)>(*this, lib, "vkCreateImageView", SideEffects::worstDefault, "WRAP_vkCreateImageView")
  ->args({"device", "pCreateInfo", "pAllocator", "pView"});
addExtern<DAS_BIND_FUN(WRAP_vkCreateInstance)>(*this, lib, "vkCreateInstance", SideEffects::worstDefault, "WRAP_vkCreateInstance")
  ->args({"pCreateInfo", "pAllocator", "pInstance"});
addExtern<DAS_BIND_FUN(WRAP_vkCreatePipelineCache)>(*this, lib, "vkCreatePipelineCache", SideEffects::worstDefault, "WRAP_vkCreatePipelineCache")
  ->args({"device", "pCreateInfo", "pAllocator", "pPipelineCache"});
addExtern<DAS_BIND_FUN(WRAP_vkCreatePipelineLayout)>(*this, lib, "vkCreatePipelineLayout", SideEffects::worstDefault, "WRAP_vkCreatePipelineLayout")
  ->args({"device", "pCreateInfo", "pAllocator", "pPipelineLayout"});
addExtern<DAS_BIND_FUN(WRAP_vkCreateQueryPool)>(*this, lib, "vkCreateQueryPool", SideEffects::worstDefault, "WRAP_vkCreateQueryPool")
  ->args({"device", "pCreateInfo", "pAllocator", "pQueryPool"});
addExtern<DAS_BIND_FUN(WRAP_vkCreateRenderPass)>(*this, lib, "vkCreateRenderPass", SideEffects::worstDefault, "WRAP_vkCreateRenderPass")
  ->args({"device", "pCreateInfo", "pAllocator", "pRenderPass"});
addExtern<DAS_BIND_FUN(WRAP_vkCreateSampler)>(*this, lib, "vkCreateSampler", SideEffects::worstDefault, "WRAP_vkCreateSampler")
  ->args({"device", "pCreateInfo", "pAllocator", "pSampler"});
addExtern<DAS_BIND_FUN(WRAP_vkCreateSemaphore)>(*this, lib, "vkCreateSemaphore", SideEffects::worstDefault, "WRAP_vkCreateSemaphore")
  ->args({"device", "pCreateInfo", "pAllocator", "pSemaphore"});
addExtern<DAS_BIND_FUN(WRAP_vkCreateShaderModule)>(*this, lib, "vkCreateShaderModule", SideEffects::worstDefault, "WRAP_vkCreateShaderModule")
  ->args({"device", "pCreateInfo", "pAllocator", "pShaderModule"});
addExtern<DAS_BIND_FUN(WRAP_vkDestroyBuffer)>(*this, lib, "vkDestroyBuffer", SideEffects::worstDefault, "WRAP_vkDestroyBuffer")
  ->args({"device", "buffer", "pAllocator"});
addExtern<DAS_BIND_FUN(WRAP_vkDestroyBufferView)>(*this, lib, "vkDestroyBufferView", SideEffects::worstDefault, "WRAP_vkDestroyBufferView")
  ->args({"device", "bufferView", "pAllocator"});
addExtern<DAS_BIND_FUN(WRAP_vkDestroyCommandPool)>(*this, lib, "vkDestroyCommandPool", SideEffects::worstDefault, "WRAP_vkDestroyCommandPool")
  ->args({"device", "commandPool", "pAllocator"});
addExtern<DAS_BIND_FUN(WRAP_vkDestroyDescriptorPool)>(*this, lib, "vkDestroyDescriptorPool", SideEffects::worstDefault, "WRAP_vkDestroyDescriptorPool")
  ->args({"device", "descriptorPool", "pAllocator"});
addExtern<DAS_BIND_FUN(WRAP_vkDestroyDescriptorSetLayout)>(*this, lib, "vkDestroyDescriptorSetLayout", SideEffects::worstDefault, "WRAP_vkDestroyDescriptorSetLayout")
  ->args({"device", "descriptorSetLayout", "pAllocator"});
addExtern<DAS_BIND_FUN(WRAP_vkDestroyDevice)>(*this, lib, "vkDestroyDevice", SideEffects::worstDefault, "WRAP_vkDestroyDevice")
  ->args({"device", "pAllocator"});
addExtern<DAS_BIND_FUN(WRAP_vkDestroyEvent)>(*this, lib, "vkDestroyEvent", SideEffects::worstDefault, "WRAP_vkDestroyEvent")
  ->args({"device", "event", "pAllocator"});
addExtern<DAS_BIND_FUN(WRAP_vkDestroyFence)>(*this, lib, "vkDestroyFence", SideEffects::worstDefault, "WRAP_vkDestroyFence")
  ->args({"device", "fence", "pAllocator"});
addExtern<DAS_BIND_FUN(WRAP_vkDestroyFramebuffer)>(*this, lib, "vkDestroyFramebuffer", SideEffects::worstDefault, "WRAP_vkDestroyFramebuffer")
  ->args({"device", "framebuffer", "pAllocator"});
addExtern<DAS_BIND_FUN(WRAP_vkDestroyImage)>(*this, lib, "vkDestroyImage", SideEffects::worstDefault, "WRAP_vkDestroyImage")
  ->args({"device", "image", "pAllocator"});
addExtern<DAS_BIND_FUN(WRAP_vkDestroyImageView)>(*this, lib, "vkDestroyImageView", SideEffects::worstDefault, "WRAP_vkDestroyImageView")
  ->args({"device", "imageView", "pAllocator"});
addExtern<DAS_BIND_FUN(WRAP_vkDestroyInstance)>(*this, lib, "vkDestroyInstance", SideEffects::worstDefault, "WRAP_vkDestroyInstance")
  ->args({"instance", "pAllocator"});
addExtern<DAS_BIND_FUN(WRAP_vkDestroyPipeline)>(*this, lib, "vkDestroyPipeline", SideEffects::worstDefault, "WRAP_vkDestroyPipeline")
  ->args({"device", "pipeline", "pAllocator"});
addExtern<DAS_BIND_FUN(WRAP_vkDestroyPipelineCache)>(*this, lib, "vkDestroyPipelineCache", SideEffects::worstDefault, "WRAP_vkDestroyPipelineCache")
  ->args({"device", "pipelineCache", "pAllocator"});
addExtern<DAS_BIND_FUN(WRAP_vkDestroyPipelineLayout)>(*this, lib, "vkDestroyPipelineLayout", SideEffects::worstDefault, "WRAP_vkDestroyPipelineLayout")
  ->args({"device", "pipelineLayout", "pAllocator"});
addExtern<DAS_BIND_FUN(WRAP_vkDestroyQueryPool)>(*this, lib, "vkDestroyQueryPool", SideEffects::worstDefault, "WRAP_vkDestroyQueryPool")
  ->args({"device", "queryPool", "pAllocator"});
addExtern<DAS_BIND_FUN(WRAP_vkDestroyRenderPass)>(*this, lib, "vkDestroyRenderPass", SideEffects::worstDefault, "WRAP_vkDestroyRenderPass")
  ->args({"device", "renderPass", "pAllocator"});
addExtern<DAS_BIND_FUN(WRAP_vkDestroySampler)>(*this, lib, "vkDestroySampler", SideEffects::worstDefault, "WRAP_vkDestroySampler")
  ->args({"device", "sampler", "pAllocator"});
addExtern<DAS_BIND_FUN(WRAP_vkDestroySemaphore)>(*this, lib, "vkDestroySemaphore", SideEffects::worstDefault, "WRAP_vkDestroySemaphore")
  ->args({"device", "semaphore", "pAllocator"});
addExtern<DAS_BIND_FUN(WRAP_vkDestroyShaderModule)>(*this, lib, "vkDestroyShaderModule", SideEffects::worstDefault, "WRAP_vkDestroyShaderModule")
  ->args({"device", "shaderModule", "pAllocator"});
addExtern<DAS_BIND_FUN(WRAP_vkDeviceWaitIdle)>(*this, lib, "vkDeviceWaitIdle", SideEffects::worstDefault, "WRAP_vkDeviceWaitIdle")
  ->args({"device"});
addExtern<DAS_BIND_FUN(WRAP_vkEndCommandBuffer)>(*this, lib, "vkEndCommandBuffer", SideEffects::worstDefault, "WRAP_vkEndCommandBuffer")
  ->args({"commandBuffer"});
addExtern<DAS_BIND_FUN(WRAP_vkEnumerateDeviceExtensionProperties)>(*this, lib, "vkEnumerateDeviceExtensionProperties", SideEffects::worstDefault, "WRAP_vkEnumerateDeviceExtensionProperties")
  ->args({"physicalDevice", "pLayerName", "pPropertyCount", "pProperties"});
addExtern<DAS_BIND_FUN(WRAP_vkEnumerateDeviceLayerProperties)>(*this, lib, "vkEnumerateDeviceLayerProperties", SideEffects::worstDefault, "WRAP_vkEnumerateDeviceLayerProperties")
  ->args({"physicalDevice", "pPropertyCount", "pProperties"});
addExtern<DAS_BIND_FUN(WRAP_vkEnumerateInstanceExtensionProperties)>(*this, lib, "vkEnumerateInstanceExtensionProperties", SideEffects::worstDefault, "WRAP_vkEnumerateInstanceExtensionProperties")
  ->args({"pLayerName", "pPropertyCount", "pProperties"});
addExtern<DAS_BIND_FUN(WRAP_vkEnumerateInstanceLayerProperties)>(*this, lib, "vkEnumerateInstanceLayerProperties", SideEffects::worstDefault, "WRAP_vkEnumerateInstanceLayerProperties")
  ->args({"pPropertyCount", "pProperties"});
addExtern<DAS_BIND_FUN(WRAP_vkEnumeratePhysicalDevices)>(*this, lib, "vkEnumeratePhysicalDevices", SideEffects::worstDefault, "WRAP_vkEnumeratePhysicalDevices")
  ->args({"instance", "pPhysicalDeviceCount", "pPhysicalDevices"});
addExtern<DAS_BIND_FUN(WRAP_vkFlushMappedMemoryRanges)>(*this, lib, "vkFlushMappedMemoryRanges", SideEffects::worstDefault, "WRAP_vkFlushMappedMemoryRanges")
  ->args({"device", "memoryRangeCount", "pMemoryRanges"});
addExtern<DAS_BIND_FUN(WRAP_vkFreeCommandBuffers)>(*this, lib, "vkFreeCommandBuffers", SideEffects::worstDefault, "WRAP_vkFreeCommandBuffers")
  ->args({"device", "commandPool", "commandBufferCount", "pCommandBuffers"});
addExtern<DAS_BIND_FUN(WRAP_vkFreeDescriptorSets)>(*this, lib, "vkFreeDescriptorSets", SideEffects::worstDefault, "WRAP_vkFreeDescriptorSets")
  ->args({"device", "descriptorPool", "descriptorSetCount", "pDescriptorSets"});
addExtern<DAS_BIND_FUN(WRAP_vkFreeMemory)>(*this, lib, "vkFreeMemory", SideEffects::worstDefault, "WRAP_vkFreeMemory")
  ->args({"device", "memory", "pAllocator"});
addExtern<DAS_BIND_FUN(WRAP_vkGetBufferMemoryRequirements)>(*this, lib, "vkGetBufferMemoryRequirements", SideEffects::worstDefault, "WRAP_vkGetBufferMemoryRequirements")
  ->args({"device", "buffer", "pMemoryRequirements"});
addExtern<DAS_BIND_FUN(WRAP_vkGetDeviceMemoryCommitment)>(*this, lib, "vkGetDeviceMemoryCommitment", SideEffects::worstDefault, "WRAP_vkGetDeviceMemoryCommitment")
  ->args({"device", "memory", "pCommittedMemoryInBytes"});
addExtern<DAS_BIND_FUN(WRAP_vkGetDeviceProcAddr)>(*this, lib, "vkGetDeviceProcAddr", SideEffects::worstDefault, "WRAP_vkGetDeviceProcAddr")
  ->args({"device", "pName"});
addExtern<DAS_BIND_FUN(WRAP_vkGetDeviceQueue)>(*this, lib, "vkGetDeviceQueue", SideEffects::worstDefault, "WRAP_vkGetDeviceQueue")
  ->args({"device", "queueFamilyIndex", "queueIndex", "pQueue"});
addExtern<DAS_BIND_FUN(WRAP_vkGetEventStatus)>(*this, lib, "vkGetEventStatus", SideEffects::worstDefault, "WRAP_vkGetEventStatus")
  ->args({"device", "event"});
addExtern<DAS_BIND_FUN(WRAP_vkGetFenceStatus)>(*this, lib, "vkGetFenceStatus", SideEffects::worstDefault, "WRAP_vkGetFenceStatus")
  ->args({"device", "fence"});
addExtern<DAS_BIND_FUN(WRAP_vkGetImageMemoryRequirements)>(*this, lib, "vkGetImageMemoryRequirements", SideEffects::worstDefault, "WRAP_vkGetImageMemoryRequirements")
  ->args({"device", "image", "pMemoryRequirements"});
addExtern<DAS_BIND_FUN(WRAP_vkGetImageSparseMemoryRequirements)>(*this, lib, "vkGetImageSparseMemoryRequirements", SideEffects::worstDefault, "WRAP_vkGetImageSparseMemoryRequirements")
  ->args({"device", "image", "pSparseMemoryRequirementCount", "pSparseMemoryRequirements"});
addExtern<DAS_BIND_FUN(WRAP_vkGetImageSubresourceLayout)>(*this, lib, "vkGetImageSubresourceLayout", SideEffects::worstDefault, "WRAP_vkGetImageSubresourceLayout")
  ->args({"device", "image", "pSubresource", "pLayout"});
addExtern<DAS_BIND_FUN(WRAP_vkGetInstanceProcAddr)>(*this, lib, "vkGetInstanceProcAddr", SideEffects::worstDefault, "WRAP_vkGetInstanceProcAddr")
  ->args({"instance", "pName"});
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDeviceFeatures)>(*this, lib, "vkGetPhysicalDeviceFeatures", SideEffects::worstDefault, "WRAP_vkGetPhysicalDeviceFeatures")
  ->args({"physicalDevice", "pFeatures"});
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDeviceFormatProperties)>(*this, lib, "vkGetPhysicalDeviceFormatProperties", SideEffects::worstDefault, "WRAP_vkGetPhysicalDeviceFormatProperties")
  ->args({"physicalDevice", "format", "pFormatProperties"});
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDeviceImageFormatProperties)>(*this, lib, "vkGetPhysicalDeviceImageFormatProperties", SideEffects::worstDefault, "WRAP_vkGetPhysicalDeviceImageFormatProperties")
  ->args({"physicalDevice", "format", "type", "tiling", "usage", "flags", "pImageFormatProperties"});
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDeviceMemoryProperties)>(*this, lib, "vkGetPhysicalDeviceMemoryProperties", SideEffects::worstDefault, "WRAP_vkGetPhysicalDeviceMemoryProperties")
  ->args({"physicalDevice", "pMemoryProperties"});
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDeviceProperties)>(*this, lib, "vkGetPhysicalDeviceProperties", SideEffects::worstDefault, "WRAP_vkGetPhysicalDeviceProperties")
  ->args({"physicalDevice", "pProperties"});
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDeviceQueueFamilyProperties)>(*this, lib, "vkGetPhysicalDeviceQueueFamilyProperties", SideEffects::worstDefault, "WRAP_vkGetPhysicalDeviceQueueFamilyProperties")
  ->args({"physicalDevice", "pQueueFamilyPropertyCount", "pQueueFamilyProperties"});
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDeviceSparseImageFormatProperties)>(*this, lib, "vkGetPhysicalDeviceSparseImageFormatProperties", SideEffects::worstDefault, "WRAP_vkGetPhysicalDeviceSparseImageFormatProperties")
  ->args({"physicalDevice", "format", "type", "samples", "usage", "tiling", "pPropertyCount", "pProperties"});
addExtern<DAS_BIND_FUN(WRAP_vkGetPipelineCacheData)>(*this, lib, "vkGetPipelineCacheData", SideEffects::worstDefault, "WRAP_vkGetPipelineCacheData")
  ->args({"device", "pipelineCache", "pDataSize", "pData"});
addExtern<DAS_BIND_FUN(WRAP_vkGetQueryPoolResults)>(*this, lib, "vkGetQueryPoolResults", SideEffects::worstDefault, "WRAP_vkGetQueryPoolResults")
  ->args({"device", "queryPool", "firstQuery", "queryCount", "dataSize", "pData", "stride", "flags"});
addExtern<DAS_BIND_FUN(WRAP_vkGetRenderAreaGranularity)>(*this, lib, "vkGetRenderAreaGranularity", SideEffects::worstDefault, "WRAP_vkGetRenderAreaGranularity")
  ->args({"device", "renderPass", "pGranularity"});
addExtern<DAS_BIND_FUN(WRAP_vkInvalidateMappedMemoryRanges)>(*this, lib, "vkInvalidateMappedMemoryRanges", SideEffects::worstDefault, "WRAP_vkInvalidateMappedMemoryRanges")
  ->args({"device", "memoryRangeCount", "pMemoryRanges"});
addExtern<DAS_BIND_FUN(WRAP_vkMapMemory)>(*this, lib, "vkMapMemory", SideEffects::worstDefault, "WRAP_vkMapMemory")
  ->args({"device", "memory", "offset", "size", "flags", "ppData"});
addExtern<DAS_BIND_FUN(WRAP_vkMergePipelineCaches)>(*this, lib, "vkMergePipelineCaches", SideEffects::worstDefault, "WRAP_vkMergePipelineCaches")
  ->args({"device", "dstCache", "srcCacheCount", "pSrcCaches"});
addExtern<DAS_BIND_FUN(WRAP_vkQueueBindSparse)>(*this, lib, "vkQueueBindSparse", SideEffects::worstDefault, "WRAP_vkQueueBindSparse")
  ->args({"queue", "bindInfoCount", "pBindInfo", "fence"});
addExtern<DAS_BIND_FUN(WRAP_vkQueueSubmit)>(*this, lib, "vkQueueSubmit", SideEffects::worstDefault, "WRAP_vkQueueSubmit")
  ->args({"queue", "submitCount", "pSubmits", "fence"});
addExtern<DAS_BIND_FUN(WRAP_vkQueueWaitIdle)>(*this, lib, "vkQueueWaitIdle", SideEffects::worstDefault, "WRAP_vkQueueWaitIdle")
  ->args({"queue"});
addExtern<DAS_BIND_FUN(WRAP_vkResetCommandBuffer)>(*this, lib, "vkResetCommandBuffer", SideEffects::worstDefault, "WRAP_vkResetCommandBuffer")
  ->args({"commandBuffer", "flags"});
addExtern<DAS_BIND_FUN(WRAP_vkResetCommandPool)>(*this, lib, "vkResetCommandPool", SideEffects::worstDefault, "WRAP_vkResetCommandPool")
  ->args({"device", "commandPool", "flags"});
addExtern<DAS_BIND_FUN(WRAP_vkResetDescriptorPool)>(*this, lib, "vkResetDescriptorPool", SideEffects::worstDefault, "WRAP_vkResetDescriptorPool")
  ->args({"device", "descriptorPool", "flags"});
addExtern<DAS_BIND_FUN(WRAP_vkResetEvent)>(*this, lib, "vkResetEvent", SideEffects::worstDefault, "WRAP_vkResetEvent")
  ->args({"device", "event"});
addExtern<DAS_BIND_FUN(WRAP_vkResetFences)>(*this, lib, "vkResetFences", SideEffects::worstDefault, "WRAP_vkResetFences")
  ->args({"device", "fenceCount", "pFences"});
addExtern<DAS_BIND_FUN(WRAP_vkSetEvent)>(*this, lib, "vkSetEvent", SideEffects::worstDefault, "WRAP_vkSetEvent")
  ->args({"device", "event"});
addExtern<DAS_BIND_FUN(WRAP_vkUnmapMemory)>(*this, lib, "vkUnmapMemory", SideEffects::worstDefault, "WRAP_vkUnmapMemory")
  ->args({"device", "memory"});
addExtern<DAS_BIND_FUN(WRAP_vkUpdateDescriptorSets)>(*this, lib, "vkUpdateDescriptorSets", SideEffects::worstDefault, "WRAP_vkUpdateDescriptorSets")
  ->args({"device", "descriptorWriteCount", "pDescriptorWrites", "descriptorCopyCount", "pDescriptorCopies"});
addExtern<DAS_BIND_FUN(WRAP_vkWaitForFences)>(*this, lib, "vkWaitForFences", SideEffects::worstDefault, "WRAP_vkWaitForFences")
  ->args({"device", "fenceCount", "pFences", "waitAll", "timeout"});
#endif /* defined(VK_VERSION_1_0) */
#if defined(VK_VERSION_1_1)
addExtern<DAS_BIND_FUN(WRAP_vkBindBufferMemory2)>(*this, lib, "vkBindBufferMemory2", SideEffects::worstDefault, "WRAP_vkBindBufferMemory2")
  ->args({"device", "bindInfoCount", "pBindInfos"});
addExtern<DAS_BIND_FUN(WRAP_vkBindImageMemory2)>(*this, lib, "vkBindImageMemory2", SideEffects::worstDefault, "WRAP_vkBindImageMemory2")
  ->args({"device", "bindInfoCount", "pBindInfos"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdDispatchBase)>(*this, lib, "vkCmdDispatchBase", SideEffects::worstDefault, "WRAP_vkCmdDispatchBase")
  ->args({"commandBuffer", "baseGroupX", "baseGroupY", "baseGroupZ", "groupCountX", "groupCountY", "groupCountZ"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetDeviceMask)>(*this, lib, "vkCmdSetDeviceMask", SideEffects::worstDefault, "WRAP_vkCmdSetDeviceMask")
  ->args({"commandBuffer", "deviceMask"});
addExtern<DAS_BIND_FUN(WRAP_vkCreateDescriptorUpdateTemplate)>(*this, lib, "vkCreateDescriptorUpdateTemplate", SideEffects::worstDefault, "WRAP_vkCreateDescriptorUpdateTemplate")
  ->args({"device", "pCreateInfo", "pAllocator", "pDescriptorUpdateTemplate"});
addExtern<DAS_BIND_FUN(WRAP_vkCreateSamplerYcbcrConversion)>(*this, lib, "vkCreateSamplerYcbcrConversion", SideEffects::worstDefault, "WRAP_vkCreateSamplerYcbcrConversion")
  ->args({"device", "pCreateInfo", "pAllocator", "pYcbcrConversion"});
addExtern<DAS_BIND_FUN(WRAP_vkDestroyDescriptorUpdateTemplate)>(*this, lib, "vkDestroyDescriptorUpdateTemplate", SideEffects::worstDefault, "WRAP_vkDestroyDescriptorUpdateTemplate")
  ->args({"device", "descriptorUpdateTemplate", "pAllocator"});
addExtern<DAS_BIND_FUN(WRAP_vkDestroySamplerYcbcrConversion)>(*this, lib, "vkDestroySamplerYcbcrConversion", SideEffects::worstDefault, "WRAP_vkDestroySamplerYcbcrConversion")
  ->args({"device", "ycbcrConversion", "pAllocator"});
addExtern<DAS_BIND_FUN(WRAP_vkEnumerateInstanceVersion)>(*this, lib, "vkEnumerateInstanceVersion", SideEffects::worstDefault, "WRAP_vkEnumerateInstanceVersion")
  ->args({"pApiVersion"});
addExtern<DAS_BIND_FUN(WRAP_vkEnumeratePhysicalDeviceGroups)>(*this, lib, "vkEnumeratePhysicalDeviceGroups", SideEffects::worstDefault, "WRAP_vkEnumeratePhysicalDeviceGroups")
  ->args({"instance", "pPhysicalDeviceGroupCount", "pPhysicalDeviceGroupProperties"});
addExtern<DAS_BIND_FUN(WRAP_vkGetBufferMemoryRequirements2)>(*this, lib, "vkGetBufferMemoryRequirements2", SideEffects::worstDefault, "WRAP_vkGetBufferMemoryRequirements2")
  ->args({"device", "pInfo", "pMemoryRequirements"});
addExtern<DAS_BIND_FUN(WRAP_vkGetDescriptorSetLayoutSupport)>(*this, lib, "vkGetDescriptorSetLayoutSupport", SideEffects::worstDefault, "WRAP_vkGetDescriptorSetLayoutSupport")
  ->args({"device", "pCreateInfo", "pSupport"});
addExtern<DAS_BIND_FUN(WRAP_vkGetDeviceGroupPeerMemoryFeatures)>(*this, lib, "vkGetDeviceGroupPeerMemoryFeatures", SideEffects::worstDefault, "WRAP_vkGetDeviceGroupPeerMemoryFeatures")
  ->args({"device", "heapIndex", "localDeviceIndex", "remoteDeviceIndex", "pPeerMemoryFeatures"});
addExtern<DAS_BIND_FUN(WRAP_vkGetDeviceQueue2)>(*this, lib, "vkGetDeviceQueue2", SideEffects::worstDefault, "WRAP_vkGetDeviceQueue2")
  ->args({"device", "pQueueInfo", "pQueue"});
addExtern<DAS_BIND_FUN(WRAP_vkGetImageMemoryRequirements2)>(*this, lib, "vkGetImageMemoryRequirements2", SideEffects::worstDefault, "WRAP_vkGetImageMemoryRequirements2")
  ->args({"device", "pInfo", "pMemoryRequirements"});
addExtern<DAS_BIND_FUN(WRAP_vkGetImageSparseMemoryRequirements2)>(*this, lib, "vkGetImageSparseMemoryRequirements2", SideEffects::worstDefault, "WRAP_vkGetImageSparseMemoryRequirements2")
  ->args({"device", "pInfo", "pSparseMemoryRequirementCount", "pSparseMemoryRequirements"});
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDeviceExternalBufferProperties)>(*this, lib, "vkGetPhysicalDeviceExternalBufferProperties", SideEffects::worstDefault, "WRAP_vkGetPhysicalDeviceExternalBufferProperties")
  ->args({"physicalDevice", "pExternalBufferInfo", "pExternalBufferProperties"});
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDeviceExternalFenceProperties)>(*this, lib, "vkGetPhysicalDeviceExternalFenceProperties", SideEffects::worstDefault, "WRAP_vkGetPhysicalDeviceExternalFenceProperties")
  ->args({"physicalDevice", "pExternalFenceInfo", "pExternalFenceProperties"});
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDeviceExternalSemaphoreProperties)>(*this, lib, "vkGetPhysicalDeviceExternalSemaphoreProperties", SideEffects::worstDefault, "WRAP_vkGetPhysicalDeviceExternalSemaphoreProperties")
  ->args({"physicalDevice", "pExternalSemaphoreInfo", "pExternalSemaphoreProperties"});
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDeviceFeatures2)>(*this, lib, "vkGetPhysicalDeviceFeatures2", SideEffects::worstDefault, "WRAP_vkGetPhysicalDeviceFeatures2")
  ->args({"physicalDevice", "pFeatures"});
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDeviceFormatProperties2)>(*this, lib, "vkGetPhysicalDeviceFormatProperties2", SideEffects::worstDefault, "WRAP_vkGetPhysicalDeviceFormatProperties2")
  ->args({"physicalDevice", "format", "pFormatProperties"});
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDeviceImageFormatProperties2)>(*this, lib, "vkGetPhysicalDeviceImageFormatProperties2", SideEffects::worstDefault, "WRAP_vkGetPhysicalDeviceImageFormatProperties2")
  ->args({"physicalDevice", "pImageFormatInfo", "pImageFormatProperties"});
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDeviceMemoryProperties2)>(*this, lib, "vkGetPhysicalDeviceMemoryProperties2", SideEffects::worstDefault, "WRAP_vkGetPhysicalDeviceMemoryProperties2")
  ->args({"physicalDevice", "pMemoryProperties"});
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDeviceProperties2)>(*this, lib, "vkGetPhysicalDeviceProperties2", SideEffects::worstDefault, "WRAP_vkGetPhysicalDeviceProperties2")
  ->args({"physicalDevice", "pProperties"});
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDeviceQueueFamilyProperties2)>(*this, lib, "vkGetPhysicalDeviceQueueFamilyProperties2", SideEffects::worstDefault, "WRAP_vkGetPhysicalDeviceQueueFamilyProperties2")
  ->args({"physicalDevice", "pQueueFamilyPropertyCount", "pQueueFamilyProperties"});
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDeviceSparseImageFormatProperties2)>(*this, lib, "vkGetPhysicalDeviceSparseImageFormatProperties2", SideEffects::worstDefault, "WRAP_vkGetPhysicalDeviceSparseImageFormatProperties2")
  ->args({"physicalDevice", "pFormatInfo", "pPropertyCount", "pProperties"});
addExtern<DAS_BIND_FUN(WRAP_vkTrimCommandPool)>(*this, lib, "vkTrimCommandPool", SideEffects::worstDefault, "WRAP_vkTrimCommandPool")
  ->args({"device", "commandPool", "flags"});
addExtern<DAS_BIND_FUN(WRAP_vkUpdateDescriptorSetWithTemplate)>(*this, lib, "vkUpdateDescriptorSetWithTemplate", SideEffects::worstDefault, "WRAP_vkUpdateDescriptorSetWithTemplate")
  ->args({"device", "descriptorSet", "descriptorUpdateTemplate", "pData"});
#endif /* defined(VK_VERSION_1_1) */
#if defined(VK_VERSION_1_2)
addExtern<DAS_BIND_FUN(WRAP_vkCmdBeginRenderPass2)>(*this, lib, "vkCmdBeginRenderPass2", SideEffects::worstDefault, "WRAP_vkCmdBeginRenderPass2")
  ->args({"commandBuffer", "pRenderPassBegin", "pSubpassBeginInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdDrawIndexedIndirectCount)>(*this, lib, "vkCmdDrawIndexedIndirectCount", SideEffects::worstDefault, "WRAP_vkCmdDrawIndexedIndirectCount")
  ->args({"commandBuffer", "buffer", "offset", "countBuffer", "countBufferOffset", "maxDrawCount", "stride"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdDrawIndirectCount)>(*this, lib, "vkCmdDrawIndirectCount", SideEffects::worstDefault, "WRAP_vkCmdDrawIndirectCount")
  ->args({"commandBuffer", "buffer", "offset", "countBuffer", "countBufferOffset", "maxDrawCount", "stride"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdEndRenderPass2)>(*this, lib, "vkCmdEndRenderPass2", SideEffects::worstDefault, "WRAP_vkCmdEndRenderPass2")
  ->args({"commandBuffer", "pSubpassEndInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdNextSubpass2)>(*this, lib, "vkCmdNextSubpass2", SideEffects::worstDefault, "WRAP_vkCmdNextSubpass2")
  ->args({"commandBuffer", "pSubpassBeginInfo", "pSubpassEndInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCreateRenderPass2)>(*this, lib, "vkCreateRenderPass2", SideEffects::worstDefault, "WRAP_vkCreateRenderPass2")
  ->args({"device", "pCreateInfo", "pAllocator", "pRenderPass"});
addExtern<DAS_BIND_FUN(WRAP_vkGetBufferDeviceAddress)>(*this, lib, "vkGetBufferDeviceAddress", SideEffects::worstDefault, "WRAP_vkGetBufferDeviceAddress")
  ->args({"device", "pInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkGetBufferOpaqueCaptureAddress)>(*this, lib, "vkGetBufferOpaqueCaptureAddress", SideEffects::worstDefault, "WRAP_vkGetBufferOpaqueCaptureAddress")
  ->args({"device", "pInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkGetDeviceMemoryOpaqueCaptureAddress)>(*this, lib, "vkGetDeviceMemoryOpaqueCaptureAddress", SideEffects::worstDefault, "WRAP_vkGetDeviceMemoryOpaqueCaptureAddress")
  ->args({"device", "pInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkGetSemaphoreCounterValue)>(*this, lib, "vkGetSemaphoreCounterValue", SideEffects::worstDefault, "WRAP_vkGetSemaphoreCounterValue")
  ->args({"device", "semaphore", "pValue"});
addExtern<DAS_BIND_FUN(WRAP_vkResetQueryPool)>(*this, lib, "vkResetQueryPool", SideEffects::worstDefault, "WRAP_vkResetQueryPool")
  ->args({"device", "queryPool", "firstQuery", "queryCount"});
addExtern<DAS_BIND_FUN(WRAP_vkSignalSemaphore)>(*this, lib, "vkSignalSemaphore", SideEffects::worstDefault, "WRAP_vkSignalSemaphore")
  ->args({"device", "pSignalInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkWaitSemaphores)>(*this, lib, "vkWaitSemaphores", SideEffects::worstDefault, "WRAP_vkWaitSemaphores")
  ->args({"device", "pWaitInfo", "timeout"});
#endif /* defined(VK_VERSION_1_2) */
#if defined(VK_VERSION_1_3)
addExtern<DAS_BIND_FUN(WRAP_vkCmdBeginRendering)>(*this, lib, "vkCmdBeginRendering", SideEffects::worstDefault, "WRAP_vkCmdBeginRendering")
  ->args({"commandBuffer", "pRenderingInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdBindVertexBuffers2)>(*this, lib, "vkCmdBindVertexBuffers2", SideEffects::worstDefault, "WRAP_vkCmdBindVertexBuffers2")
  ->args({"commandBuffer", "firstBinding", "bindingCount", "pBuffers", "pOffsets", "pSizes", "pStrides"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdBlitImage2)>(*this, lib, "vkCmdBlitImage2", SideEffects::worstDefault, "WRAP_vkCmdBlitImage2")
  ->args({"commandBuffer", "pBlitImageInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdCopyBuffer2)>(*this, lib, "vkCmdCopyBuffer2", SideEffects::worstDefault, "WRAP_vkCmdCopyBuffer2")
  ->args({"commandBuffer", "pCopyBufferInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdCopyBufferToImage2)>(*this, lib, "vkCmdCopyBufferToImage2", SideEffects::worstDefault, "WRAP_vkCmdCopyBufferToImage2")
  ->args({"commandBuffer", "pCopyBufferToImageInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdCopyImage2)>(*this, lib, "vkCmdCopyImage2", SideEffects::worstDefault, "WRAP_vkCmdCopyImage2")
  ->args({"commandBuffer", "pCopyImageInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdCopyImageToBuffer2)>(*this, lib, "vkCmdCopyImageToBuffer2", SideEffects::worstDefault, "WRAP_vkCmdCopyImageToBuffer2")
  ->args({"commandBuffer", "pCopyImageToBufferInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdEndRendering)>(*this, lib, "vkCmdEndRendering", SideEffects::worstDefault, "WRAP_vkCmdEndRendering")
  ->args({"commandBuffer"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdPipelineBarrier2)>(*this, lib, "vkCmdPipelineBarrier2", SideEffects::worstDefault, "WRAP_vkCmdPipelineBarrier2")
  ->args({"commandBuffer", "pDependencyInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdResetEvent2)>(*this, lib, "vkCmdResetEvent2", SideEffects::worstDefault, "WRAP_vkCmdResetEvent2")
  ->args({"commandBuffer", "event", "stageMask"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdResolveImage2)>(*this, lib, "vkCmdResolveImage2", SideEffects::worstDefault, "WRAP_vkCmdResolveImage2")
  ->args({"commandBuffer", "pResolveImageInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetCullMode)>(*this, lib, "vkCmdSetCullMode", SideEffects::worstDefault, "WRAP_vkCmdSetCullMode")
  ->args({"commandBuffer", "cullMode"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetDepthBiasEnable)>(*this, lib, "vkCmdSetDepthBiasEnable", SideEffects::worstDefault, "WRAP_vkCmdSetDepthBiasEnable")
  ->args({"commandBuffer", "depthBiasEnable"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetDepthBoundsTestEnable)>(*this, lib, "vkCmdSetDepthBoundsTestEnable", SideEffects::worstDefault, "WRAP_vkCmdSetDepthBoundsTestEnable")
  ->args({"commandBuffer", "depthBoundsTestEnable"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetDepthCompareOp)>(*this, lib, "vkCmdSetDepthCompareOp", SideEffects::worstDefault, "WRAP_vkCmdSetDepthCompareOp")
  ->args({"commandBuffer", "depthCompareOp"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetDepthTestEnable)>(*this, lib, "vkCmdSetDepthTestEnable", SideEffects::worstDefault, "WRAP_vkCmdSetDepthTestEnable")
  ->args({"commandBuffer", "depthTestEnable"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetDepthWriteEnable)>(*this, lib, "vkCmdSetDepthWriteEnable", SideEffects::worstDefault, "WRAP_vkCmdSetDepthWriteEnable")
  ->args({"commandBuffer", "depthWriteEnable"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetEvent2)>(*this, lib, "vkCmdSetEvent2", SideEffects::worstDefault, "WRAP_vkCmdSetEvent2")
  ->args({"commandBuffer", "event", "pDependencyInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetFrontFace)>(*this, lib, "vkCmdSetFrontFace", SideEffects::worstDefault, "WRAP_vkCmdSetFrontFace")
  ->args({"commandBuffer", "frontFace"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetPrimitiveRestartEnable)>(*this, lib, "vkCmdSetPrimitiveRestartEnable", SideEffects::worstDefault, "WRAP_vkCmdSetPrimitiveRestartEnable")
  ->args({"commandBuffer", "primitiveRestartEnable"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetPrimitiveTopology)>(*this, lib, "vkCmdSetPrimitiveTopology", SideEffects::worstDefault, "WRAP_vkCmdSetPrimitiveTopology")
  ->args({"commandBuffer", "primitiveTopology"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetRasterizerDiscardEnable)>(*this, lib, "vkCmdSetRasterizerDiscardEnable", SideEffects::worstDefault, "WRAP_vkCmdSetRasterizerDiscardEnable")
  ->args({"commandBuffer", "rasterizerDiscardEnable"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetScissorWithCount)>(*this, lib, "vkCmdSetScissorWithCount", SideEffects::worstDefault, "WRAP_vkCmdSetScissorWithCount")
  ->args({"commandBuffer", "scissorCount", "pScissors"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetStencilOp)>(*this, lib, "vkCmdSetStencilOp", SideEffects::worstDefault, "WRAP_vkCmdSetStencilOp")
  ->args({"commandBuffer", "faceMask", "failOp", "passOp", "depthFailOp", "compareOp"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetStencilTestEnable)>(*this, lib, "vkCmdSetStencilTestEnable", SideEffects::worstDefault, "WRAP_vkCmdSetStencilTestEnable")
  ->args({"commandBuffer", "stencilTestEnable"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetViewportWithCount)>(*this, lib, "vkCmdSetViewportWithCount", SideEffects::worstDefault, "WRAP_vkCmdSetViewportWithCount")
  ->args({"commandBuffer", "viewportCount", "pViewports"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdWaitEvents2)>(*this, lib, "vkCmdWaitEvents2", SideEffects::worstDefault, "WRAP_vkCmdWaitEvents2")
  ->args({"commandBuffer", "eventCount", "pEvents", "pDependencyInfos"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdWriteTimestamp2)>(*this, lib, "vkCmdWriteTimestamp2", SideEffects::worstDefault, "WRAP_vkCmdWriteTimestamp2")
  ->args({"commandBuffer", "stage", "queryPool", "query"});
addExtern<DAS_BIND_FUN(WRAP_vkCreatePrivateDataSlot)>(*this, lib, "vkCreatePrivateDataSlot", SideEffects::worstDefault, "WRAP_vkCreatePrivateDataSlot")
  ->args({"device", "pCreateInfo", "pAllocator", "pPrivateDataSlot"});
addExtern<DAS_BIND_FUN(WRAP_vkDestroyPrivateDataSlot)>(*this, lib, "vkDestroyPrivateDataSlot", SideEffects::worstDefault, "WRAP_vkDestroyPrivateDataSlot")
  ->args({"device", "privateDataSlot", "pAllocator"});
addExtern<DAS_BIND_FUN(WRAP_vkGetDeviceBufferMemoryRequirements)>(*this, lib, "vkGetDeviceBufferMemoryRequirements", SideEffects::worstDefault, "WRAP_vkGetDeviceBufferMemoryRequirements")
  ->args({"device", "pInfo", "pMemoryRequirements"});
addExtern<DAS_BIND_FUN(WRAP_vkGetDeviceImageMemoryRequirements)>(*this, lib, "vkGetDeviceImageMemoryRequirements", SideEffects::worstDefault, "WRAP_vkGetDeviceImageMemoryRequirements")
  ->args({"device", "pInfo", "pMemoryRequirements"});
addExtern<DAS_BIND_FUN(WRAP_vkGetDeviceImageSparseMemoryRequirements)>(*this, lib, "vkGetDeviceImageSparseMemoryRequirements", SideEffects::worstDefault, "WRAP_vkGetDeviceImageSparseMemoryRequirements")
  ->args({"device", "pInfo", "pSparseMemoryRequirementCount", "pSparseMemoryRequirements"});
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDeviceToolProperties)>(*this, lib, "vkGetPhysicalDeviceToolProperties", SideEffects::worstDefault, "WRAP_vkGetPhysicalDeviceToolProperties")
  ->args({"physicalDevice", "pToolCount", "pToolProperties"});
addExtern<DAS_BIND_FUN(WRAP_vkGetPrivateData)>(*this, lib, "vkGetPrivateData", SideEffects::worstDefault, "WRAP_vkGetPrivateData")
  ->args({"device", "objectType", "objectHandle", "privateDataSlot", "pData"});
addExtern<DAS_BIND_FUN(WRAP_vkQueueSubmit2)>(*this, lib, "vkQueueSubmit2", SideEffects::worstDefault, "WRAP_vkQueueSubmit2")
  ->args({"queue", "submitCount", "pSubmits", "fence"});
addExtern<DAS_BIND_FUN(WRAP_vkSetPrivateData)>(*this, lib, "vkSetPrivateData", SideEffects::worstDefault, "WRAP_vkSetPrivateData")
  ->args({"device", "objectType", "objectHandle", "privateDataSlot", "data"});
#endif /* defined(VK_VERSION_1_3) */
#if defined(VK_VERSION_1_4)
addExtern<DAS_BIND_FUN(WRAP_vkCmdBindDescriptorSets2)>(*this, lib, "vkCmdBindDescriptorSets2", SideEffects::worstDefault, "WRAP_vkCmdBindDescriptorSets2")
  ->args({"commandBuffer", "pBindDescriptorSetsInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdBindIndexBuffer2)>(*this, lib, "vkCmdBindIndexBuffer2", SideEffects::worstDefault, "WRAP_vkCmdBindIndexBuffer2")
  ->args({"commandBuffer", "buffer", "offset", "size", "indexType"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdPushConstants2)>(*this, lib, "vkCmdPushConstants2", SideEffects::worstDefault, "WRAP_vkCmdPushConstants2")
  ->args({"commandBuffer", "pPushConstantsInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdPushDescriptorSet)>(*this, lib, "vkCmdPushDescriptorSet", SideEffects::worstDefault, "WRAP_vkCmdPushDescriptorSet")
  ->args({"commandBuffer", "pipelineBindPoint", "layout", "set", "descriptorWriteCount", "pDescriptorWrites"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdPushDescriptorSet2)>(*this, lib, "vkCmdPushDescriptorSet2", SideEffects::worstDefault, "WRAP_vkCmdPushDescriptorSet2")
  ->args({"commandBuffer", "pPushDescriptorSetInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdPushDescriptorSetWithTemplate)>(*this, lib, "vkCmdPushDescriptorSetWithTemplate", SideEffects::worstDefault, "WRAP_vkCmdPushDescriptorSetWithTemplate")
  ->args({"commandBuffer", "descriptorUpdateTemplate", "layout", "set", "pData"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdPushDescriptorSetWithTemplate2)>(*this, lib, "vkCmdPushDescriptorSetWithTemplate2", SideEffects::worstDefault, "WRAP_vkCmdPushDescriptorSetWithTemplate2")
  ->args({"commandBuffer", "pPushDescriptorSetWithTemplateInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetLineStipple)>(*this, lib, "vkCmdSetLineStipple", SideEffects::worstDefault, "WRAP_vkCmdSetLineStipple")
  ->args({"commandBuffer", "lineStippleFactor", "lineStipplePattern"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetRenderingAttachmentLocations)>(*this, lib, "vkCmdSetRenderingAttachmentLocations", SideEffects::worstDefault, "WRAP_vkCmdSetRenderingAttachmentLocations")
  ->args({"commandBuffer", "pLocationInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetRenderingInputAttachmentIndices)>(*this, lib, "vkCmdSetRenderingInputAttachmentIndices", SideEffects::worstDefault, "WRAP_vkCmdSetRenderingInputAttachmentIndices")
  ->args({"commandBuffer", "pInputAttachmentIndexInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCopyImageToImage)>(*this, lib, "vkCopyImageToImage", SideEffects::worstDefault, "WRAP_vkCopyImageToImage")
  ->args({"device", "pCopyImageToImageInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCopyImageToMemory)>(*this, lib, "vkCopyImageToMemory", SideEffects::worstDefault, "WRAP_vkCopyImageToMemory")
  ->args({"device", "pCopyImageToMemoryInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCopyMemoryToImage)>(*this, lib, "vkCopyMemoryToImage", SideEffects::worstDefault, "WRAP_vkCopyMemoryToImage")
  ->args({"device", "pCopyMemoryToImageInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkGetDeviceImageSubresourceLayout)>(*this, lib, "vkGetDeviceImageSubresourceLayout", SideEffects::worstDefault, "WRAP_vkGetDeviceImageSubresourceLayout")
  ->args({"device", "pInfo", "pLayout"});
addExtern<DAS_BIND_FUN(WRAP_vkGetImageSubresourceLayout2)>(*this, lib, "vkGetImageSubresourceLayout2", SideEffects::worstDefault, "WRAP_vkGetImageSubresourceLayout2")
  ->args({"device", "image", "pSubresource", "pLayout"});
addExtern<DAS_BIND_FUN(WRAP_vkGetRenderingAreaGranularity)>(*this, lib, "vkGetRenderingAreaGranularity", SideEffects::worstDefault, "WRAP_vkGetRenderingAreaGranularity")
  ->args({"device", "pRenderingAreaInfo", "pGranularity"});
addExtern<DAS_BIND_FUN(WRAP_vkMapMemory2)>(*this, lib, "vkMapMemory2", SideEffects::worstDefault, "WRAP_vkMapMemory2")
  ->args({"device", "pMemoryMapInfo", "ppData"});
addExtern<DAS_BIND_FUN(WRAP_vkTransitionImageLayout)>(*this, lib, "vkTransitionImageLayout", SideEffects::worstDefault, "WRAP_vkTransitionImageLayout")
  ->args({"device", "transitionCount", "pTransitions"});
addExtern<DAS_BIND_FUN(WRAP_vkUnmapMemory2)>(*this, lib, "vkUnmapMemory2", SideEffects::worstDefault, "WRAP_vkUnmapMemory2")
  ->args({"device", "pMemoryUnmapInfo"});
#endif /* defined(VK_VERSION_1_4) */
#if defined(VK_AMDX_shader_enqueue)
addExtern<DAS_BIND_FUN(WRAP_vkCmdDispatchGraphAMDX)>(*this, lib, "vkCmdDispatchGraphAMDX", SideEffects::worstDefault, "WRAP_vkCmdDispatchGraphAMDX")
  ->args({"commandBuffer", "scratch", "scratchSize", "pCountInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdDispatchGraphIndirectAMDX)>(*this, lib, "vkCmdDispatchGraphIndirectAMDX", SideEffects::worstDefault, "WRAP_vkCmdDispatchGraphIndirectAMDX")
  ->args({"commandBuffer", "scratch", "scratchSize", "pCountInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdDispatchGraphIndirectCountAMDX)>(*this, lib, "vkCmdDispatchGraphIndirectCountAMDX", SideEffects::worstDefault, "WRAP_vkCmdDispatchGraphIndirectCountAMDX")
  ->args({"commandBuffer", "scratch", "scratchSize", "countInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdInitializeGraphScratchMemoryAMDX)>(*this, lib, "vkCmdInitializeGraphScratchMemoryAMDX", SideEffects::worstDefault, "WRAP_vkCmdInitializeGraphScratchMemoryAMDX")
  ->args({"commandBuffer", "executionGraph", "scratch", "scratchSize"});
addExtern<DAS_BIND_FUN(WRAP_vkCreateExecutionGraphPipelinesAMDX)>(*this, lib, "vkCreateExecutionGraphPipelinesAMDX", SideEffects::worstDefault, "WRAP_vkCreateExecutionGraphPipelinesAMDX")
  ->args({"device", "pipelineCache", "createInfoCount", "pCreateInfos", "pAllocator", "pPipelines"});
addExtern<DAS_BIND_FUN(WRAP_vkGetExecutionGraphPipelineNodeIndexAMDX)>(*this, lib, "vkGetExecutionGraphPipelineNodeIndexAMDX", SideEffects::worstDefault, "WRAP_vkGetExecutionGraphPipelineNodeIndexAMDX")
  ->args({"device", "executionGraph", "pNodeInfo", "pNodeIndex"});
addExtern<DAS_BIND_FUN(WRAP_vkGetExecutionGraphPipelineScratchSizeAMDX)>(*this, lib, "vkGetExecutionGraphPipelineScratchSizeAMDX", SideEffects::worstDefault, "WRAP_vkGetExecutionGraphPipelineScratchSizeAMDX")
  ->args({"device", "executionGraph", "pSizeInfo"});
#endif /* defined(VK_AMDX_shader_enqueue) */
#if defined(VK_AMD_anti_lag)
addExtern<DAS_BIND_FUN(WRAP_vkAntiLagUpdateAMD)>(*this, lib, "vkAntiLagUpdateAMD", SideEffects::worstDefault, "WRAP_vkAntiLagUpdateAMD")
  ->args({"device", "pData"});
#endif /* defined(VK_AMD_anti_lag) */
#if defined(VK_AMD_buffer_marker)
addExtern<DAS_BIND_FUN(WRAP_vkCmdWriteBufferMarkerAMD)>(*this, lib, "vkCmdWriteBufferMarkerAMD", SideEffects::worstDefault, "WRAP_vkCmdWriteBufferMarkerAMD")
  ->args({"commandBuffer", "pipelineStage", "dstBuffer", "dstOffset", "marker"});
#endif /* defined(VK_AMD_buffer_marker) */
#if defined(VK_AMD_buffer_marker) && (defined(VK_VERSION_1_3) || defined(VK_KHR_synchronization2))
addExtern<DAS_BIND_FUN(WRAP_vkCmdWriteBufferMarker2AMD)>(*this, lib, "vkCmdWriteBufferMarker2AMD", SideEffects::worstDefault, "WRAP_vkCmdWriteBufferMarker2AMD")
  ->args({"commandBuffer", "stage", "dstBuffer", "dstOffset", "marker"});
#endif /* defined(VK_AMD_buffer_marker) && (defined(VK_VERSION_1_3) || defined(VK_KHR_synchronization2)) */
#if defined(VK_AMD_display_native_hdr)
addExtern<DAS_BIND_FUN(WRAP_vkSetLocalDimmingAMD)>(*this, lib, "vkSetLocalDimmingAMD", SideEffects::worstDefault, "WRAP_vkSetLocalDimmingAMD")
  ->args({"device", "swapChain", "localDimmingEnable"});
#endif /* defined(VK_AMD_display_native_hdr) */
#if defined(VK_AMD_draw_indirect_count)
addExtern<DAS_BIND_FUN(WRAP_vkCmdDrawIndexedIndirectCountAMD)>(*this, lib, "vkCmdDrawIndexedIndirectCountAMD", SideEffects::worstDefault, "WRAP_vkCmdDrawIndexedIndirectCountAMD")
  ->args({"commandBuffer", "buffer", "offset", "countBuffer", "countBufferOffset", "maxDrawCount", "stride"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdDrawIndirectCountAMD)>(*this, lib, "vkCmdDrawIndirectCountAMD", SideEffects::worstDefault, "WRAP_vkCmdDrawIndirectCountAMD")
  ->args({"commandBuffer", "buffer", "offset", "countBuffer", "countBufferOffset", "maxDrawCount", "stride"});
#endif /* defined(VK_AMD_draw_indirect_count) */
#if defined(VK_AMD_shader_info)
addExtern<DAS_BIND_FUN(WRAP_vkGetShaderInfoAMD)>(*this, lib, "vkGetShaderInfoAMD", SideEffects::worstDefault, "WRAP_vkGetShaderInfoAMD")
  ->args({"device", "pipeline", "shaderStage", "infoType", "pInfoSize", "pInfo"});
#endif /* defined(VK_AMD_shader_info) */
#if defined(VK_ANDROID_external_memory_android_hardware_buffer)
addExtern<DAS_BIND_FUN(WRAP_vkGetAndroidHardwareBufferPropertiesANDROID)>(*this, lib, "vkGetAndroidHardwareBufferPropertiesANDROID", SideEffects::worstDefault, "WRAP_vkGetAndroidHardwareBufferPropertiesANDROID")
  ->args({"device", "buffer", "pProperties"});
addExtern<DAS_BIND_FUN(WRAP_vkGetMemoryAndroidHardwareBufferANDROID)>(*this, lib, "vkGetMemoryAndroidHardwareBufferANDROID", SideEffects::worstDefault, "WRAP_vkGetMemoryAndroidHardwareBufferANDROID")
  ->args({"device", "pInfo", "pBuffer"});
#endif /* defined(VK_ANDROID_external_memory_android_hardware_buffer) */
#if defined(VK_EXT_acquire_drm_display)
addExtern<DAS_BIND_FUN(WRAP_vkAcquireDrmDisplayEXT)>(*this, lib, "vkAcquireDrmDisplayEXT", SideEffects::worstDefault, "WRAP_vkAcquireDrmDisplayEXT")
  ->args({"physicalDevice", "drmFd", "display"});
addExtern<DAS_BIND_FUN(WRAP_vkGetDrmDisplayEXT)>(*this, lib, "vkGetDrmDisplayEXT", SideEffects::worstDefault, "WRAP_vkGetDrmDisplayEXT")
  ->args({"physicalDevice", "drmFd", "connectorId", "display"});
#endif /* defined(VK_EXT_acquire_drm_display) */
#if defined(VK_EXT_acquire_xlib_display)
addExtern<DAS_BIND_FUN(WRAP_vkAcquireXlibDisplayEXT)>(*this, lib, "vkAcquireXlibDisplayEXT", SideEffects::worstDefault, "WRAP_vkAcquireXlibDisplayEXT")
  ->args({"physicalDevice", "dpy", "display"});
addExtern<DAS_BIND_FUN(WRAP_vkGetRandROutputDisplayEXT)>(*this, lib, "vkGetRandROutputDisplayEXT", SideEffects::worstDefault, "WRAP_vkGetRandROutputDisplayEXT")
  ->args({"physicalDevice", "dpy", "rrOutput", "pDisplay"});
#endif /* defined(VK_EXT_acquire_xlib_display) */
#if defined(VK_EXT_attachment_feedback_loop_dynamic_state)
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetAttachmentFeedbackLoopEnableEXT)>(*this, lib, "vkCmdSetAttachmentFeedbackLoopEnableEXT", SideEffects::worstDefault, "WRAP_vkCmdSetAttachmentFeedbackLoopEnableEXT")
  ->args({"commandBuffer", "aspectMask"});
#endif /* defined(VK_EXT_attachment_feedback_loop_dynamic_state) */
#if defined(VK_EXT_buffer_device_address)
addExtern<DAS_BIND_FUN(WRAP_vkGetBufferDeviceAddressEXT)>(*this, lib, "vkGetBufferDeviceAddressEXT", SideEffects::worstDefault, "WRAP_vkGetBufferDeviceAddressEXT")
  ->args({"device", "pInfo"});
#endif /* defined(VK_EXT_buffer_device_address) */
#if defined(VK_EXT_calibrated_timestamps)
addExtern<DAS_BIND_FUN(WRAP_vkGetCalibratedTimestampsEXT)>(*this, lib, "vkGetCalibratedTimestampsEXT", SideEffects::worstDefault, "WRAP_vkGetCalibratedTimestampsEXT")
  ->args({"device", "timestampCount", "pTimestampInfos", "pTimestamps", "pMaxDeviation"});
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT)>(*this, lib, "vkGetPhysicalDeviceCalibrateableTimeDomainsEXT", SideEffects::worstDefault, "WRAP_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT")
  ->args({"physicalDevice", "pTimeDomainCount", "pTimeDomains"});
#endif /* defined(VK_EXT_calibrated_timestamps) */
#if defined(VK_EXT_color_write_enable)
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetColorWriteEnableEXT)>(*this, lib, "vkCmdSetColorWriteEnableEXT", SideEffects::worstDefault, "WRAP_vkCmdSetColorWriteEnableEXT")
  ->args({"commandBuffer", "attachmentCount", "pColorWriteEnables"});
#endif /* defined(VK_EXT_color_write_enable) */
#if defined(VK_EXT_conditional_rendering)
addExtern<DAS_BIND_FUN(WRAP_vkCmdBeginConditionalRenderingEXT)>(*this, lib, "vkCmdBeginConditionalRenderingEXT", SideEffects::worstDefault, "WRAP_vkCmdBeginConditionalRenderingEXT")
  ->args({"commandBuffer", "pConditionalRenderingBegin"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdEndConditionalRenderingEXT)>(*this, lib, "vkCmdEndConditionalRenderingEXT", SideEffects::worstDefault, "WRAP_vkCmdEndConditionalRenderingEXT")
  ->args({"commandBuffer"});
#endif /* defined(VK_EXT_conditional_rendering) */
#if defined(VK_EXT_debug_marker)
addExtern<DAS_BIND_FUN(WRAP_vkCmdDebugMarkerBeginEXT)>(*this, lib, "vkCmdDebugMarkerBeginEXT", SideEffects::worstDefault, "WRAP_vkCmdDebugMarkerBeginEXT")
  ->args({"commandBuffer", "pMarkerInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdDebugMarkerEndEXT)>(*this, lib, "vkCmdDebugMarkerEndEXT", SideEffects::worstDefault, "WRAP_vkCmdDebugMarkerEndEXT")
  ->args({"commandBuffer"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdDebugMarkerInsertEXT)>(*this, lib, "vkCmdDebugMarkerInsertEXT", SideEffects::worstDefault, "WRAP_vkCmdDebugMarkerInsertEXT")
  ->args({"commandBuffer", "pMarkerInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkDebugMarkerSetObjectNameEXT)>(*this, lib, "vkDebugMarkerSetObjectNameEXT", SideEffects::worstDefault, "WRAP_vkDebugMarkerSetObjectNameEXT")
  ->args({"device", "pNameInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkDebugMarkerSetObjectTagEXT)>(*this, lib, "vkDebugMarkerSetObjectTagEXT", SideEffects::worstDefault, "WRAP_vkDebugMarkerSetObjectTagEXT")
  ->args({"device", "pTagInfo"});
#endif /* defined(VK_EXT_debug_marker) */
#if defined(VK_EXT_debug_report)
addExtern<DAS_BIND_FUN(WRAP_vkCreateDebugReportCallbackEXT)>(*this, lib, "vkCreateDebugReportCallbackEXT", SideEffects::worstDefault, "WRAP_vkCreateDebugReportCallbackEXT")
  ->args({"instance", "pCreateInfo", "pAllocator", "pCallback"});
addExtern<DAS_BIND_FUN(WRAP_vkDebugReportMessageEXT)>(*this, lib, "vkDebugReportMessageEXT", SideEffects::worstDefault, "WRAP_vkDebugReportMessageEXT")
  ->args({"instance", "flags", "objectType", "object", "location", "messageCode", "pLayerPrefix", "pMessage"});
addExtern<DAS_BIND_FUN(WRAP_vkDestroyDebugReportCallbackEXT)>(*this, lib, "vkDestroyDebugReportCallbackEXT", SideEffects::worstDefault, "WRAP_vkDestroyDebugReportCallbackEXT")
  ->args({"instance", "callback", "pAllocator"});
#endif /* defined(VK_EXT_debug_report) */
#if defined(VK_EXT_debug_utils)
addExtern<DAS_BIND_FUN(WRAP_vkCmdBeginDebugUtilsLabelEXT)>(*this, lib, "vkCmdBeginDebugUtilsLabelEXT", SideEffects::worstDefault, "WRAP_vkCmdBeginDebugUtilsLabelEXT")
  ->args({"commandBuffer", "pLabelInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdEndDebugUtilsLabelEXT)>(*this, lib, "vkCmdEndDebugUtilsLabelEXT", SideEffects::worstDefault, "WRAP_vkCmdEndDebugUtilsLabelEXT")
  ->args({"commandBuffer"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdInsertDebugUtilsLabelEXT)>(*this, lib, "vkCmdInsertDebugUtilsLabelEXT", SideEffects::worstDefault, "WRAP_vkCmdInsertDebugUtilsLabelEXT")
  ->args({"commandBuffer", "pLabelInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCreateDebugUtilsMessengerEXT)>(*this, lib, "vkCreateDebugUtilsMessengerEXT", SideEffects::worstDefault, "WRAP_vkCreateDebugUtilsMessengerEXT")
  ->args({"instance", "pCreateInfo", "pAllocator", "pMessenger"});
addExtern<DAS_BIND_FUN(WRAP_vkDestroyDebugUtilsMessengerEXT)>(*this, lib, "vkDestroyDebugUtilsMessengerEXT", SideEffects::worstDefault, "WRAP_vkDestroyDebugUtilsMessengerEXT")
  ->args({"instance", "messenger", "pAllocator"});
addExtern<DAS_BIND_FUN(WRAP_vkQueueBeginDebugUtilsLabelEXT)>(*this, lib, "vkQueueBeginDebugUtilsLabelEXT", SideEffects::worstDefault, "WRAP_vkQueueBeginDebugUtilsLabelEXT")
  ->args({"queue", "pLabelInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkQueueEndDebugUtilsLabelEXT)>(*this, lib, "vkQueueEndDebugUtilsLabelEXT", SideEffects::worstDefault, "WRAP_vkQueueEndDebugUtilsLabelEXT")
  ->args({"queue"});
addExtern<DAS_BIND_FUN(WRAP_vkQueueInsertDebugUtilsLabelEXT)>(*this, lib, "vkQueueInsertDebugUtilsLabelEXT", SideEffects::worstDefault, "WRAP_vkQueueInsertDebugUtilsLabelEXT")
  ->args({"queue", "pLabelInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkSetDebugUtilsObjectNameEXT)>(*this, lib, "vkSetDebugUtilsObjectNameEXT", SideEffects::worstDefault, "WRAP_vkSetDebugUtilsObjectNameEXT")
  ->args({"device", "pNameInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkSetDebugUtilsObjectTagEXT)>(*this, lib, "vkSetDebugUtilsObjectTagEXT", SideEffects::worstDefault, "WRAP_vkSetDebugUtilsObjectTagEXT")
  ->args({"device", "pTagInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkSubmitDebugUtilsMessageEXT)>(*this, lib, "vkSubmitDebugUtilsMessageEXT", SideEffects::worstDefault, "WRAP_vkSubmitDebugUtilsMessageEXT")
  ->args({"instance", "messageSeverity", "messageTypes", "pCallbackData"});
#endif /* defined(VK_EXT_debug_utils) */
#if defined(VK_EXT_depth_bias_control)
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetDepthBias2EXT)>(*this, lib, "vkCmdSetDepthBias2EXT", SideEffects::worstDefault, "WRAP_vkCmdSetDepthBias2EXT")
  ->args({"commandBuffer", "pDepthBiasInfo"});
#endif /* defined(VK_EXT_depth_bias_control) */
#if defined(VK_EXT_descriptor_buffer)
addExtern<DAS_BIND_FUN(WRAP_vkCmdBindDescriptorBufferEmbeddedSamplersEXT)>(*this, lib, "vkCmdBindDescriptorBufferEmbeddedSamplersEXT", SideEffects::worstDefault, "WRAP_vkCmdBindDescriptorBufferEmbeddedSamplersEXT")
  ->args({"commandBuffer", "pipelineBindPoint", "layout", "set"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdBindDescriptorBuffersEXT)>(*this, lib, "vkCmdBindDescriptorBuffersEXT", SideEffects::worstDefault, "WRAP_vkCmdBindDescriptorBuffersEXT")
  ->args({"commandBuffer", "bufferCount", "pBindingInfos"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetDescriptorBufferOffsetsEXT)>(*this, lib, "vkCmdSetDescriptorBufferOffsetsEXT", SideEffects::worstDefault, "WRAP_vkCmdSetDescriptorBufferOffsetsEXT")
  ->args({"commandBuffer", "pipelineBindPoint", "layout", "firstSet", "setCount", "pBufferIndices", "pOffsets"});
addExtern<DAS_BIND_FUN(WRAP_vkGetBufferOpaqueCaptureDescriptorDataEXT)>(*this, lib, "vkGetBufferOpaqueCaptureDescriptorDataEXT", SideEffects::worstDefault, "WRAP_vkGetBufferOpaqueCaptureDescriptorDataEXT")
  ->args({"device", "pInfo", "pData"});
addExtern<DAS_BIND_FUN(WRAP_vkGetDescriptorEXT)>(*this, lib, "vkGetDescriptorEXT", SideEffects::worstDefault, "WRAP_vkGetDescriptorEXT")
  ->args({"device", "pDescriptorInfo", "dataSize", "pDescriptor"});
addExtern<DAS_BIND_FUN(WRAP_vkGetDescriptorSetLayoutBindingOffsetEXT)>(*this, lib, "vkGetDescriptorSetLayoutBindingOffsetEXT", SideEffects::worstDefault, "WRAP_vkGetDescriptorSetLayoutBindingOffsetEXT")
  ->args({"device", "layout", "binding", "pOffset"});
addExtern<DAS_BIND_FUN(WRAP_vkGetDescriptorSetLayoutSizeEXT)>(*this, lib, "vkGetDescriptorSetLayoutSizeEXT", SideEffects::worstDefault, "WRAP_vkGetDescriptorSetLayoutSizeEXT")
  ->args({"device", "layout", "pLayoutSizeInBytes"});
addExtern<DAS_BIND_FUN(WRAP_vkGetImageOpaqueCaptureDescriptorDataEXT)>(*this, lib, "vkGetImageOpaqueCaptureDescriptorDataEXT", SideEffects::worstDefault, "WRAP_vkGetImageOpaqueCaptureDescriptorDataEXT")
  ->args({"device", "pInfo", "pData"});
addExtern<DAS_BIND_FUN(WRAP_vkGetImageViewOpaqueCaptureDescriptorDataEXT)>(*this, lib, "vkGetImageViewOpaqueCaptureDescriptorDataEXT", SideEffects::worstDefault, "WRAP_vkGetImageViewOpaqueCaptureDescriptorDataEXT")
  ->args({"device", "pInfo", "pData"});
addExtern<DAS_BIND_FUN(WRAP_vkGetSamplerOpaqueCaptureDescriptorDataEXT)>(*this, lib, "vkGetSamplerOpaqueCaptureDescriptorDataEXT", SideEffects::worstDefault, "WRAP_vkGetSamplerOpaqueCaptureDescriptorDataEXT")
  ->args({"device", "pInfo", "pData"});
#endif /* defined(VK_EXT_descriptor_buffer) */
#if defined(VK_EXT_descriptor_buffer) && (defined(VK_KHR_acceleration_structure) || defined(VK_NV_ray_tracing))
addExtern<DAS_BIND_FUN(WRAP_vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT)>(*this, lib, "vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT", SideEffects::worstDefault, "WRAP_vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT")
  ->args({"device", "pInfo", "pData"});
#endif /* defined(VK_EXT_descriptor_buffer) && (defined(VK_KHR_acceleration_structure) || defined(VK_NV_ray_tracing)) */
#if defined(VK_EXT_device_fault)
addExtern<DAS_BIND_FUN(WRAP_vkGetDeviceFaultInfoEXT)>(*this, lib, "vkGetDeviceFaultInfoEXT", SideEffects::worstDefault, "WRAP_vkGetDeviceFaultInfoEXT")
  ->args({"device", "pFaultCounts", "pFaultInfo"});
#endif /* defined(VK_EXT_device_fault) */
#if defined(VK_EXT_device_generated_commands)
addExtern<DAS_BIND_FUN(WRAP_vkCmdExecuteGeneratedCommandsEXT)>(*this, lib, "vkCmdExecuteGeneratedCommandsEXT", SideEffects::worstDefault, "WRAP_vkCmdExecuteGeneratedCommandsEXT")
  ->args({"commandBuffer", "isPreprocessed", "pGeneratedCommandsInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdPreprocessGeneratedCommandsEXT)>(*this, lib, "vkCmdPreprocessGeneratedCommandsEXT", SideEffects::worstDefault, "WRAP_vkCmdPreprocessGeneratedCommandsEXT")
  ->args({"commandBuffer", "pGeneratedCommandsInfo", "stateCommandBuffer"});
addExtern<DAS_BIND_FUN(WRAP_vkCreateIndirectCommandsLayoutEXT)>(*this, lib, "vkCreateIndirectCommandsLayoutEXT", SideEffects::worstDefault, "WRAP_vkCreateIndirectCommandsLayoutEXT")
  ->args({"device", "pCreateInfo", "pAllocator", "pIndirectCommandsLayout"});
addExtern<DAS_BIND_FUN(WRAP_vkCreateIndirectExecutionSetEXT)>(*this, lib, "vkCreateIndirectExecutionSetEXT", SideEffects::worstDefault, "WRAP_vkCreateIndirectExecutionSetEXT")
  ->args({"device", "pCreateInfo", "pAllocator", "pIndirectExecutionSet"});
addExtern<DAS_BIND_FUN(WRAP_vkDestroyIndirectCommandsLayoutEXT)>(*this, lib, "vkDestroyIndirectCommandsLayoutEXT", SideEffects::worstDefault, "WRAP_vkDestroyIndirectCommandsLayoutEXT")
  ->args({"device", "indirectCommandsLayout", "pAllocator"});
addExtern<DAS_BIND_FUN(WRAP_vkDestroyIndirectExecutionSetEXT)>(*this, lib, "vkDestroyIndirectExecutionSetEXT", SideEffects::worstDefault, "WRAP_vkDestroyIndirectExecutionSetEXT")
  ->args({"device", "indirectExecutionSet", "pAllocator"});
addExtern<DAS_BIND_FUN(WRAP_vkGetGeneratedCommandsMemoryRequirementsEXT)>(*this, lib, "vkGetGeneratedCommandsMemoryRequirementsEXT", SideEffects::worstDefault, "WRAP_vkGetGeneratedCommandsMemoryRequirementsEXT")
  ->args({"device", "pInfo", "pMemoryRequirements"});
addExtern<DAS_BIND_FUN(WRAP_vkUpdateIndirectExecutionSetPipelineEXT)>(*this, lib, "vkUpdateIndirectExecutionSetPipelineEXT", SideEffects::worstDefault, "WRAP_vkUpdateIndirectExecutionSetPipelineEXT")
  ->args({"device", "indirectExecutionSet", "executionSetWriteCount", "pExecutionSetWrites"});
addExtern<DAS_BIND_FUN(WRAP_vkUpdateIndirectExecutionSetShaderEXT)>(*this, lib, "vkUpdateIndirectExecutionSetShaderEXT", SideEffects::worstDefault, "WRAP_vkUpdateIndirectExecutionSetShaderEXT")
  ->args({"device", "indirectExecutionSet", "executionSetWriteCount", "pExecutionSetWrites"});
#endif /* defined(VK_EXT_device_generated_commands) */
#if defined(VK_EXT_direct_mode_display)
addExtern<DAS_BIND_FUN(WRAP_vkReleaseDisplayEXT)>(*this, lib, "vkReleaseDisplayEXT", SideEffects::worstDefault, "WRAP_vkReleaseDisplayEXT")
  ->args({"physicalDevice", "display"});
#endif /* defined(VK_EXT_direct_mode_display) */
#if defined(VK_EXT_directfb_surface)
addExtern<DAS_BIND_FUN(WRAP_vkCreateDirectFBSurfaceEXT)>(*this, lib, "vkCreateDirectFBSurfaceEXT", SideEffects::worstDefault, "WRAP_vkCreateDirectFBSurfaceEXT")
  ->args({"instance", "pCreateInfo", "pAllocator", "pSurface"});
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDeviceDirectFBPresentationSupportEXT)>(*this, lib, "vkGetPhysicalDeviceDirectFBPresentationSupportEXT", SideEffects::worstDefault, "WRAP_vkGetPhysicalDeviceDirectFBPresentationSupportEXT")
  ->args({"physicalDevice", "queueFamilyIndex", "dfb"});
#endif /* defined(VK_EXT_directfb_surface) */
#if defined(VK_EXT_discard_rectangles)
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetDiscardRectangleEXT)>(*this, lib, "vkCmdSetDiscardRectangleEXT", SideEffects::worstDefault, "WRAP_vkCmdSetDiscardRectangleEXT")
  ->args({"commandBuffer", "firstDiscardRectangle", "discardRectangleCount", "pDiscardRectangles"});
#endif /* defined(VK_EXT_discard_rectangles) */
#if defined(VK_EXT_discard_rectangles) && VK_EXT_DISCARD_RECTANGLES_SPEC_VERSION >= 2
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetDiscardRectangleEnableEXT)>(*this, lib, "vkCmdSetDiscardRectangleEnableEXT", SideEffects::worstDefault, "WRAP_vkCmdSetDiscardRectangleEnableEXT")
  ->args({"commandBuffer", "discardRectangleEnable"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetDiscardRectangleModeEXT)>(*this, lib, "vkCmdSetDiscardRectangleModeEXT", SideEffects::worstDefault, "WRAP_vkCmdSetDiscardRectangleModeEXT")
  ->args({"commandBuffer", "discardRectangleMode"});
#endif /* defined(VK_EXT_discard_rectangles) && VK_EXT_DISCARD_RECTANGLES_SPEC_VERSION >= 2 */
#if defined(VK_EXT_display_control)
addExtern<DAS_BIND_FUN(WRAP_vkDisplayPowerControlEXT)>(*this, lib, "vkDisplayPowerControlEXT", SideEffects::worstDefault, "WRAP_vkDisplayPowerControlEXT")
  ->args({"device", "display", "pDisplayPowerInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkGetSwapchainCounterEXT)>(*this, lib, "vkGetSwapchainCounterEXT", SideEffects::worstDefault, "WRAP_vkGetSwapchainCounterEXT")
  ->args({"device", "swapchain", "counter", "pCounterValue"});
addExtern<DAS_BIND_FUN(WRAP_vkRegisterDeviceEventEXT)>(*this, lib, "vkRegisterDeviceEventEXT", SideEffects::worstDefault, "WRAP_vkRegisterDeviceEventEXT")
  ->args({"device", "pDeviceEventInfo", "pAllocator", "pFence"});
addExtern<DAS_BIND_FUN(WRAP_vkRegisterDisplayEventEXT)>(*this, lib, "vkRegisterDisplayEventEXT", SideEffects::worstDefault, "WRAP_vkRegisterDisplayEventEXT")
  ->args({"device", "display", "pDisplayEventInfo", "pAllocator", "pFence"});
#endif /* defined(VK_EXT_display_control) */
#if defined(VK_EXT_display_surface_counter)
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDeviceSurfaceCapabilities2EXT)>(*this, lib, "vkGetPhysicalDeviceSurfaceCapabilities2EXT", SideEffects::worstDefault, "WRAP_vkGetPhysicalDeviceSurfaceCapabilities2EXT")
  ->args({"physicalDevice", "surface", "pSurfaceCapabilities"});
#endif /* defined(VK_EXT_display_surface_counter) */
#if defined(VK_EXT_external_memory_host)
addExtern<DAS_BIND_FUN(WRAP_vkGetMemoryHostPointerPropertiesEXT)>(*this, lib, "vkGetMemoryHostPointerPropertiesEXT", SideEffects::worstDefault, "WRAP_vkGetMemoryHostPointerPropertiesEXT")
  ->args({"device", "handleType", "pHostPointer", "pMemoryHostPointerProperties"});
#endif /* defined(VK_EXT_external_memory_host) */
#if defined(VK_EXT_full_screen_exclusive)
addExtern<DAS_BIND_FUN(WRAP_vkAcquireFullScreenExclusiveModeEXT)>(*this, lib, "vkAcquireFullScreenExclusiveModeEXT", SideEffects::worstDefault, "WRAP_vkAcquireFullScreenExclusiveModeEXT")
  ->args({"device", "swapchain"});
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDeviceSurfacePresentModes2EXT)>(*this, lib, "vkGetPhysicalDeviceSurfacePresentModes2EXT", SideEffects::worstDefault, "WRAP_vkGetPhysicalDeviceSurfacePresentModes2EXT")
  ->args({"physicalDevice", "pSurfaceInfo", "pPresentModeCount", "pPresentModes"});
addExtern<DAS_BIND_FUN(WRAP_vkReleaseFullScreenExclusiveModeEXT)>(*this, lib, "vkReleaseFullScreenExclusiveModeEXT", SideEffects::worstDefault, "WRAP_vkReleaseFullScreenExclusiveModeEXT")
  ->args({"device", "swapchain"});
#endif /* defined(VK_EXT_full_screen_exclusive) */
#if defined(VK_EXT_full_screen_exclusive) && (defined(VK_KHR_device_group) || defined(VK_VERSION_1_1))
addExtern<DAS_BIND_FUN(WRAP_vkGetDeviceGroupSurfacePresentModes2EXT)>(*this, lib, "vkGetDeviceGroupSurfacePresentModes2EXT", SideEffects::worstDefault, "WRAP_vkGetDeviceGroupSurfacePresentModes2EXT")
  ->args({"device", "pSurfaceInfo", "pModes"});
#endif /* defined(VK_EXT_full_screen_exclusive) && (defined(VK_KHR_device_group) || defined(VK_VERSION_1_1)) */
#if defined(VK_EXT_hdr_metadata)
addExtern<DAS_BIND_FUN(WRAP_vkSetHdrMetadataEXT)>(*this, lib, "vkSetHdrMetadataEXT", SideEffects::worstDefault, "WRAP_vkSetHdrMetadataEXT")
  ->args({"device", "swapchainCount", "pSwapchains", "pMetadata"});
#endif /* defined(VK_EXT_hdr_metadata) */
#if defined(VK_EXT_headless_surface)
addExtern<DAS_BIND_FUN(WRAP_vkCreateHeadlessSurfaceEXT)>(*this, lib, "vkCreateHeadlessSurfaceEXT", SideEffects::worstDefault, "WRAP_vkCreateHeadlessSurfaceEXT")
  ->args({"instance", "pCreateInfo", "pAllocator", "pSurface"});
#endif /* defined(VK_EXT_headless_surface) */
#if defined(VK_EXT_host_image_copy)
addExtern<DAS_BIND_FUN(WRAP_vkCopyImageToImageEXT)>(*this, lib, "vkCopyImageToImageEXT", SideEffects::worstDefault, "WRAP_vkCopyImageToImageEXT")
  ->args({"device", "pCopyImageToImageInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCopyImageToMemoryEXT)>(*this, lib, "vkCopyImageToMemoryEXT", SideEffects::worstDefault, "WRAP_vkCopyImageToMemoryEXT")
  ->args({"device", "pCopyImageToMemoryInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCopyMemoryToImageEXT)>(*this, lib, "vkCopyMemoryToImageEXT", SideEffects::worstDefault, "WRAP_vkCopyMemoryToImageEXT")
  ->args({"device", "pCopyMemoryToImageInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkTransitionImageLayoutEXT)>(*this, lib, "vkTransitionImageLayoutEXT", SideEffects::worstDefault, "WRAP_vkTransitionImageLayoutEXT")
  ->args({"device", "transitionCount", "pTransitions"});
#endif /* defined(VK_EXT_host_image_copy) */
#if defined(VK_EXT_host_query_reset)
addExtern<DAS_BIND_FUN(WRAP_vkResetQueryPoolEXT)>(*this, lib, "vkResetQueryPoolEXT", SideEffects::worstDefault, "WRAP_vkResetQueryPoolEXT")
  ->args({"device", "queryPool", "firstQuery", "queryCount"});
#endif /* defined(VK_EXT_host_query_reset) */
#if defined(VK_EXT_image_drm_format_modifier)
addExtern<DAS_BIND_FUN(WRAP_vkGetImageDrmFormatModifierPropertiesEXT)>(*this, lib, "vkGetImageDrmFormatModifierPropertiesEXT", SideEffects::worstDefault, "WRAP_vkGetImageDrmFormatModifierPropertiesEXT")
  ->args({"device", "image", "pProperties"});
#endif /* defined(VK_EXT_image_drm_format_modifier) */
#if defined(VK_EXT_line_rasterization)
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetLineStippleEXT)>(*this, lib, "vkCmdSetLineStippleEXT", SideEffects::worstDefault, "WRAP_vkCmdSetLineStippleEXT")
  ->args({"commandBuffer", "lineStippleFactor", "lineStipplePattern"});
#endif /* defined(VK_EXT_line_rasterization) */
#if defined(VK_EXT_mesh_shader)
addExtern<DAS_BIND_FUN(WRAP_vkCmdDrawMeshTasksEXT)>(*this, lib, "vkCmdDrawMeshTasksEXT", SideEffects::worstDefault, "WRAP_vkCmdDrawMeshTasksEXT")
  ->args({"commandBuffer", "groupCountX", "groupCountY", "groupCountZ"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdDrawMeshTasksIndirectCountEXT)>(*this, lib, "vkCmdDrawMeshTasksIndirectCountEXT", SideEffects::worstDefault, "WRAP_vkCmdDrawMeshTasksIndirectCountEXT")
  ->args({"commandBuffer", "buffer", "offset", "countBuffer", "countBufferOffset", "maxDrawCount", "stride"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdDrawMeshTasksIndirectEXT)>(*this, lib, "vkCmdDrawMeshTasksIndirectEXT", SideEffects::worstDefault, "WRAP_vkCmdDrawMeshTasksIndirectEXT")
  ->args({"commandBuffer", "buffer", "offset", "drawCount", "stride"});
#endif /* defined(VK_EXT_mesh_shader) */
#if defined(VK_EXT_metal_objects)
addExtern<DAS_BIND_FUN(WRAP_vkExportMetalObjectsEXT)>(*this, lib, "vkExportMetalObjectsEXT", SideEffects::worstDefault, "WRAP_vkExportMetalObjectsEXT")
  ->args({"device", "pMetalObjectsInfo"});
#endif /* defined(VK_EXT_metal_objects) */
#if defined(VK_EXT_metal_surface)
addExtern<DAS_BIND_FUN(WRAP_vkCreateMetalSurfaceEXT)>(*this, lib, "vkCreateMetalSurfaceEXT", SideEffects::worstDefault, "WRAP_vkCreateMetalSurfaceEXT")
  ->args({"instance", "pCreateInfo", "pAllocator", "pSurface"});
#endif /* defined(VK_EXT_metal_surface) */
#if defined(VK_EXT_multi_draw)
addExtern<DAS_BIND_FUN(WRAP_vkCmdDrawMultiEXT)>(*this, lib, "vkCmdDrawMultiEXT", SideEffects::worstDefault, "WRAP_vkCmdDrawMultiEXT")
  ->args({"commandBuffer", "drawCount", "pVertexInfo", "instanceCount", "firstInstance", "stride"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdDrawMultiIndexedEXT)>(*this, lib, "vkCmdDrawMultiIndexedEXT", SideEffects::worstDefault, "WRAP_vkCmdDrawMultiIndexedEXT")
  ->args({"commandBuffer", "drawCount", "pIndexInfo", "instanceCount", "firstInstance", "stride", "pVertexOffset"});
#endif /* defined(VK_EXT_multi_draw) */
#if defined(VK_EXT_opacity_micromap)
addExtern<DAS_BIND_FUN(WRAP_vkBuildMicromapsEXT)>(*this, lib, "vkBuildMicromapsEXT", SideEffects::worstDefault, "WRAP_vkBuildMicromapsEXT")
  ->args({"device", "deferredOperation", "infoCount", "pInfos"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdBuildMicromapsEXT)>(*this, lib, "vkCmdBuildMicromapsEXT", SideEffects::worstDefault, "WRAP_vkCmdBuildMicromapsEXT")
  ->args({"commandBuffer", "infoCount", "pInfos"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdCopyMemoryToMicromapEXT)>(*this, lib, "vkCmdCopyMemoryToMicromapEXT", SideEffects::worstDefault, "WRAP_vkCmdCopyMemoryToMicromapEXT")
  ->args({"commandBuffer", "pInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdCopyMicromapEXT)>(*this, lib, "vkCmdCopyMicromapEXT", SideEffects::worstDefault, "WRAP_vkCmdCopyMicromapEXT")
  ->args({"commandBuffer", "pInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdCopyMicromapToMemoryEXT)>(*this, lib, "vkCmdCopyMicromapToMemoryEXT", SideEffects::worstDefault, "WRAP_vkCmdCopyMicromapToMemoryEXT")
  ->args({"commandBuffer", "pInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdWriteMicromapsPropertiesEXT)>(*this, lib, "vkCmdWriteMicromapsPropertiesEXT", SideEffects::worstDefault, "WRAP_vkCmdWriteMicromapsPropertiesEXT")
  ->args({"commandBuffer", "micromapCount", "pMicromaps", "queryType", "queryPool", "firstQuery"});
addExtern<DAS_BIND_FUN(WRAP_vkCopyMemoryToMicromapEXT)>(*this, lib, "vkCopyMemoryToMicromapEXT", SideEffects::worstDefault, "WRAP_vkCopyMemoryToMicromapEXT")
  ->args({"device", "deferredOperation", "pInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCopyMicromapEXT)>(*this, lib, "vkCopyMicromapEXT", SideEffects::worstDefault, "WRAP_vkCopyMicromapEXT")
  ->args({"device", "deferredOperation", "pInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCopyMicromapToMemoryEXT)>(*this, lib, "vkCopyMicromapToMemoryEXT", SideEffects::worstDefault, "WRAP_vkCopyMicromapToMemoryEXT")
  ->args({"device", "deferredOperation", "pInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCreateMicromapEXT)>(*this, lib, "vkCreateMicromapEXT", SideEffects::worstDefault, "WRAP_vkCreateMicromapEXT")
  ->args({"device", "pCreateInfo", "pAllocator", "pMicromap"});
addExtern<DAS_BIND_FUN(WRAP_vkDestroyMicromapEXT)>(*this, lib, "vkDestroyMicromapEXT", SideEffects::worstDefault, "WRAP_vkDestroyMicromapEXT")
  ->args({"device", "micromap", "pAllocator"});
addExtern<DAS_BIND_FUN(WRAP_vkGetDeviceMicromapCompatibilityEXT)>(*this, lib, "vkGetDeviceMicromapCompatibilityEXT", SideEffects::worstDefault, "WRAP_vkGetDeviceMicromapCompatibilityEXT")
  ->args({"device", "pVersionInfo", "pCompatibility"});
addExtern<DAS_BIND_FUN(WRAP_vkGetMicromapBuildSizesEXT)>(*this, lib, "vkGetMicromapBuildSizesEXT", SideEffects::worstDefault, "WRAP_vkGetMicromapBuildSizesEXT")
  ->args({"device", "buildType", "pBuildInfo", "pSizeInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkWriteMicromapsPropertiesEXT)>(*this, lib, "vkWriteMicromapsPropertiesEXT", SideEffects::worstDefault, "WRAP_vkWriteMicromapsPropertiesEXT")
  ->args({"device", "micromapCount", "pMicromaps", "queryType", "dataSize", "pData", "stride"});
#endif /* defined(VK_EXT_opacity_micromap) */
#if defined(VK_EXT_pageable_device_local_memory)
addExtern<DAS_BIND_FUN(WRAP_vkSetDeviceMemoryPriorityEXT)>(*this, lib, "vkSetDeviceMemoryPriorityEXT", SideEffects::worstDefault, "WRAP_vkSetDeviceMemoryPriorityEXT")
  ->args({"device", "memory", "priority"});
#endif /* defined(VK_EXT_pageable_device_local_memory) */
#if defined(VK_EXT_pipeline_properties)
addExtern<DAS_BIND_FUN(WRAP_vkGetPipelinePropertiesEXT)>(*this, lib, "vkGetPipelinePropertiesEXT", SideEffects::worstDefault, "WRAP_vkGetPipelinePropertiesEXT")
  ->args({"device", "pPipelineInfo", "pPipelineProperties"});
#endif /* defined(VK_EXT_pipeline_properties) */
#if defined(VK_EXT_private_data)
addExtern<DAS_BIND_FUN(WRAP_vkCreatePrivateDataSlotEXT)>(*this, lib, "vkCreatePrivateDataSlotEXT", SideEffects::worstDefault, "WRAP_vkCreatePrivateDataSlotEXT")
  ->args({"device", "pCreateInfo", "pAllocator", "pPrivateDataSlot"});
addExtern<DAS_BIND_FUN(WRAP_vkDestroyPrivateDataSlotEXT)>(*this, lib, "vkDestroyPrivateDataSlotEXT", SideEffects::worstDefault, "WRAP_vkDestroyPrivateDataSlotEXT")
  ->args({"device", "privateDataSlot", "pAllocator"});
addExtern<DAS_BIND_FUN(WRAP_vkGetPrivateDataEXT)>(*this, lib, "vkGetPrivateDataEXT", SideEffects::worstDefault, "WRAP_vkGetPrivateDataEXT")
  ->args({"device", "objectType", "objectHandle", "privateDataSlot", "pData"});
addExtern<DAS_BIND_FUN(WRAP_vkSetPrivateDataEXT)>(*this, lib, "vkSetPrivateDataEXT", SideEffects::worstDefault, "WRAP_vkSetPrivateDataEXT")
  ->args({"device", "objectType", "objectHandle", "privateDataSlot", "data"});
#endif /* defined(VK_EXT_private_data) */
#if defined(VK_EXT_sample_locations)
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetSampleLocationsEXT)>(*this, lib, "vkCmdSetSampleLocationsEXT", SideEffects::worstDefault, "WRAP_vkCmdSetSampleLocationsEXT")
  ->args({"commandBuffer", "pSampleLocationsInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDeviceMultisamplePropertiesEXT)>(*this, lib, "vkGetPhysicalDeviceMultisamplePropertiesEXT", SideEffects::worstDefault, "WRAP_vkGetPhysicalDeviceMultisamplePropertiesEXT")
  ->args({"physicalDevice", "samples", "pMultisampleProperties"});
#endif /* defined(VK_EXT_sample_locations) */
#if defined(VK_EXT_shader_module_identifier)
addExtern<DAS_BIND_FUN(WRAP_vkGetShaderModuleCreateInfoIdentifierEXT)>(*this, lib, "vkGetShaderModuleCreateInfoIdentifierEXT", SideEffects::worstDefault, "WRAP_vkGetShaderModuleCreateInfoIdentifierEXT")
  ->args({"device", "pCreateInfo", "pIdentifier"});
addExtern<DAS_BIND_FUN(WRAP_vkGetShaderModuleIdentifierEXT)>(*this, lib, "vkGetShaderModuleIdentifierEXT", SideEffects::worstDefault, "WRAP_vkGetShaderModuleIdentifierEXT")
  ->args({"device", "shaderModule", "pIdentifier"});
#endif /* defined(VK_EXT_shader_module_identifier) */
#if defined(VK_EXT_shader_object)
addExtern<DAS_BIND_FUN(WRAP_vkCmdBindShadersEXT)>(*this, lib, "vkCmdBindShadersEXT", SideEffects::worstDefault, "WRAP_vkCmdBindShadersEXT")
  ->args({"commandBuffer", "stageCount", "pStages", "pShaders"});
addExtern<DAS_BIND_FUN(WRAP_vkCreateShadersEXT)>(*this, lib, "vkCreateShadersEXT", SideEffects::worstDefault, "WRAP_vkCreateShadersEXT")
  ->args({"device", "createInfoCount", "pCreateInfos", "pAllocator", "pShaders"});
addExtern<DAS_BIND_FUN(WRAP_vkDestroyShaderEXT)>(*this, lib, "vkDestroyShaderEXT", SideEffects::worstDefault, "WRAP_vkDestroyShaderEXT")
  ->args({"device", "shader", "pAllocator"});
addExtern<DAS_BIND_FUN(WRAP_vkGetShaderBinaryDataEXT)>(*this, lib, "vkGetShaderBinaryDataEXT", SideEffects::worstDefault, "WRAP_vkGetShaderBinaryDataEXT")
  ->args({"device", "shader", "pDataSize", "pData"});
#endif /* defined(VK_EXT_shader_object) */
#if defined(VK_EXT_swapchain_maintenance1)
addExtern<DAS_BIND_FUN(WRAP_vkReleaseSwapchainImagesEXT)>(*this, lib, "vkReleaseSwapchainImagesEXT", SideEffects::worstDefault, "WRAP_vkReleaseSwapchainImagesEXT")
  ->args({"device", "pReleaseInfo"});
#endif /* defined(VK_EXT_swapchain_maintenance1) */
#if defined(VK_EXT_tooling_info)
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDeviceToolPropertiesEXT)>(*this, lib, "vkGetPhysicalDeviceToolPropertiesEXT", SideEffects::worstDefault, "WRAP_vkGetPhysicalDeviceToolPropertiesEXT")
  ->args({"physicalDevice", "pToolCount", "pToolProperties"});
#endif /* defined(VK_EXT_tooling_info) */
#if defined(VK_EXT_transform_feedback)
addExtern<DAS_BIND_FUN(WRAP_vkCmdBeginQueryIndexedEXT)>(*this, lib, "vkCmdBeginQueryIndexedEXT", SideEffects::worstDefault, "WRAP_vkCmdBeginQueryIndexedEXT")
  ->args({"commandBuffer", "queryPool", "query", "flags", "index"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdBeginTransformFeedbackEXT)>(*this, lib, "vkCmdBeginTransformFeedbackEXT", SideEffects::worstDefault, "WRAP_vkCmdBeginTransformFeedbackEXT")
  ->args({"commandBuffer", "firstCounterBuffer", "counterBufferCount", "pCounterBuffers", "pCounterBufferOffsets"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdBindTransformFeedbackBuffersEXT)>(*this, lib, "vkCmdBindTransformFeedbackBuffersEXT", SideEffects::worstDefault, "WRAP_vkCmdBindTransformFeedbackBuffersEXT")
  ->args({"commandBuffer", "firstBinding", "bindingCount", "pBuffers", "pOffsets", "pSizes"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdDrawIndirectByteCountEXT)>(*this, lib, "vkCmdDrawIndirectByteCountEXT", SideEffects::worstDefault, "WRAP_vkCmdDrawIndirectByteCountEXT")
  ->args({"commandBuffer", "instanceCount", "firstInstance", "counterBuffer", "counterBufferOffset", "counterOffset", "vertexStride"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdEndQueryIndexedEXT)>(*this, lib, "vkCmdEndQueryIndexedEXT", SideEffects::worstDefault, "WRAP_vkCmdEndQueryIndexedEXT")
  ->args({"commandBuffer", "queryPool", "query", "index"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdEndTransformFeedbackEXT)>(*this, lib, "vkCmdEndTransformFeedbackEXT", SideEffects::worstDefault, "WRAP_vkCmdEndTransformFeedbackEXT")
  ->args({"commandBuffer", "firstCounterBuffer", "counterBufferCount", "pCounterBuffers", "pCounterBufferOffsets"});
#endif /* defined(VK_EXT_transform_feedback) */
#if defined(VK_EXT_validation_cache)
addExtern<DAS_BIND_FUN(WRAP_vkCreateValidationCacheEXT)>(*this, lib, "vkCreateValidationCacheEXT", SideEffects::worstDefault, "WRAP_vkCreateValidationCacheEXT")
  ->args({"device", "pCreateInfo", "pAllocator", "pValidationCache"});
addExtern<DAS_BIND_FUN(WRAP_vkDestroyValidationCacheEXT)>(*this, lib, "vkDestroyValidationCacheEXT", SideEffects::worstDefault, "WRAP_vkDestroyValidationCacheEXT")
  ->args({"device", "validationCache", "pAllocator"});
addExtern<DAS_BIND_FUN(WRAP_vkGetValidationCacheDataEXT)>(*this, lib, "vkGetValidationCacheDataEXT", SideEffects::worstDefault, "WRAP_vkGetValidationCacheDataEXT")
  ->args({"device", "validationCache", "pDataSize", "pData"});
addExtern<DAS_BIND_FUN(WRAP_vkMergeValidationCachesEXT)>(*this, lib, "vkMergeValidationCachesEXT", SideEffects::worstDefault, "WRAP_vkMergeValidationCachesEXT")
  ->args({"device", "dstCache", "srcCacheCount", "pSrcCaches"});
#endif /* defined(VK_EXT_validation_cache) */
#if defined(VK_FUCHSIA_buffer_collection)
addExtern<DAS_BIND_FUN(WRAP_vkCreateBufferCollectionFUCHSIA)>(*this, lib, "vkCreateBufferCollectionFUCHSIA", SideEffects::worstDefault, "WRAP_vkCreateBufferCollectionFUCHSIA")
  ->args({"device", "pCreateInfo", "pAllocator", "pCollection"});
addExtern<DAS_BIND_FUN(WRAP_vkDestroyBufferCollectionFUCHSIA)>(*this, lib, "vkDestroyBufferCollectionFUCHSIA", SideEffects::worstDefault, "WRAP_vkDestroyBufferCollectionFUCHSIA")
  ->args({"device", "collection", "pAllocator"});
addExtern<DAS_BIND_FUN(WRAP_vkGetBufferCollectionPropertiesFUCHSIA)>(*this, lib, "vkGetBufferCollectionPropertiesFUCHSIA", SideEffects::worstDefault, "WRAP_vkGetBufferCollectionPropertiesFUCHSIA")
  ->args({"device", "collection", "pProperties"});
addExtern<DAS_BIND_FUN(WRAP_vkSetBufferCollectionBufferConstraintsFUCHSIA)>(*this, lib, "vkSetBufferCollectionBufferConstraintsFUCHSIA", SideEffects::worstDefault, "WRAP_vkSetBufferCollectionBufferConstraintsFUCHSIA")
  ->args({"device", "collection", "pBufferConstraintsInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkSetBufferCollectionImageConstraintsFUCHSIA)>(*this, lib, "vkSetBufferCollectionImageConstraintsFUCHSIA", SideEffects::worstDefault, "WRAP_vkSetBufferCollectionImageConstraintsFUCHSIA")
  ->args({"device", "collection", "pImageConstraintsInfo"});
#endif /* defined(VK_FUCHSIA_buffer_collection) */
#if defined(VK_FUCHSIA_external_memory)
addExtern<DAS_BIND_FUN(WRAP_vkGetMemoryZirconHandleFUCHSIA)>(*this, lib, "vkGetMemoryZirconHandleFUCHSIA", SideEffects::worstDefault, "WRAP_vkGetMemoryZirconHandleFUCHSIA")
  ->args({"device", "pGetZirconHandleInfo", "pZirconHandle"});
addExtern<DAS_BIND_FUN(WRAP_vkGetMemoryZirconHandlePropertiesFUCHSIA)>(*this, lib, "vkGetMemoryZirconHandlePropertiesFUCHSIA", SideEffects::worstDefault, "WRAP_vkGetMemoryZirconHandlePropertiesFUCHSIA")
  ->args({"device", "handleType", "zirconHandle", "pMemoryZirconHandleProperties"});
#endif /* defined(VK_FUCHSIA_external_memory) */
#if defined(VK_FUCHSIA_external_semaphore)
addExtern<DAS_BIND_FUN(WRAP_vkGetSemaphoreZirconHandleFUCHSIA)>(*this, lib, "vkGetSemaphoreZirconHandleFUCHSIA", SideEffects::worstDefault, "WRAP_vkGetSemaphoreZirconHandleFUCHSIA")
  ->args({"device", "pGetZirconHandleInfo", "pZirconHandle"});
addExtern<DAS_BIND_FUN(WRAP_vkImportSemaphoreZirconHandleFUCHSIA)>(*this, lib, "vkImportSemaphoreZirconHandleFUCHSIA", SideEffects::worstDefault, "WRAP_vkImportSemaphoreZirconHandleFUCHSIA")
  ->args({"device", "pImportSemaphoreZirconHandleInfo"});
#endif /* defined(VK_FUCHSIA_external_semaphore) */
#if defined(VK_FUCHSIA_imagepipe_surface)
addExtern<DAS_BIND_FUN(WRAP_vkCreateImagePipeSurfaceFUCHSIA)>(*this, lib, "vkCreateImagePipeSurfaceFUCHSIA", SideEffects::worstDefault, "WRAP_vkCreateImagePipeSurfaceFUCHSIA")
  ->args({"instance", "pCreateInfo", "pAllocator", "pSurface"});
#endif /* defined(VK_FUCHSIA_imagepipe_surface) */
#if defined(VK_GGP_stream_descriptor_surface)
addExtern<DAS_BIND_FUN(WRAP_vkCreateStreamDescriptorSurfaceGGP)>(*this, lib, "vkCreateStreamDescriptorSurfaceGGP", SideEffects::worstDefault, "WRAP_vkCreateStreamDescriptorSurfaceGGP")
  ->args({"instance", "pCreateInfo", "pAllocator", "pSurface"});
#endif /* defined(VK_GGP_stream_descriptor_surface) */
#if defined(VK_GOOGLE_display_timing)
addExtern<DAS_BIND_FUN(WRAP_vkGetPastPresentationTimingGOOGLE)>(*this, lib, "vkGetPastPresentationTimingGOOGLE", SideEffects::worstDefault, "WRAP_vkGetPastPresentationTimingGOOGLE")
  ->args({"device", "swapchain", "pPresentationTimingCount", "pPresentationTimings"});
addExtern<DAS_BIND_FUN(WRAP_vkGetRefreshCycleDurationGOOGLE)>(*this, lib, "vkGetRefreshCycleDurationGOOGLE", SideEffects::worstDefault, "WRAP_vkGetRefreshCycleDurationGOOGLE")
  ->args({"device", "swapchain", "pDisplayTimingProperties"});
#endif /* defined(VK_GOOGLE_display_timing) */
#if defined(VK_HUAWEI_cluster_culling_shader)
addExtern<DAS_BIND_FUN(WRAP_vkCmdDrawClusterHUAWEI)>(*this, lib, "vkCmdDrawClusterHUAWEI", SideEffects::worstDefault, "WRAP_vkCmdDrawClusterHUAWEI")
  ->args({"commandBuffer", "groupCountX", "groupCountY", "groupCountZ"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdDrawClusterIndirectHUAWEI)>(*this, lib, "vkCmdDrawClusterIndirectHUAWEI", SideEffects::worstDefault, "WRAP_vkCmdDrawClusterIndirectHUAWEI")
  ->args({"commandBuffer", "buffer", "offset"});
#endif /* defined(VK_HUAWEI_cluster_culling_shader) */
#if defined(VK_HUAWEI_invocation_mask)
addExtern<DAS_BIND_FUN(WRAP_vkCmdBindInvocationMaskHUAWEI)>(*this, lib, "vkCmdBindInvocationMaskHUAWEI", SideEffects::worstDefault, "WRAP_vkCmdBindInvocationMaskHUAWEI")
  ->args({"commandBuffer", "imageView", "imageLayout"});
#endif /* defined(VK_HUAWEI_invocation_mask) */
#if defined(VK_HUAWEI_subpass_shading)
addExtern<DAS_BIND_FUN(WRAP_vkCmdSubpassShadingHUAWEI)>(*this, lib, "vkCmdSubpassShadingHUAWEI", SideEffects::worstDefault, "WRAP_vkCmdSubpassShadingHUAWEI")
  ->args({"commandBuffer"});
addExtern<DAS_BIND_FUN(WRAP_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI)>(*this, lib, "vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI", SideEffects::worstDefault, "WRAP_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI")
  ->args({"device", "renderpass", "pMaxWorkgroupSize"});
#endif /* defined(VK_HUAWEI_subpass_shading) */
#if defined(VK_INTEL_performance_query)
addExtern<DAS_BIND_FUN(WRAP_vkAcquirePerformanceConfigurationINTEL)>(*this, lib, "vkAcquirePerformanceConfigurationINTEL", SideEffects::worstDefault, "WRAP_vkAcquirePerformanceConfigurationINTEL")
  ->args({"device", "pAcquireInfo", "pConfiguration"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetPerformanceMarkerINTEL)>(*this, lib, "vkCmdSetPerformanceMarkerINTEL", SideEffects::worstDefault, "WRAP_vkCmdSetPerformanceMarkerINTEL")
  ->args({"commandBuffer", "pMarkerInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetPerformanceOverrideINTEL)>(*this, lib, "vkCmdSetPerformanceOverrideINTEL", SideEffects::worstDefault, "WRAP_vkCmdSetPerformanceOverrideINTEL")
  ->args({"commandBuffer", "pOverrideInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetPerformanceStreamMarkerINTEL)>(*this, lib, "vkCmdSetPerformanceStreamMarkerINTEL", SideEffects::worstDefault, "WRAP_vkCmdSetPerformanceStreamMarkerINTEL")
  ->args({"commandBuffer", "pMarkerInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkGetPerformanceParameterINTEL)>(*this, lib, "vkGetPerformanceParameterINTEL", SideEffects::worstDefault, "WRAP_vkGetPerformanceParameterINTEL")
  ->args({"device", "parameter", "pValue"});
addExtern<DAS_BIND_FUN(WRAP_vkInitializePerformanceApiINTEL)>(*this, lib, "vkInitializePerformanceApiINTEL", SideEffects::worstDefault, "WRAP_vkInitializePerformanceApiINTEL")
  ->args({"device", "pInitializeInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkQueueSetPerformanceConfigurationINTEL)>(*this, lib, "vkQueueSetPerformanceConfigurationINTEL", SideEffects::worstDefault, "WRAP_vkQueueSetPerformanceConfigurationINTEL")
  ->args({"queue", "configuration"});
addExtern<DAS_BIND_FUN(WRAP_vkReleasePerformanceConfigurationINTEL)>(*this, lib, "vkReleasePerformanceConfigurationINTEL", SideEffects::worstDefault, "WRAP_vkReleasePerformanceConfigurationINTEL")
  ->args({"device", "configuration"});
addExtern<DAS_BIND_FUN(WRAP_vkUninitializePerformanceApiINTEL)>(*this, lib, "vkUninitializePerformanceApiINTEL", SideEffects::worstDefault, "WRAP_vkUninitializePerformanceApiINTEL")
  ->args({"device"});
#endif /* defined(VK_INTEL_performance_query) */
#if defined(VK_KHR_acceleration_structure)
addExtern<DAS_BIND_FUN(WRAP_vkBuildAccelerationStructuresKHR)>(*this, lib, "vkBuildAccelerationStructuresKHR", SideEffects::worstDefault, "WRAP_vkBuildAccelerationStructuresKHR")
  ->args({"device", "deferredOperation", "infoCount", "pInfos", "ppBuildRangeInfos"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdBuildAccelerationStructuresIndirectKHR)>(*this, lib, "vkCmdBuildAccelerationStructuresIndirectKHR", SideEffects::worstDefault, "WRAP_vkCmdBuildAccelerationStructuresIndirectKHR")
  ->args({"commandBuffer", "infoCount", "pInfos", "pIndirectDeviceAddresses", "pIndirectStrides", "ppMaxPrimitiveCounts"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdBuildAccelerationStructuresKHR)>(*this, lib, "vkCmdBuildAccelerationStructuresKHR", SideEffects::worstDefault, "WRAP_vkCmdBuildAccelerationStructuresKHR")
  ->args({"commandBuffer", "infoCount", "pInfos", "ppBuildRangeInfos"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdCopyAccelerationStructureKHR)>(*this, lib, "vkCmdCopyAccelerationStructureKHR", SideEffects::worstDefault, "WRAP_vkCmdCopyAccelerationStructureKHR")
  ->args({"commandBuffer", "pInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdCopyAccelerationStructureToMemoryKHR)>(*this, lib, "vkCmdCopyAccelerationStructureToMemoryKHR", SideEffects::worstDefault, "WRAP_vkCmdCopyAccelerationStructureToMemoryKHR")
  ->args({"commandBuffer", "pInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdCopyMemoryToAccelerationStructureKHR)>(*this, lib, "vkCmdCopyMemoryToAccelerationStructureKHR", SideEffects::worstDefault, "WRAP_vkCmdCopyMemoryToAccelerationStructureKHR")
  ->args({"commandBuffer", "pInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdWriteAccelerationStructuresPropertiesKHR)>(*this, lib, "vkCmdWriteAccelerationStructuresPropertiesKHR", SideEffects::worstDefault, "WRAP_vkCmdWriteAccelerationStructuresPropertiesKHR")
  ->args({"commandBuffer", "accelerationStructureCount", "pAccelerationStructures", "queryType", "queryPool", "firstQuery"});
addExtern<DAS_BIND_FUN(WRAP_vkCopyAccelerationStructureKHR)>(*this, lib, "vkCopyAccelerationStructureKHR", SideEffects::worstDefault, "WRAP_vkCopyAccelerationStructureKHR")
  ->args({"device", "deferredOperation", "pInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCopyAccelerationStructureToMemoryKHR)>(*this, lib, "vkCopyAccelerationStructureToMemoryKHR", SideEffects::worstDefault, "WRAP_vkCopyAccelerationStructureToMemoryKHR")
  ->args({"device", "deferredOperation", "pInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCopyMemoryToAccelerationStructureKHR)>(*this, lib, "vkCopyMemoryToAccelerationStructureKHR", SideEffects::worstDefault, "WRAP_vkCopyMemoryToAccelerationStructureKHR")
  ->args({"device", "deferredOperation", "pInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCreateAccelerationStructureKHR)>(*this, lib, "vkCreateAccelerationStructureKHR", SideEffects::worstDefault, "WRAP_vkCreateAccelerationStructureKHR")
  ->args({"device", "pCreateInfo", "pAllocator", "pAccelerationStructure"});
addExtern<DAS_BIND_FUN(WRAP_vkDestroyAccelerationStructureKHR)>(*this, lib, "vkDestroyAccelerationStructureKHR", SideEffects::worstDefault, "WRAP_vkDestroyAccelerationStructureKHR")
  ->args({"device", "accelerationStructure", "pAllocator"});
addExtern<DAS_BIND_FUN(WRAP_vkGetAccelerationStructureBuildSizesKHR)>(*this, lib, "vkGetAccelerationStructureBuildSizesKHR", SideEffects::worstDefault, "WRAP_vkGetAccelerationStructureBuildSizesKHR")
  ->args({"device", "buildType", "pBuildInfo", "pMaxPrimitiveCounts", "pSizeInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkGetAccelerationStructureDeviceAddressKHR)>(*this, lib, "vkGetAccelerationStructureDeviceAddressKHR", SideEffects::worstDefault, "WRAP_vkGetAccelerationStructureDeviceAddressKHR")
  ->args({"device", "pInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkGetDeviceAccelerationStructureCompatibilityKHR)>(*this, lib, "vkGetDeviceAccelerationStructureCompatibilityKHR", SideEffects::worstDefault, "WRAP_vkGetDeviceAccelerationStructureCompatibilityKHR")
  ->args({"device", "pVersionInfo", "pCompatibility"});
addExtern<DAS_BIND_FUN(WRAP_vkWriteAccelerationStructuresPropertiesKHR)>(*this, lib, "vkWriteAccelerationStructuresPropertiesKHR", SideEffects::worstDefault, "WRAP_vkWriteAccelerationStructuresPropertiesKHR")
  ->args({"device", "accelerationStructureCount", "pAccelerationStructures", "queryType", "dataSize", "pData", "stride"});
#endif /* defined(VK_KHR_acceleration_structure) */
#if defined(VK_KHR_android_surface)
addExtern<DAS_BIND_FUN(WRAP_vkCreateAndroidSurfaceKHR)>(*this, lib, "vkCreateAndroidSurfaceKHR", SideEffects::worstDefault, "WRAP_vkCreateAndroidSurfaceKHR")
  ->args({"instance", "pCreateInfo", "pAllocator", "pSurface"});
#endif /* defined(VK_KHR_android_surface) */
#if defined(VK_KHR_bind_memory2)
addExtern<DAS_BIND_FUN(WRAP_vkBindBufferMemory2KHR)>(*this, lib, "vkBindBufferMemory2KHR", SideEffects::worstDefault, "WRAP_vkBindBufferMemory2KHR")
  ->args({"device", "bindInfoCount", "pBindInfos"});
addExtern<DAS_BIND_FUN(WRAP_vkBindImageMemory2KHR)>(*this, lib, "vkBindImageMemory2KHR", SideEffects::worstDefault, "WRAP_vkBindImageMemory2KHR")
  ->args({"device", "bindInfoCount", "pBindInfos"});
#endif /* defined(VK_KHR_bind_memory2) */
#if defined(VK_KHR_buffer_device_address)
addExtern<DAS_BIND_FUN(WRAP_vkGetBufferDeviceAddressKHR)>(*this, lib, "vkGetBufferDeviceAddressKHR", SideEffects::worstDefault, "WRAP_vkGetBufferDeviceAddressKHR")
  ->args({"device", "pInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkGetBufferOpaqueCaptureAddressKHR)>(*this, lib, "vkGetBufferOpaqueCaptureAddressKHR", SideEffects::worstDefault, "WRAP_vkGetBufferOpaqueCaptureAddressKHR")
  ->args({"device", "pInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkGetDeviceMemoryOpaqueCaptureAddressKHR)>(*this, lib, "vkGetDeviceMemoryOpaqueCaptureAddressKHR", SideEffects::worstDefault, "WRAP_vkGetDeviceMemoryOpaqueCaptureAddressKHR")
  ->args({"device", "pInfo"});
#endif /* defined(VK_KHR_buffer_device_address) */
#if defined(VK_KHR_calibrated_timestamps)
addExtern<DAS_BIND_FUN(WRAP_vkGetCalibratedTimestampsKHR)>(*this, lib, "vkGetCalibratedTimestampsKHR", SideEffects::worstDefault, "WRAP_vkGetCalibratedTimestampsKHR")
  ->args({"device", "timestampCount", "pTimestampInfos", "pTimestamps", "pMaxDeviation"});
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDeviceCalibrateableTimeDomainsKHR)>(*this, lib, "vkGetPhysicalDeviceCalibrateableTimeDomainsKHR", SideEffects::worstDefault, "WRAP_vkGetPhysicalDeviceCalibrateableTimeDomainsKHR")
  ->args({"physicalDevice", "pTimeDomainCount", "pTimeDomains"});
#endif /* defined(VK_KHR_calibrated_timestamps) */
#if defined(VK_KHR_cooperative_matrix)
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR)>(*this, lib, "vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR", SideEffects::worstDefault, "WRAP_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR")
  ->args({"physicalDevice", "pPropertyCount", "pProperties"});
#endif /* defined(VK_KHR_cooperative_matrix) */
#if defined(VK_KHR_copy_commands2)
addExtern<DAS_BIND_FUN(WRAP_vkCmdBlitImage2KHR)>(*this, lib, "vkCmdBlitImage2KHR", SideEffects::worstDefault, "WRAP_vkCmdBlitImage2KHR")
  ->args({"commandBuffer", "pBlitImageInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdCopyBuffer2KHR)>(*this, lib, "vkCmdCopyBuffer2KHR", SideEffects::worstDefault, "WRAP_vkCmdCopyBuffer2KHR")
  ->args({"commandBuffer", "pCopyBufferInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdCopyBufferToImage2KHR)>(*this, lib, "vkCmdCopyBufferToImage2KHR", SideEffects::worstDefault, "WRAP_vkCmdCopyBufferToImage2KHR")
  ->args({"commandBuffer", "pCopyBufferToImageInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdCopyImage2KHR)>(*this, lib, "vkCmdCopyImage2KHR", SideEffects::worstDefault, "WRAP_vkCmdCopyImage2KHR")
  ->args({"commandBuffer", "pCopyImageInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdCopyImageToBuffer2KHR)>(*this, lib, "vkCmdCopyImageToBuffer2KHR", SideEffects::worstDefault, "WRAP_vkCmdCopyImageToBuffer2KHR")
  ->args({"commandBuffer", "pCopyImageToBufferInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdResolveImage2KHR)>(*this, lib, "vkCmdResolveImage2KHR", SideEffects::worstDefault, "WRAP_vkCmdResolveImage2KHR")
  ->args({"commandBuffer", "pResolveImageInfo"});
#endif /* defined(VK_KHR_copy_commands2) */
#if defined(VK_KHR_create_renderpass2)
addExtern<DAS_BIND_FUN(WRAP_vkCmdBeginRenderPass2KHR)>(*this, lib, "vkCmdBeginRenderPass2KHR", SideEffects::worstDefault, "WRAP_vkCmdBeginRenderPass2KHR")
  ->args({"commandBuffer", "pRenderPassBegin", "pSubpassBeginInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdEndRenderPass2KHR)>(*this, lib, "vkCmdEndRenderPass2KHR", SideEffects::worstDefault, "WRAP_vkCmdEndRenderPass2KHR")
  ->args({"commandBuffer", "pSubpassEndInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdNextSubpass2KHR)>(*this, lib, "vkCmdNextSubpass2KHR", SideEffects::worstDefault, "WRAP_vkCmdNextSubpass2KHR")
  ->args({"commandBuffer", "pSubpassBeginInfo", "pSubpassEndInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCreateRenderPass2KHR)>(*this, lib, "vkCreateRenderPass2KHR", SideEffects::worstDefault, "WRAP_vkCreateRenderPass2KHR")
  ->args({"device", "pCreateInfo", "pAllocator", "pRenderPass"});
#endif /* defined(VK_KHR_create_renderpass2) */
#if defined(VK_KHR_deferred_host_operations)
addExtern<DAS_BIND_FUN(WRAP_vkCreateDeferredOperationKHR)>(*this, lib, "vkCreateDeferredOperationKHR", SideEffects::worstDefault, "WRAP_vkCreateDeferredOperationKHR")
  ->args({"device", "pAllocator", "pDeferredOperation"});
addExtern<DAS_BIND_FUN(WRAP_vkDeferredOperationJoinKHR)>(*this, lib, "vkDeferredOperationJoinKHR", SideEffects::worstDefault, "WRAP_vkDeferredOperationJoinKHR")
  ->args({"device", "operation"});
addExtern<DAS_BIND_FUN(WRAP_vkDestroyDeferredOperationKHR)>(*this, lib, "vkDestroyDeferredOperationKHR", SideEffects::worstDefault, "WRAP_vkDestroyDeferredOperationKHR")
  ->args({"device", "operation", "pAllocator"});
addExtern<DAS_BIND_FUN(WRAP_vkGetDeferredOperationMaxConcurrencyKHR)>(*this, lib, "vkGetDeferredOperationMaxConcurrencyKHR", SideEffects::worstDefault, "WRAP_vkGetDeferredOperationMaxConcurrencyKHR")
  ->args({"device", "operation"});
addExtern<DAS_BIND_FUN(WRAP_vkGetDeferredOperationResultKHR)>(*this, lib, "vkGetDeferredOperationResultKHR", SideEffects::worstDefault, "WRAP_vkGetDeferredOperationResultKHR")
  ->args({"device", "operation"});
#endif /* defined(VK_KHR_deferred_host_operations) */
#if defined(VK_KHR_descriptor_update_template)
addExtern<DAS_BIND_FUN(WRAP_vkCreateDescriptorUpdateTemplateKHR)>(*this, lib, "vkCreateDescriptorUpdateTemplateKHR", SideEffects::worstDefault, "WRAP_vkCreateDescriptorUpdateTemplateKHR")
  ->args({"device", "pCreateInfo", "pAllocator", "pDescriptorUpdateTemplate"});
addExtern<DAS_BIND_FUN(WRAP_vkDestroyDescriptorUpdateTemplateKHR)>(*this, lib, "vkDestroyDescriptorUpdateTemplateKHR", SideEffects::worstDefault, "WRAP_vkDestroyDescriptorUpdateTemplateKHR")
  ->args({"device", "descriptorUpdateTemplate", "pAllocator"});
addExtern<DAS_BIND_FUN(WRAP_vkUpdateDescriptorSetWithTemplateKHR)>(*this, lib, "vkUpdateDescriptorSetWithTemplateKHR", SideEffects::worstDefault, "WRAP_vkUpdateDescriptorSetWithTemplateKHR")
  ->args({"device", "descriptorSet", "descriptorUpdateTemplate", "pData"});
#endif /* defined(VK_KHR_descriptor_update_template) */
#if defined(VK_KHR_device_group)
addExtern<DAS_BIND_FUN(WRAP_vkCmdDispatchBaseKHR)>(*this, lib, "vkCmdDispatchBaseKHR", SideEffects::worstDefault, "WRAP_vkCmdDispatchBaseKHR")
  ->args({"commandBuffer", "baseGroupX", "baseGroupY", "baseGroupZ", "groupCountX", "groupCountY", "groupCountZ"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetDeviceMaskKHR)>(*this, lib, "vkCmdSetDeviceMaskKHR", SideEffects::worstDefault, "WRAP_vkCmdSetDeviceMaskKHR")
  ->args({"commandBuffer", "deviceMask"});
addExtern<DAS_BIND_FUN(WRAP_vkGetDeviceGroupPeerMemoryFeaturesKHR)>(*this, lib, "vkGetDeviceGroupPeerMemoryFeaturesKHR", SideEffects::worstDefault, "WRAP_vkGetDeviceGroupPeerMemoryFeaturesKHR")
  ->args({"device", "heapIndex", "localDeviceIndex", "remoteDeviceIndex", "pPeerMemoryFeatures"});
#endif /* defined(VK_KHR_device_group) */
#if defined(VK_KHR_device_group_creation)
addExtern<DAS_BIND_FUN(WRAP_vkEnumeratePhysicalDeviceGroupsKHR)>(*this, lib, "vkEnumeratePhysicalDeviceGroupsKHR", SideEffects::worstDefault, "WRAP_vkEnumeratePhysicalDeviceGroupsKHR")
  ->args({"instance", "pPhysicalDeviceGroupCount", "pPhysicalDeviceGroupProperties"});
#endif /* defined(VK_KHR_device_group_creation) */
#if defined(VK_KHR_display)
addExtern<DAS_BIND_FUN(WRAP_vkCreateDisplayModeKHR)>(*this, lib, "vkCreateDisplayModeKHR", SideEffects::worstDefault, "WRAP_vkCreateDisplayModeKHR")
  ->args({"physicalDevice", "display", "pCreateInfo", "pAllocator", "pMode"});
addExtern<DAS_BIND_FUN(WRAP_vkCreateDisplayPlaneSurfaceKHR)>(*this, lib, "vkCreateDisplayPlaneSurfaceKHR", SideEffects::worstDefault, "WRAP_vkCreateDisplayPlaneSurfaceKHR")
  ->args({"instance", "pCreateInfo", "pAllocator", "pSurface"});
addExtern<DAS_BIND_FUN(WRAP_vkGetDisplayModePropertiesKHR)>(*this, lib, "vkGetDisplayModePropertiesKHR", SideEffects::worstDefault, "WRAP_vkGetDisplayModePropertiesKHR")
  ->args({"physicalDevice", "display", "pPropertyCount", "pProperties"});
addExtern<DAS_BIND_FUN(WRAP_vkGetDisplayPlaneCapabilitiesKHR)>(*this, lib, "vkGetDisplayPlaneCapabilitiesKHR", SideEffects::worstDefault, "WRAP_vkGetDisplayPlaneCapabilitiesKHR")
  ->args({"physicalDevice", "mode", "planeIndex", "pCapabilities"});
addExtern<DAS_BIND_FUN(WRAP_vkGetDisplayPlaneSupportedDisplaysKHR)>(*this, lib, "vkGetDisplayPlaneSupportedDisplaysKHR", SideEffects::worstDefault, "WRAP_vkGetDisplayPlaneSupportedDisplaysKHR")
  ->args({"physicalDevice", "planeIndex", "pDisplayCount", "pDisplays"});
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDeviceDisplayPlanePropertiesKHR)>(*this, lib, "vkGetPhysicalDeviceDisplayPlanePropertiesKHR", SideEffects::worstDefault, "WRAP_vkGetPhysicalDeviceDisplayPlanePropertiesKHR")
  ->args({"physicalDevice", "pPropertyCount", "pProperties"});
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDeviceDisplayPropertiesKHR)>(*this, lib, "vkGetPhysicalDeviceDisplayPropertiesKHR", SideEffects::worstDefault, "WRAP_vkGetPhysicalDeviceDisplayPropertiesKHR")
  ->args({"physicalDevice", "pPropertyCount", "pProperties"});
#endif /* defined(VK_KHR_display) */
#if defined(VK_KHR_display_swapchain)
addExtern<DAS_BIND_FUN(WRAP_vkCreateSharedSwapchainsKHR)>(*this, lib, "vkCreateSharedSwapchainsKHR", SideEffects::worstDefault, "WRAP_vkCreateSharedSwapchainsKHR")
  ->args({"device", "swapchainCount", "pCreateInfos", "pAllocator", "pSwapchains"});
#endif /* defined(VK_KHR_display_swapchain) */
#if defined(VK_KHR_draw_indirect_count)
addExtern<DAS_BIND_FUN(WRAP_vkCmdDrawIndexedIndirectCountKHR)>(*this, lib, "vkCmdDrawIndexedIndirectCountKHR", SideEffects::worstDefault, "WRAP_vkCmdDrawIndexedIndirectCountKHR")
  ->args({"commandBuffer", "buffer", "offset", "countBuffer", "countBufferOffset", "maxDrawCount", "stride"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdDrawIndirectCountKHR)>(*this, lib, "vkCmdDrawIndirectCountKHR", SideEffects::worstDefault, "WRAP_vkCmdDrawIndirectCountKHR")
  ->args({"commandBuffer", "buffer", "offset", "countBuffer", "countBufferOffset", "maxDrawCount", "stride"});
#endif /* defined(VK_KHR_draw_indirect_count) */
#if defined(VK_KHR_dynamic_rendering)
addExtern<DAS_BIND_FUN(WRAP_vkCmdBeginRenderingKHR)>(*this, lib, "vkCmdBeginRenderingKHR", SideEffects::worstDefault, "WRAP_vkCmdBeginRenderingKHR")
  ->args({"commandBuffer", "pRenderingInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdEndRenderingKHR)>(*this, lib, "vkCmdEndRenderingKHR", SideEffects::worstDefault, "WRAP_vkCmdEndRenderingKHR")
  ->args({"commandBuffer"});
#endif /* defined(VK_KHR_dynamic_rendering) */
#if defined(VK_KHR_dynamic_rendering_local_read)
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetRenderingAttachmentLocationsKHR)>(*this, lib, "vkCmdSetRenderingAttachmentLocationsKHR", SideEffects::worstDefault, "WRAP_vkCmdSetRenderingAttachmentLocationsKHR")
  ->args({"commandBuffer", "pLocationInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetRenderingInputAttachmentIndicesKHR)>(*this, lib, "vkCmdSetRenderingInputAttachmentIndicesKHR", SideEffects::worstDefault, "WRAP_vkCmdSetRenderingInputAttachmentIndicesKHR")
  ->args({"commandBuffer", "pInputAttachmentIndexInfo"});
#endif /* defined(VK_KHR_dynamic_rendering_local_read) */
#if defined(VK_KHR_external_fence_capabilities)
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDeviceExternalFencePropertiesKHR)>(*this, lib, "vkGetPhysicalDeviceExternalFencePropertiesKHR", SideEffects::worstDefault, "WRAP_vkGetPhysicalDeviceExternalFencePropertiesKHR")
  ->args({"physicalDevice", "pExternalFenceInfo", "pExternalFenceProperties"});
#endif /* defined(VK_KHR_external_fence_capabilities) */
#if defined(VK_KHR_external_fence_fd)
addExtern<DAS_BIND_FUN(WRAP_vkGetFenceFdKHR)>(*this, lib, "vkGetFenceFdKHR", SideEffects::worstDefault, "WRAP_vkGetFenceFdKHR")
  ->args({"device", "pGetFdInfo", "pFd"});
addExtern<DAS_BIND_FUN(WRAP_vkImportFenceFdKHR)>(*this, lib, "vkImportFenceFdKHR", SideEffects::worstDefault, "WRAP_vkImportFenceFdKHR")
  ->args({"device", "pImportFenceFdInfo"});
#endif /* defined(VK_KHR_external_fence_fd) */
#if defined(VK_KHR_external_fence_win32)
addExtern<DAS_BIND_FUN(WRAP_vkGetFenceWin32HandleKHR)>(*this, lib, "vkGetFenceWin32HandleKHR", SideEffects::worstDefault, "WRAP_vkGetFenceWin32HandleKHR")
  ->args({"device", "pGetWin32HandleInfo", "pHandle"});
addExtern<DAS_BIND_FUN(WRAP_vkImportFenceWin32HandleKHR)>(*this, lib, "vkImportFenceWin32HandleKHR", SideEffects::worstDefault, "WRAP_vkImportFenceWin32HandleKHR")
  ->args({"device", "pImportFenceWin32HandleInfo"});
#endif /* defined(VK_KHR_external_fence_win32) */
#if defined(VK_KHR_external_memory_capabilities)
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDeviceExternalBufferPropertiesKHR)>(*this, lib, "vkGetPhysicalDeviceExternalBufferPropertiesKHR", SideEffects::worstDefault, "WRAP_vkGetPhysicalDeviceExternalBufferPropertiesKHR")
  ->args({"physicalDevice", "pExternalBufferInfo", "pExternalBufferProperties"});
#endif /* defined(VK_KHR_external_memory_capabilities) */
#if defined(VK_KHR_external_memory_fd)
addExtern<DAS_BIND_FUN(WRAP_vkGetMemoryFdKHR)>(*this, lib, "vkGetMemoryFdKHR", SideEffects::worstDefault, "WRAP_vkGetMemoryFdKHR")
  ->args({"device", "pGetFdInfo", "pFd"});
addExtern<DAS_BIND_FUN(WRAP_vkGetMemoryFdPropertiesKHR)>(*this, lib, "vkGetMemoryFdPropertiesKHR", SideEffects::worstDefault, "WRAP_vkGetMemoryFdPropertiesKHR")
  ->args({"device", "handleType", "fd", "pMemoryFdProperties"});
#endif /* defined(VK_KHR_external_memory_fd) */
#if defined(VK_KHR_external_memory_win32)
addExtern<DAS_BIND_FUN(WRAP_vkGetMemoryWin32HandleKHR)>(*this, lib, "vkGetMemoryWin32HandleKHR", SideEffects::worstDefault, "WRAP_vkGetMemoryWin32HandleKHR")
  ->args({"device", "pGetWin32HandleInfo", "pHandle"});
addExtern<DAS_BIND_FUN(WRAP_vkGetMemoryWin32HandlePropertiesKHR)>(*this, lib, "vkGetMemoryWin32HandlePropertiesKHR", SideEffects::worstDefault, "WRAP_vkGetMemoryWin32HandlePropertiesKHR")
  ->args({"device", "handleType", "handle", "pMemoryWin32HandleProperties"});
#endif /* defined(VK_KHR_external_memory_win32) */
#if defined(VK_KHR_external_semaphore_capabilities)
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR)>(*this, lib, "vkGetPhysicalDeviceExternalSemaphorePropertiesKHR", SideEffects::worstDefault, "WRAP_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR")
  ->args({"physicalDevice", "pExternalSemaphoreInfo", "pExternalSemaphoreProperties"});
#endif /* defined(VK_KHR_external_semaphore_capabilities) */
#if defined(VK_KHR_external_semaphore_fd)
addExtern<DAS_BIND_FUN(WRAP_vkGetSemaphoreFdKHR)>(*this, lib, "vkGetSemaphoreFdKHR", SideEffects::worstDefault, "WRAP_vkGetSemaphoreFdKHR")
  ->args({"device", "pGetFdInfo", "pFd"});
addExtern<DAS_BIND_FUN(WRAP_vkImportSemaphoreFdKHR)>(*this, lib, "vkImportSemaphoreFdKHR", SideEffects::worstDefault, "WRAP_vkImportSemaphoreFdKHR")
  ->args({"device", "pImportSemaphoreFdInfo"});
#endif /* defined(VK_KHR_external_semaphore_fd) */
#if defined(VK_KHR_external_semaphore_win32)
addExtern<DAS_BIND_FUN(WRAP_vkGetSemaphoreWin32HandleKHR)>(*this, lib, "vkGetSemaphoreWin32HandleKHR", SideEffects::worstDefault, "WRAP_vkGetSemaphoreWin32HandleKHR")
  ->args({"device", "pGetWin32HandleInfo", "pHandle"});
addExtern<DAS_BIND_FUN(WRAP_vkImportSemaphoreWin32HandleKHR)>(*this, lib, "vkImportSemaphoreWin32HandleKHR", SideEffects::worstDefault, "WRAP_vkImportSemaphoreWin32HandleKHR")
  ->args({"device", "pImportSemaphoreWin32HandleInfo"});
#endif /* defined(VK_KHR_external_semaphore_win32) */
#if defined(VK_KHR_fragment_shading_rate)
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetFragmentShadingRateKHR)>(*this, lib, "vkCmdSetFragmentShadingRateKHR", SideEffects::worstDefault, "WRAP_vkCmdSetFragmentShadingRateKHR")
  ->args({"commandBuffer", "pFragmentSize", "combinerOps"});
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDeviceFragmentShadingRatesKHR)>(*this, lib, "vkGetPhysicalDeviceFragmentShadingRatesKHR", SideEffects::worstDefault, "WRAP_vkGetPhysicalDeviceFragmentShadingRatesKHR")
  ->args({"physicalDevice", "pFragmentShadingRateCount", "pFragmentShadingRates"});
#endif /* defined(VK_KHR_fragment_shading_rate) */
#if defined(VK_KHR_get_display_properties2)
addExtern<DAS_BIND_FUN(WRAP_vkGetDisplayModeProperties2KHR)>(*this, lib, "vkGetDisplayModeProperties2KHR", SideEffects::worstDefault, "WRAP_vkGetDisplayModeProperties2KHR")
  ->args({"physicalDevice", "display", "pPropertyCount", "pProperties"});
addExtern<DAS_BIND_FUN(WRAP_vkGetDisplayPlaneCapabilities2KHR)>(*this, lib, "vkGetDisplayPlaneCapabilities2KHR", SideEffects::worstDefault, "WRAP_vkGetDisplayPlaneCapabilities2KHR")
  ->args({"physicalDevice", "pDisplayPlaneInfo", "pCapabilities"});
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDeviceDisplayPlaneProperties2KHR)>(*this, lib, "vkGetPhysicalDeviceDisplayPlaneProperties2KHR", SideEffects::worstDefault, "WRAP_vkGetPhysicalDeviceDisplayPlaneProperties2KHR")
  ->args({"physicalDevice", "pPropertyCount", "pProperties"});
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDeviceDisplayProperties2KHR)>(*this, lib, "vkGetPhysicalDeviceDisplayProperties2KHR", SideEffects::worstDefault, "WRAP_vkGetPhysicalDeviceDisplayProperties2KHR")
  ->args({"physicalDevice", "pPropertyCount", "pProperties"});
#endif /* defined(VK_KHR_get_display_properties2) */
#if defined(VK_KHR_get_memory_requirements2)
addExtern<DAS_BIND_FUN(WRAP_vkGetBufferMemoryRequirements2KHR)>(*this, lib, "vkGetBufferMemoryRequirements2KHR", SideEffects::worstDefault, "WRAP_vkGetBufferMemoryRequirements2KHR")
  ->args({"device", "pInfo", "pMemoryRequirements"});
addExtern<DAS_BIND_FUN(WRAP_vkGetImageMemoryRequirements2KHR)>(*this, lib, "vkGetImageMemoryRequirements2KHR", SideEffects::worstDefault, "WRAP_vkGetImageMemoryRequirements2KHR")
  ->args({"device", "pInfo", "pMemoryRequirements"});
addExtern<DAS_BIND_FUN(WRAP_vkGetImageSparseMemoryRequirements2KHR)>(*this, lib, "vkGetImageSparseMemoryRequirements2KHR", SideEffects::worstDefault, "WRAP_vkGetImageSparseMemoryRequirements2KHR")
  ->args({"device", "pInfo", "pSparseMemoryRequirementCount", "pSparseMemoryRequirements"});
#endif /* defined(VK_KHR_get_memory_requirements2) */
#if defined(VK_KHR_get_physical_device_properties2)
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDeviceFeatures2KHR)>(*this, lib, "vkGetPhysicalDeviceFeatures2KHR", SideEffects::worstDefault, "WRAP_vkGetPhysicalDeviceFeatures2KHR")
  ->args({"physicalDevice", "pFeatures"});
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDeviceFormatProperties2KHR)>(*this, lib, "vkGetPhysicalDeviceFormatProperties2KHR", SideEffects::worstDefault, "WRAP_vkGetPhysicalDeviceFormatProperties2KHR")
  ->args({"physicalDevice", "format", "pFormatProperties"});
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDeviceImageFormatProperties2KHR)>(*this, lib, "vkGetPhysicalDeviceImageFormatProperties2KHR", SideEffects::worstDefault, "WRAP_vkGetPhysicalDeviceImageFormatProperties2KHR")
  ->args({"physicalDevice", "pImageFormatInfo", "pImageFormatProperties"});
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDeviceMemoryProperties2KHR)>(*this, lib, "vkGetPhysicalDeviceMemoryProperties2KHR", SideEffects::worstDefault, "WRAP_vkGetPhysicalDeviceMemoryProperties2KHR")
  ->args({"physicalDevice", "pMemoryProperties"});
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDeviceProperties2KHR)>(*this, lib, "vkGetPhysicalDeviceProperties2KHR", SideEffects::worstDefault, "WRAP_vkGetPhysicalDeviceProperties2KHR")
  ->args({"physicalDevice", "pProperties"});
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDeviceQueueFamilyProperties2KHR)>(*this, lib, "vkGetPhysicalDeviceQueueFamilyProperties2KHR", SideEffects::worstDefault, "WRAP_vkGetPhysicalDeviceQueueFamilyProperties2KHR")
  ->args({"physicalDevice", "pQueueFamilyPropertyCount", "pQueueFamilyProperties"});
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDeviceSparseImageFormatProperties2KHR)>(*this, lib, "vkGetPhysicalDeviceSparseImageFormatProperties2KHR", SideEffects::worstDefault, "WRAP_vkGetPhysicalDeviceSparseImageFormatProperties2KHR")
  ->args({"physicalDevice", "pFormatInfo", "pPropertyCount", "pProperties"});
#endif /* defined(VK_KHR_get_physical_device_properties2) */
#if defined(VK_KHR_get_surface_capabilities2)
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDeviceSurfaceCapabilities2KHR)>(*this, lib, "vkGetPhysicalDeviceSurfaceCapabilities2KHR", SideEffects::worstDefault, "WRAP_vkGetPhysicalDeviceSurfaceCapabilities2KHR")
  ->args({"physicalDevice", "pSurfaceInfo", "pSurfaceCapabilities"});
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDeviceSurfaceFormats2KHR)>(*this, lib, "vkGetPhysicalDeviceSurfaceFormats2KHR", SideEffects::worstDefault, "WRAP_vkGetPhysicalDeviceSurfaceFormats2KHR")
  ->args({"physicalDevice", "pSurfaceInfo", "pSurfaceFormatCount", "pSurfaceFormats"});
#endif /* defined(VK_KHR_get_surface_capabilities2) */
#if defined(VK_KHR_line_rasterization)
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetLineStippleKHR)>(*this, lib, "vkCmdSetLineStippleKHR", SideEffects::worstDefault, "WRAP_vkCmdSetLineStippleKHR")
  ->args({"commandBuffer", "lineStippleFactor", "lineStipplePattern"});
#endif /* defined(VK_KHR_line_rasterization) */
#if defined(VK_KHR_maintenance1)
addExtern<DAS_BIND_FUN(WRAP_vkTrimCommandPoolKHR)>(*this, lib, "vkTrimCommandPoolKHR", SideEffects::worstDefault, "WRAP_vkTrimCommandPoolKHR")
  ->args({"device", "commandPool", "flags"});
#endif /* defined(VK_KHR_maintenance1) */
#if defined(VK_KHR_maintenance3)
addExtern<DAS_BIND_FUN(WRAP_vkGetDescriptorSetLayoutSupportKHR)>(*this, lib, "vkGetDescriptorSetLayoutSupportKHR", SideEffects::worstDefault, "WRAP_vkGetDescriptorSetLayoutSupportKHR")
  ->args({"device", "pCreateInfo", "pSupport"});
#endif /* defined(VK_KHR_maintenance3) */
#if defined(VK_KHR_maintenance4)
addExtern<DAS_BIND_FUN(WRAP_vkGetDeviceBufferMemoryRequirementsKHR)>(*this, lib, "vkGetDeviceBufferMemoryRequirementsKHR", SideEffects::worstDefault, "WRAP_vkGetDeviceBufferMemoryRequirementsKHR")
  ->args({"device", "pInfo", "pMemoryRequirements"});
addExtern<DAS_BIND_FUN(WRAP_vkGetDeviceImageMemoryRequirementsKHR)>(*this, lib, "vkGetDeviceImageMemoryRequirementsKHR", SideEffects::worstDefault, "WRAP_vkGetDeviceImageMemoryRequirementsKHR")
  ->args({"device", "pInfo", "pMemoryRequirements"});
addExtern<DAS_BIND_FUN(WRAP_vkGetDeviceImageSparseMemoryRequirementsKHR)>(*this, lib, "vkGetDeviceImageSparseMemoryRequirementsKHR", SideEffects::worstDefault, "WRAP_vkGetDeviceImageSparseMemoryRequirementsKHR")
  ->args({"device", "pInfo", "pSparseMemoryRequirementCount", "pSparseMemoryRequirements"});
#endif /* defined(VK_KHR_maintenance4) */
#if defined(VK_KHR_maintenance5)
addExtern<DAS_BIND_FUN(WRAP_vkCmdBindIndexBuffer2KHR)>(*this, lib, "vkCmdBindIndexBuffer2KHR", SideEffects::worstDefault, "WRAP_vkCmdBindIndexBuffer2KHR")
  ->args({"commandBuffer", "buffer", "offset", "size", "indexType"});
addExtern<DAS_BIND_FUN(WRAP_vkGetDeviceImageSubresourceLayoutKHR)>(*this, lib, "vkGetDeviceImageSubresourceLayoutKHR", SideEffects::worstDefault, "WRAP_vkGetDeviceImageSubresourceLayoutKHR")
  ->args({"device", "pInfo", "pLayout"});
addExtern<DAS_BIND_FUN(WRAP_vkGetImageSubresourceLayout2KHR)>(*this, lib, "vkGetImageSubresourceLayout2KHR", SideEffects::worstDefault, "WRAP_vkGetImageSubresourceLayout2KHR")
  ->args({"device", "image", "pSubresource", "pLayout"});
addExtern<DAS_BIND_FUN(WRAP_vkGetRenderingAreaGranularityKHR)>(*this, lib, "vkGetRenderingAreaGranularityKHR", SideEffects::worstDefault, "WRAP_vkGetRenderingAreaGranularityKHR")
  ->args({"device", "pRenderingAreaInfo", "pGranularity"});
#endif /* defined(VK_KHR_maintenance5) */
#if defined(VK_KHR_maintenance6)
addExtern<DAS_BIND_FUN(WRAP_vkCmdBindDescriptorSets2KHR)>(*this, lib, "vkCmdBindDescriptorSets2KHR", SideEffects::worstDefault, "WRAP_vkCmdBindDescriptorSets2KHR")
  ->args({"commandBuffer", "pBindDescriptorSetsInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdPushConstants2KHR)>(*this, lib, "vkCmdPushConstants2KHR", SideEffects::worstDefault, "WRAP_vkCmdPushConstants2KHR")
  ->args({"commandBuffer", "pPushConstantsInfo"});
#endif /* defined(VK_KHR_maintenance6) */
#if defined(VK_KHR_maintenance6) && defined(VK_KHR_push_descriptor)
addExtern<DAS_BIND_FUN(WRAP_vkCmdPushDescriptorSet2KHR)>(*this, lib, "vkCmdPushDescriptorSet2KHR", SideEffects::worstDefault, "WRAP_vkCmdPushDescriptorSet2KHR")
  ->args({"commandBuffer", "pPushDescriptorSetInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdPushDescriptorSetWithTemplate2KHR)>(*this, lib, "vkCmdPushDescriptorSetWithTemplate2KHR", SideEffects::worstDefault, "WRAP_vkCmdPushDescriptorSetWithTemplate2KHR")
  ->args({"commandBuffer", "pPushDescriptorSetWithTemplateInfo"});
#endif /* defined(VK_KHR_maintenance6) && defined(VK_KHR_push_descriptor) */
#if defined(VK_KHR_maintenance6) && defined(VK_EXT_descriptor_buffer)
addExtern<DAS_BIND_FUN(WRAP_vkCmdBindDescriptorBufferEmbeddedSamplers2EXT)>(*this, lib, "vkCmdBindDescriptorBufferEmbeddedSamplers2EXT", SideEffects::worstDefault, "WRAP_vkCmdBindDescriptorBufferEmbeddedSamplers2EXT")
  ->args({"commandBuffer", "pBindDescriptorBufferEmbeddedSamplersInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetDescriptorBufferOffsets2EXT)>(*this, lib, "vkCmdSetDescriptorBufferOffsets2EXT", SideEffects::worstDefault, "WRAP_vkCmdSetDescriptorBufferOffsets2EXT")
  ->args({"commandBuffer", "pSetDescriptorBufferOffsetsInfo"});
#endif /* defined(VK_KHR_maintenance6) && defined(VK_EXT_descriptor_buffer) */
#if defined(VK_KHR_map_memory2)
addExtern<DAS_BIND_FUN(WRAP_vkMapMemory2KHR)>(*this, lib, "vkMapMemory2KHR", SideEffects::worstDefault, "WRAP_vkMapMemory2KHR")
  ->args({"device", "pMemoryMapInfo", "ppData"});
addExtern<DAS_BIND_FUN(WRAP_vkUnmapMemory2KHR)>(*this, lib, "vkUnmapMemory2KHR", SideEffects::worstDefault, "WRAP_vkUnmapMemory2KHR")
  ->args({"device", "pMemoryUnmapInfo"});
#endif /* defined(VK_KHR_map_memory2) */
#if defined(VK_KHR_performance_query)
addExtern<DAS_BIND_FUN(WRAP_vkAcquireProfilingLockKHR)>(*this, lib, "vkAcquireProfilingLockKHR", SideEffects::worstDefault, "WRAP_vkAcquireProfilingLockKHR")
  ->args({"device", "pInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR)>(*this, lib, "vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR", SideEffects::worstDefault, "WRAP_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR")
  ->args({"physicalDevice", "queueFamilyIndex", "pCounterCount", "pCounters", "pCounterDescriptions"});
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR)>(*this, lib, "vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR", SideEffects::worstDefault, "WRAP_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR")
  ->args({"physicalDevice", "pPerformanceQueryCreateInfo", "pNumPasses"});
addExtern<DAS_BIND_FUN(WRAP_vkReleaseProfilingLockKHR)>(*this, lib, "vkReleaseProfilingLockKHR", SideEffects::worstDefault, "WRAP_vkReleaseProfilingLockKHR")
  ->args({"device"});
#endif /* defined(VK_KHR_performance_query) */
#if defined(VK_KHR_pipeline_binary)
addExtern<DAS_BIND_FUN(WRAP_vkCreatePipelineBinariesKHR)>(*this, lib, "vkCreatePipelineBinariesKHR", SideEffects::worstDefault, "WRAP_vkCreatePipelineBinariesKHR")
  ->args({"device", "pCreateInfo", "pAllocator", "pBinaries"});
addExtern<DAS_BIND_FUN(WRAP_vkDestroyPipelineBinaryKHR)>(*this, lib, "vkDestroyPipelineBinaryKHR", SideEffects::worstDefault, "WRAP_vkDestroyPipelineBinaryKHR")
  ->args({"device", "pipelineBinary", "pAllocator"});
addExtern<DAS_BIND_FUN(WRAP_vkGetPipelineBinaryDataKHR)>(*this, lib, "vkGetPipelineBinaryDataKHR", SideEffects::worstDefault, "WRAP_vkGetPipelineBinaryDataKHR")
  ->args({"device", "pInfo", "pPipelineBinaryKey", "pPipelineBinaryDataSize", "pPipelineBinaryData"});
addExtern<DAS_BIND_FUN(WRAP_vkGetPipelineKeyKHR)>(*this, lib, "vkGetPipelineKeyKHR", SideEffects::worstDefault, "WRAP_vkGetPipelineKeyKHR")
  ->args({"device", "pPipelineCreateInfo", "pPipelineKey"});
addExtern<DAS_BIND_FUN(WRAP_vkReleaseCapturedPipelineDataKHR)>(*this, lib, "vkReleaseCapturedPipelineDataKHR", SideEffects::worstDefault, "WRAP_vkReleaseCapturedPipelineDataKHR")
  ->args({"device", "pInfo", "pAllocator"});
#endif /* defined(VK_KHR_pipeline_binary) */
#if defined(VK_KHR_pipeline_executable_properties)
addExtern<DAS_BIND_FUN(WRAP_vkGetPipelineExecutableInternalRepresentationsKHR)>(*this, lib, "vkGetPipelineExecutableInternalRepresentationsKHR", SideEffects::worstDefault, "WRAP_vkGetPipelineExecutableInternalRepresentationsKHR")
  ->args({"device", "pExecutableInfo", "pInternalRepresentationCount", "pInternalRepresentations"});
addExtern<DAS_BIND_FUN(WRAP_vkGetPipelineExecutablePropertiesKHR)>(*this, lib, "vkGetPipelineExecutablePropertiesKHR", SideEffects::worstDefault, "WRAP_vkGetPipelineExecutablePropertiesKHR")
  ->args({"device", "pPipelineInfo", "pExecutableCount", "pProperties"});
addExtern<DAS_BIND_FUN(WRAP_vkGetPipelineExecutableStatisticsKHR)>(*this, lib, "vkGetPipelineExecutableStatisticsKHR", SideEffects::worstDefault, "WRAP_vkGetPipelineExecutableStatisticsKHR")
  ->args({"device", "pExecutableInfo", "pStatisticCount", "pStatistics"});
#endif /* defined(VK_KHR_pipeline_executable_properties) */
#if defined(VK_KHR_present_wait)
addExtern<DAS_BIND_FUN(WRAP_vkWaitForPresentKHR)>(*this, lib, "vkWaitForPresentKHR", SideEffects::worstDefault, "WRAP_vkWaitForPresentKHR")
  ->args({"device", "swapchain", "presentId", "timeout"});
#endif /* defined(VK_KHR_present_wait) */
#if defined(VK_KHR_push_descriptor)
addExtern<DAS_BIND_FUN(WRAP_vkCmdPushDescriptorSetKHR)>(*this, lib, "vkCmdPushDescriptorSetKHR", SideEffects::worstDefault, "WRAP_vkCmdPushDescriptorSetKHR")
  ->args({"commandBuffer", "pipelineBindPoint", "layout", "set", "descriptorWriteCount", "pDescriptorWrites"});
#endif /* defined(VK_KHR_push_descriptor) */
#if defined(VK_KHR_ray_tracing_maintenance1) && defined(VK_KHR_ray_tracing_pipeline)
addExtern<DAS_BIND_FUN(WRAP_vkCmdTraceRaysIndirect2KHR)>(*this, lib, "vkCmdTraceRaysIndirect2KHR", SideEffects::worstDefault, "WRAP_vkCmdTraceRaysIndirect2KHR")
  ->args({"commandBuffer", "indirectDeviceAddress"});
#endif /* defined(VK_KHR_ray_tracing_maintenance1) && defined(VK_KHR_ray_tracing_pipeline) */
#if defined(VK_KHR_ray_tracing_pipeline)
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetRayTracingPipelineStackSizeKHR)>(*this, lib, "vkCmdSetRayTracingPipelineStackSizeKHR", SideEffects::worstDefault, "WRAP_vkCmdSetRayTracingPipelineStackSizeKHR")
  ->args({"commandBuffer", "pipelineStackSize"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdTraceRaysIndirectKHR)>(*this, lib, "vkCmdTraceRaysIndirectKHR", SideEffects::worstDefault, "WRAP_vkCmdTraceRaysIndirectKHR")
  ->args({"commandBuffer", "pRaygenShaderBindingTable", "pMissShaderBindingTable", "pHitShaderBindingTable", "pCallableShaderBindingTable", "indirectDeviceAddress"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdTraceRaysKHR)>(*this, lib, "vkCmdTraceRaysKHR", SideEffects::worstDefault, "WRAP_vkCmdTraceRaysKHR")
  ->args({"commandBuffer", "pRaygenShaderBindingTable", "pMissShaderBindingTable", "pHitShaderBindingTable", "pCallableShaderBindingTable", "width", "height", "depth"});
addExtern<DAS_BIND_FUN(WRAP_vkCreateRayTracingPipelinesKHR)>(*this, lib, "vkCreateRayTracingPipelinesKHR", SideEffects::worstDefault, "WRAP_vkCreateRayTracingPipelinesKHR")
  ->args({"device", "deferredOperation", "pipelineCache", "createInfoCount", "pCreateInfos", "pAllocator", "pPipelines"});
addExtern<DAS_BIND_FUN(WRAP_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR)>(*this, lib, "vkGetRayTracingCaptureReplayShaderGroupHandlesKHR", SideEffects::worstDefault, "WRAP_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR")
  ->args({"device", "pipeline", "firstGroup", "groupCount", "dataSize", "pData"});
addExtern<DAS_BIND_FUN(WRAP_vkGetRayTracingShaderGroupHandlesKHR)>(*this, lib, "vkGetRayTracingShaderGroupHandlesKHR", SideEffects::worstDefault, "WRAP_vkGetRayTracingShaderGroupHandlesKHR")
  ->args({"device", "pipeline", "firstGroup", "groupCount", "dataSize", "pData"});
addExtern<DAS_BIND_FUN(WRAP_vkGetRayTracingShaderGroupStackSizeKHR)>(*this, lib, "vkGetRayTracingShaderGroupStackSizeKHR", SideEffects::worstDefault, "WRAP_vkGetRayTracingShaderGroupStackSizeKHR")
  ->args({"device", "pipeline", "group", "groupShader"});
#endif /* defined(VK_KHR_ray_tracing_pipeline) */
#if defined(VK_KHR_sampler_ycbcr_conversion)
addExtern<DAS_BIND_FUN(WRAP_vkCreateSamplerYcbcrConversionKHR)>(*this, lib, "vkCreateSamplerYcbcrConversionKHR", SideEffects::worstDefault, "WRAP_vkCreateSamplerYcbcrConversionKHR")
  ->args({"device", "pCreateInfo", "pAllocator", "pYcbcrConversion"});
addExtern<DAS_BIND_FUN(WRAP_vkDestroySamplerYcbcrConversionKHR)>(*this, lib, "vkDestroySamplerYcbcrConversionKHR", SideEffects::worstDefault, "WRAP_vkDestroySamplerYcbcrConversionKHR")
  ->args({"device", "ycbcrConversion", "pAllocator"});
#endif /* defined(VK_KHR_sampler_ycbcr_conversion) */
#if defined(VK_KHR_shared_presentable_image)
addExtern<DAS_BIND_FUN(WRAP_vkGetSwapchainStatusKHR)>(*this, lib, "vkGetSwapchainStatusKHR", SideEffects::worstDefault, "WRAP_vkGetSwapchainStatusKHR")
  ->args({"device", "swapchain"});
#endif /* defined(VK_KHR_shared_presentable_image) */
#if defined(VK_KHR_surface)
addExtern<DAS_BIND_FUN(WRAP_vkDestroySurfaceKHR)>(*this, lib, "vkDestroySurfaceKHR", SideEffects::worstDefault, "WRAP_vkDestroySurfaceKHR")
  ->args({"instance", "surface", "pAllocator"});
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDeviceSurfaceCapabilitiesKHR)>(*this, lib, "vkGetPhysicalDeviceSurfaceCapabilitiesKHR", SideEffects::worstDefault, "WRAP_vkGetPhysicalDeviceSurfaceCapabilitiesKHR")
  ->args({"physicalDevice", "surface", "pSurfaceCapabilities"});
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDeviceSurfaceFormatsKHR)>(*this, lib, "vkGetPhysicalDeviceSurfaceFormatsKHR", SideEffects::worstDefault, "WRAP_vkGetPhysicalDeviceSurfaceFormatsKHR")
  ->args({"physicalDevice", "surface", "pSurfaceFormatCount", "pSurfaceFormats"});
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDeviceSurfacePresentModesKHR)>(*this, lib, "vkGetPhysicalDeviceSurfacePresentModesKHR", SideEffects::worstDefault, "WRAP_vkGetPhysicalDeviceSurfacePresentModesKHR")
  ->args({"physicalDevice", "surface", "pPresentModeCount", "pPresentModes"});
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDeviceSurfaceSupportKHR)>(*this, lib, "vkGetPhysicalDeviceSurfaceSupportKHR", SideEffects::worstDefault, "WRAP_vkGetPhysicalDeviceSurfaceSupportKHR")
  ->args({"physicalDevice", "queueFamilyIndex", "surface", "pSupported"});
#endif /* defined(VK_KHR_surface) */
#if defined(VK_KHR_swapchain)
addExtern<DAS_BIND_FUN(WRAP_vkAcquireNextImageKHR)>(*this, lib, "vkAcquireNextImageKHR", SideEffects::worstDefault, "WRAP_vkAcquireNextImageKHR")
  ->args({"device", "swapchain", "timeout", "semaphore", "fence", "pImageIndex"});
addExtern<DAS_BIND_FUN(WRAP_vkCreateSwapchainKHR)>(*this, lib, "vkCreateSwapchainKHR", SideEffects::worstDefault, "WRAP_vkCreateSwapchainKHR")
  ->args({"device", "pCreateInfo", "pAllocator", "pSwapchain"});
addExtern<DAS_BIND_FUN(WRAP_vkDestroySwapchainKHR)>(*this, lib, "vkDestroySwapchainKHR", SideEffects::worstDefault, "WRAP_vkDestroySwapchainKHR")
  ->args({"device", "swapchain", "pAllocator"});
addExtern<DAS_BIND_FUN(WRAP_vkGetSwapchainImagesKHR)>(*this, lib, "vkGetSwapchainImagesKHR", SideEffects::worstDefault, "WRAP_vkGetSwapchainImagesKHR")
  ->args({"device", "swapchain", "pSwapchainImageCount", "pSwapchainImages"});
addExtern<DAS_BIND_FUN(WRAP_vkQueuePresentKHR)>(*this, lib, "vkQueuePresentKHR", SideEffects::worstDefault, "WRAP_vkQueuePresentKHR")
  ->args({"queue", "pPresentInfo"});
#endif /* defined(VK_KHR_swapchain) */
#if defined(VK_KHR_synchronization2)
addExtern<DAS_BIND_FUN(WRAP_vkCmdPipelineBarrier2KHR)>(*this, lib, "vkCmdPipelineBarrier2KHR", SideEffects::worstDefault, "WRAP_vkCmdPipelineBarrier2KHR")
  ->args({"commandBuffer", "pDependencyInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdResetEvent2KHR)>(*this, lib, "vkCmdResetEvent2KHR", SideEffects::worstDefault, "WRAP_vkCmdResetEvent2KHR")
  ->args({"commandBuffer", "event", "stageMask"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetEvent2KHR)>(*this, lib, "vkCmdSetEvent2KHR", SideEffects::worstDefault, "WRAP_vkCmdSetEvent2KHR")
  ->args({"commandBuffer", "event", "pDependencyInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdWaitEvents2KHR)>(*this, lib, "vkCmdWaitEvents2KHR", SideEffects::worstDefault, "WRAP_vkCmdWaitEvents2KHR")
  ->args({"commandBuffer", "eventCount", "pEvents", "pDependencyInfos"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdWriteTimestamp2KHR)>(*this, lib, "vkCmdWriteTimestamp2KHR", SideEffects::worstDefault, "WRAP_vkCmdWriteTimestamp2KHR")
  ->args({"commandBuffer", "stage", "queryPool", "query"});
addExtern<DAS_BIND_FUN(WRAP_vkQueueSubmit2KHR)>(*this, lib, "vkQueueSubmit2KHR", SideEffects::worstDefault, "WRAP_vkQueueSubmit2KHR")
  ->args({"queue", "submitCount", "pSubmits", "fence"});
#endif /* defined(VK_KHR_synchronization2) */
#if defined(VK_KHR_timeline_semaphore)
addExtern<DAS_BIND_FUN(WRAP_vkGetSemaphoreCounterValueKHR)>(*this, lib, "vkGetSemaphoreCounterValueKHR", SideEffects::worstDefault, "WRAP_vkGetSemaphoreCounterValueKHR")
  ->args({"device", "semaphore", "pValue"});
addExtern<DAS_BIND_FUN(WRAP_vkSignalSemaphoreKHR)>(*this, lib, "vkSignalSemaphoreKHR", SideEffects::worstDefault, "WRAP_vkSignalSemaphoreKHR")
  ->args({"device", "pSignalInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkWaitSemaphoresKHR)>(*this, lib, "vkWaitSemaphoresKHR", SideEffects::worstDefault, "WRAP_vkWaitSemaphoresKHR")
  ->args({"device", "pWaitInfo", "timeout"});
#endif /* defined(VK_KHR_timeline_semaphore) */
#if defined(VK_KHR_video_decode_queue)
addExtern<DAS_BIND_FUN(WRAP_vkCmdDecodeVideoKHR)>(*this, lib, "vkCmdDecodeVideoKHR", SideEffects::worstDefault, "WRAP_vkCmdDecodeVideoKHR")
  ->args({"commandBuffer", "pDecodeInfo"});
#endif /* defined(VK_KHR_video_decode_queue) */
#if defined(VK_KHR_video_encode_queue)
addExtern<DAS_BIND_FUN(WRAP_vkCmdEncodeVideoKHR)>(*this, lib, "vkCmdEncodeVideoKHR", SideEffects::worstDefault, "WRAP_vkCmdEncodeVideoKHR")
  ->args({"commandBuffer", "pEncodeInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkGetEncodedVideoSessionParametersKHR)>(*this, lib, "vkGetEncodedVideoSessionParametersKHR", SideEffects::worstDefault, "WRAP_vkGetEncodedVideoSessionParametersKHR")
  ->args({"device", "pVideoSessionParametersInfo", "pFeedbackInfo", "pDataSize", "pData"});
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR)>(*this, lib, "vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR", SideEffects::worstDefault, "WRAP_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR")
  ->args({"physicalDevice", "pQualityLevelInfo", "pQualityLevelProperties"});
#endif /* defined(VK_KHR_video_encode_queue) */
#if defined(VK_KHR_video_queue)
addExtern<DAS_BIND_FUN(WRAP_vkBindVideoSessionMemoryKHR)>(*this, lib, "vkBindVideoSessionMemoryKHR", SideEffects::worstDefault, "WRAP_vkBindVideoSessionMemoryKHR")
  ->args({"device", "videoSession", "bindSessionMemoryInfoCount", "pBindSessionMemoryInfos"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdBeginVideoCodingKHR)>(*this, lib, "vkCmdBeginVideoCodingKHR", SideEffects::worstDefault, "WRAP_vkCmdBeginVideoCodingKHR")
  ->args({"commandBuffer", "pBeginInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdControlVideoCodingKHR)>(*this, lib, "vkCmdControlVideoCodingKHR", SideEffects::worstDefault, "WRAP_vkCmdControlVideoCodingKHR")
  ->args({"commandBuffer", "pCodingControlInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdEndVideoCodingKHR)>(*this, lib, "vkCmdEndVideoCodingKHR", SideEffects::worstDefault, "WRAP_vkCmdEndVideoCodingKHR")
  ->args({"commandBuffer", "pEndCodingInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCreateVideoSessionKHR)>(*this, lib, "vkCreateVideoSessionKHR", SideEffects::worstDefault, "WRAP_vkCreateVideoSessionKHR")
  ->args({"device", "pCreateInfo", "pAllocator", "pVideoSession"});
addExtern<DAS_BIND_FUN(WRAP_vkCreateVideoSessionParametersKHR)>(*this, lib, "vkCreateVideoSessionParametersKHR", SideEffects::worstDefault, "WRAP_vkCreateVideoSessionParametersKHR")
  ->args({"device", "pCreateInfo", "pAllocator", "pVideoSessionParameters"});
addExtern<DAS_BIND_FUN(WRAP_vkDestroyVideoSessionKHR)>(*this, lib, "vkDestroyVideoSessionKHR", SideEffects::worstDefault, "WRAP_vkDestroyVideoSessionKHR")
  ->args({"device", "videoSession", "pAllocator"});
addExtern<DAS_BIND_FUN(WRAP_vkDestroyVideoSessionParametersKHR)>(*this, lib, "vkDestroyVideoSessionParametersKHR", SideEffects::worstDefault, "WRAP_vkDestroyVideoSessionParametersKHR")
  ->args({"device", "videoSessionParameters", "pAllocator"});
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDeviceVideoCapabilitiesKHR)>(*this, lib, "vkGetPhysicalDeviceVideoCapabilitiesKHR", SideEffects::worstDefault, "WRAP_vkGetPhysicalDeviceVideoCapabilitiesKHR")
  ->args({"physicalDevice", "pVideoProfile", "pCapabilities"});
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDeviceVideoFormatPropertiesKHR)>(*this, lib, "vkGetPhysicalDeviceVideoFormatPropertiesKHR", SideEffects::worstDefault, "WRAP_vkGetPhysicalDeviceVideoFormatPropertiesKHR")
  ->args({"physicalDevice", "pVideoFormatInfo", "pVideoFormatPropertyCount", "pVideoFormatProperties"});
addExtern<DAS_BIND_FUN(WRAP_vkGetVideoSessionMemoryRequirementsKHR)>(*this, lib, "vkGetVideoSessionMemoryRequirementsKHR", SideEffects::worstDefault, "WRAP_vkGetVideoSessionMemoryRequirementsKHR")
  ->args({"device", "videoSession", "pMemoryRequirementsCount", "pMemoryRequirements"});
addExtern<DAS_BIND_FUN(WRAP_vkUpdateVideoSessionParametersKHR)>(*this, lib, "vkUpdateVideoSessionParametersKHR", SideEffects::worstDefault, "WRAP_vkUpdateVideoSessionParametersKHR")
  ->args({"device", "videoSessionParameters", "pUpdateInfo"});
#endif /* defined(VK_KHR_video_queue) */
#if defined(VK_KHR_wayland_surface)
addExtern<DAS_BIND_FUN(WRAP_vkCreateWaylandSurfaceKHR)>(*this, lib, "vkCreateWaylandSurfaceKHR", SideEffects::worstDefault, "WRAP_vkCreateWaylandSurfaceKHR")
  ->args({"instance", "pCreateInfo", "pAllocator", "pSurface"});
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDeviceWaylandPresentationSupportKHR)>(*this, lib, "vkGetPhysicalDeviceWaylandPresentationSupportKHR", SideEffects::worstDefault, "WRAP_vkGetPhysicalDeviceWaylandPresentationSupportKHR")
  ->args({"physicalDevice", "queueFamilyIndex", "display"});
#endif /* defined(VK_KHR_wayland_surface) */
#if defined(VK_KHR_win32_surface)
addExtern<DAS_BIND_FUN(WRAP_vkCreateWin32SurfaceKHR)>(*this, lib, "vkCreateWin32SurfaceKHR", SideEffects::worstDefault, "WRAP_vkCreateWin32SurfaceKHR")
  ->args({"instance", "pCreateInfo", "pAllocator", "pSurface"});
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDeviceWin32PresentationSupportKHR)>(*this, lib, "vkGetPhysicalDeviceWin32PresentationSupportKHR", SideEffects::worstDefault, "WRAP_vkGetPhysicalDeviceWin32PresentationSupportKHR")
  ->args({"physicalDevice", "queueFamilyIndex"});
#endif /* defined(VK_KHR_win32_surface) */
#if defined(VK_KHR_xcb_surface)
addExtern<DAS_BIND_FUN(WRAP_vkCreateXcbSurfaceKHR)>(*this, lib, "vkCreateXcbSurfaceKHR", SideEffects::worstDefault, "WRAP_vkCreateXcbSurfaceKHR")
  ->args({"instance", "pCreateInfo", "pAllocator", "pSurface"});
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDeviceXcbPresentationSupportKHR)>(*this, lib, "vkGetPhysicalDeviceXcbPresentationSupportKHR", SideEffects::worstDefault, "WRAP_vkGetPhysicalDeviceXcbPresentationSupportKHR")
  ->args({"physicalDevice", "queueFamilyIndex", "connection", "visual_id"});
#endif /* defined(VK_KHR_xcb_surface) */
#if defined(VK_KHR_xlib_surface)
addExtern<DAS_BIND_FUN(WRAP_vkCreateXlibSurfaceKHR)>(*this, lib, "vkCreateXlibSurfaceKHR", SideEffects::worstDefault, "WRAP_vkCreateXlibSurfaceKHR")
  ->args({"instance", "pCreateInfo", "pAllocator", "pSurface"});
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDeviceXlibPresentationSupportKHR)>(*this, lib, "vkGetPhysicalDeviceXlibPresentationSupportKHR", SideEffects::worstDefault, "WRAP_vkGetPhysicalDeviceXlibPresentationSupportKHR")
  ->args({"physicalDevice", "queueFamilyIndex", "dpy", "visualID"});
#endif /* defined(VK_KHR_xlib_surface) */
#if defined(VK_MVK_ios_surface)
addExtern<DAS_BIND_FUN(WRAP_vkCreateIOSSurfaceMVK)>(*this, lib, "vkCreateIOSSurfaceMVK", SideEffects::worstDefault, "WRAP_vkCreateIOSSurfaceMVK")
  ->args({"instance", "pCreateInfo", "pAllocator", "pSurface"});
#endif /* defined(VK_MVK_ios_surface) */
#if defined(VK_MVK_macos_surface)
addExtern<DAS_BIND_FUN(WRAP_vkCreateMacOSSurfaceMVK)>(*this, lib, "vkCreateMacOSSurfaceMVK", SideEffects::worstDefault, "WRAP_vkCreateMacOSSurfaceMVK")
  ->args({"instance", "pCreateInfo", "pAllocator", "pSurface"});
#endif /* defined(VK_MVK_macos_surface) */
#if defined(VK_NN_vi_surface)
addExtern<DAS_BIND_FUN(WRAP_vkCreateViSurfaceNN)>(*this, lib, "vkCreateViSurfaceNN", SideEffects::worstDefault, "WRAP_vkCreateViSurfaceNN")
  ->args({"instance", "pCreateInfo", "pAllocator", "pSurface"});
#endif /* defined(VK_NN_vi_surface) */
#if defined(VK_NVX_binary_import)
addExtern<DAS_BIND_FUN(WRAP_vkCmdCuLaunchKernelNVX)>(*this, lib, "vkCmdCuLaunchKernelNVX", SideEffects::worstDefault, "WRAP_vkCmdCuLaunchKernelNVX")
  ->args({"commandBuffer", "pLaunchInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCreateCuFunctionNVX)>(*this, lib, "vkCreateCuFunctionNVX", SideEffects::worstDefault, "WRAP_vkCreateCuFunctionNVX")
  ->args({"device", "pCreateInfo", "pAllocator", "pFunction"});
addExtern<DAS_BIND_FUN(WRAP_vkCreateCuModuleNVX)>(*this, lib, "vkCreateCuModuleNVX", SideEffects::worstDefault, "WRAP_vkCreateCuModuleNVX")
  ->args({"device", "pCreateInfo", "pAllocator", "pModule"});
addExtern<DAS_BIND_FUN(WRAP_vkDestroyCuFunctionNVX)>(*this, lib, "vkDestroyCuFunctionNVX", SideEffects::worstDefault, "WRAP_vkDestroyCuFunctionNVX")
  ->args({"device", "function", "pAllocator"});
addExtern<DAS_BIND_FUN(WRAP_vkDestroyCuModuleNVX)>(*this, lib, "vkDestroyCuModuleNVX", SideEffects::worstDefault, "WRAP_vkDestroyCuModuleNVX")
  ->args({"device", "module", "pAllocator"});
#endif /* defined(VK_NVX_binary_import) */
#if defined(VK_NVX_image_view_handle)
addExtern<DAS_BIND_FUN(WRAP_vkGetImageViewAddressNVX)>(*this, lib, "vkGetImageViewAddressNVX", SideEffects::worstDefault, "WRAP_vkGetImageViewAddressNVX")
  ->args({"device", "imageView", "pProperties"});
addExtern<DAS_BIND_FUN(WRAP_vkGetImageViewHandle64NVX)>(*this, lib, "vkGetImageViewHandle64NVX", SideEffects::worstDefault, "WRAP_vkGetImageViewHandle64NVX")
  ->args({"device", "pInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkGetImageViewHandleNVX)>(*this, lib, "vkGetImageViewHandleNVX", SideEffects::worstDefault, "WRAP_vkGetImageViewHandleNVX")
  ->args({"device", "pInfo"});
#endif /* defined(VK_NVX_image_view_handle) */
#if defined(VK_NV_acquire_winrt_display)
addExtern<DAS_BIND_FUN(WRAP_vkAcquireWinrtDisplayNV)>(*this, lib, "vkAcquireWinrtDisplayNV", SideEffects::worstDefault, "WRAP_vkAcquireWinrtDisplayNV")
  ->args({"physicalDevice", "display"});
addExtern<DAS_BIND_FUN(WRAP_vkGetWinrtDisplayNV)>(*this, lib, "vkGetWinrtDisplayNV", SideEffects::worstDefault, "WRAP_vkGetWinrtDisplayNV")
  ->args({"physicalDevice", "deviceRelativeId", "pDisplay"});
#endif /* defined(VK_NV_acquire_winrt_display) */
#if defined(VK_NV_clip_space_w_scaling)
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetViewportWScalingNV)>(*this, lib, "vkCmdSetViewportWScalingNV", SideEffects::worstDefault, "WRAP_vkCmdSetViewportWScalingNV")
  ->args({"commandBuffer", "firstViewport", "viewportCount", "pViewportWScalings"});
#endif /* defined(VK_NV_clip_space_w_scaling) */
#if defined(VK_NV_cooperative_matrix)
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV)>(*this, lib, "vkGetPhysicalDeviceCooperativeMatrixPropertiesNV", SideEffects::worstDefault, "WRAP_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV")
  ->args({"physicalDevice", "pPropertyCount", "pProperties"});
#endif /* defined(VK_NV_cooperative_matrix) */
#if defined(VK_NV_cooperative_matrix2)
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV)>(*this, lib, "vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV", SideEffects::worstDefault, "WRAP_vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV")
  ->args({"physicalDevice", "pPropertyCount", "pProperties"});
#endif /* defined(VK_NV_cooperative_matrix2) */
#if defined(VK_NV_copy_memory_indirect)
addExtern<DAS_BIND_FUN(WRAP_vkCmdCopyMemoryIndirectNV)>(*this, lib, "vkCmdCopyMemoryIndirectNV", SideEffects::worstDefault, "WRAP_vkCmdCopyMemoryIndirectNV")
  ->args({"commandBuffer", "copyBufferAddress", "copyCount", "stride"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdCopyMemoryToImageIndirectNV)>(*this, lib, "vkCmdCopyMemoryToImageIndirectNV", SideEffects::worstDefault, "WRAP_vkCmdCopyMemoryToImageIndirectNV")
  ->args({"commandBuffer", "copyBufferAddress", "copyCount", "stride", "dstImage", "dstImageLayout", "pImageSubresources"});
#endif /* defined(VK_NV_copy_memory_indirect) */
#if defined(VK_NV_coverage_reduction_mode)
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV)>(*this, lib, "vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV", SideEffects::worstDefault, "WRAP_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV")
  ->args({"physicalDevice", "pCombinationCount", "pCombinations"});
#endif /* defined(VK_NV_coverage_reduction_mode) */
#if defined(VK_NV_cuda_kernel_launch)
addExtern<DAS_BIND_FUN(WRAP_vkCmdCudaLaunchKernelNV)>(*this, lib, "vkCmdCudaLaunchKernelNV", SideEffects::worstDefault, "WRAP_vkCmdCudaLaunchKernelNV")
  ->args({"commandBuffer", "pLaunchInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCreateCudaFunctionNV)>(*this, lib, "vkCreateCudaFunctionNV", SideEffects::worstDefault, "WRAP_vkCreateCudaFunctionNV")
  ->args({"device", "pCreateInfo", "pAllocator", "pFunction"});
addExtern<DAS_BIND_FUN(WRAP_vkCreateCudaModuleNV)>(*this, lib, "vkCreateCudaModuleNV", SideEffects::worstDefault, "WRAP_vkCreateCudaModuleNV")
  ->args({"device", "pCreateInfo", "pAllocator", "pModule"});
addExtern<DAS_BIND_FUN(WRAP_vkDestroyCudaFunctionNV)>(*this, lib, "vkDestroyCudaFunctionNV", SideEffects::worstDefault, "WRAP_vkDestroyCudaFunctionNV")
  ->args({"device", "function", "pAllocator"});
addExtern<DAS_BIND_FUN(WRAP_vkDestroyCudaModuleNV)>(*this, lib, "vkDestroyCudaModuleNV", SideEffects::worstDefault, "WRAP_vkDestroyCudaModuleNV")
  ->args({"device", "module", "pAllocator"});
addExtern<DAS_BIND_FUN(WRAP_vkGetCudaModuleCacheNV)>(*this, lib, "vkGetCudaModuleCacheNV", SideEffects::worstDefault, "WRAP_vkGetCudaModuleCacheNV")
  ->args({"device", "module", "pCacheSize", "pCacheData"});
#endif /* defined(VK_NV_cuda_kernel_launch) */
#if defined(VK_NV_device_diagnostic_checkpoints)
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetCheckpointNV)>(*this, lib, "vkCmdSetCheckpointNV", SideEffects::worstDefault, "WRAP_vkCmdSetCheckpointNV")
  ->args({"commandBuffer", "pCheckpointMarker"});
addExtern<DAS_BIND_FUN(WRAP_vkGetQueueCheckpointDataNV)>(*this, lib, "vkGetQueueCheckpointDataNV", SideEffects::worstDefault, "WRAP_vkGetQueueCheckpointDataNV")
  ->args({"queue", "pCheckpointDataCount", "pCheckpointData"});
#endif /* defined(VK_NV_device_diagnostic_checkpoints) */
#if defined(VK_NV_device_diagnostic_checkpoints) && (defined(VK_VERSION_1_3) || defined(VK_KHR_synchronization2))
addExtern<DAS_BIND_FUN(WRAP_vkGetQueueCheckpointData2NV)>(*this, lib, "vkGetQueueCheckpointData2NV", SideEffects::worstDefault, "WRAP_vkGetQueueCheckpointData2NV")
  ->args({"queue", "pCheckpointDataCount", "pCheckpointData"});
#endif /* defined(VK_NV_device_diagnostic_checkpoints) && (defined(VK_VERSION_1_3) || defined(VK_KHR_synchronization2)) */
#if defined(VK_NV_device_generated_commands)
addExtern<DAS_BIND_FUN(WRAP_vkCmdBindPipelineShaderGroupNV)>(*this, lib, "vkCmdBindPipelineShaderGroupNV", SideEffects::worstDefault, "WRAP_vkCmdBindPipelineShaderGroupNV")
  ->args({"commandBuffer", "pipelineBindPoint", "pipeline", "groupIndex"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdExecuteGeneratedCommandsNV)>(*this, lib, "vkCmdExecuteGeneratedCommandsNV", SideEffects::worstDefault, "WRAP_vkCmdExecuteGeneratedCommandsNV")
  ->args({"commandBuffer", "isPreprocessed", "pGeneratedCommandsInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdPreprocessGeneratedCommandsNV)>(*this, lib, "vkCmdPreprocessGeneratedCommandsNV", SideEffects::worstDefault, "WRAP_vkCmdPreprocessGeneratedCommandsNV")
  ->args({"commandBuffer", "pGeneratedCommandsInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCreateIndirectCommandsLayoutNV)>(*this, lib, "vkCreateIndirectCommandsLayoutNV", SideEffects::worstDefault, "WRAP_vkCreateIndirectCommandsLayoutNV")
  ->args({"device", "pCreateInfo", "pAllocator", "pIndirectCommandsLayout"});
addExtern<DAS_BIND_FUN(WRAP_vkDestroyIndirectCommandsLayoutNV)>(*this, lib, "vkDestroyIndirectCommandsLayoutNV", SideEffects::worstDefault, "WRAP_vkDestroyIndirectCommandsLayoutNV")
  ->args({"device", "indirectCommandsLayout", "pAllocator"});
addExtern<DAS_BIND_FUN(WRAP_vkGetGeneratedCommandsMemoryRequirementsNV)>(*this, lib, "vkGetGeneratedCommandsMemoryRequirementsNV", SideEffects::worstDefault, "WRAP_vkGetGeneratedCommandsMemoryRequirementsNV")
  ->args({"device", "pInfo", "pMemoryRequirements"});
#endif /* defined(VK_NV_device_generated_commands) */
#if defined(VK_NV_device_generated_commands_compute)
addExtern<DAS_BIND_FUN(WRAP_vkCmdUpdatePipelineIndirectBufferNV)>(*this, lib, "vkCmdUpdatePipelineIndirectBufferNV", SideEffects::worstDefault, "WRAP_vkCmdUpdatePipelineIndirectBufferNV")
  ->args({"commandBuffer", "pipelineBindPoint", "pipeline"});
addExtern<DAS_BIND_FUN(WRAP_vkGetPipelineIndirectDeviceAddressNV)>(*this, lib, "vkGetPipelineIndirectDeviceAddressNV", SideEffects::worstDefault, "WRAP_vkGetPipelineIndirectDeviceAddressNV")
  ->args({"device", "pInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkGetPipelineIndirectMemoryRequirementsNV)>(*this, lib, "vkGetPipelineIndirectMemoryRequirementsNV", SideEffects::worstDefault, "WRAP_vkGetPipelineIndirectMemoryRequirementsNV")
  ->args({"device", "pCreateInfo", "pMemoryRequirements"});
#endif /* defined(VK_NV_device_generated_commands_compute) */
#if defined(VK_NV_external_memory_capabilities)
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDeviceExternalImageFormatPropertiesNV)>(*this, lib, "vkGetPhysicalDeviceExternalImageFormatPropertiesNV", SideEffects::worstDefault, "WRAP_vkGetPhysicalDeviceExternalImageFormatPropertiesNV")
  ->args({"physicalDevice", "format", "type", "tiling", "usage", "flags", "externalHandleType", "pExternalImageFormatProperties"});
#endif /* defined(VK_NV_external_memory_capabilities) */
#if defined(VK_NV_external_memory_rdma)
addExtern<DAS_BIND_FUN(WRAP_vkGetMemoryRemoteAddressNV)>(*this, lib, "vkGetMemoryRemoteAddressNV", SideEffects::worstDefault, "WRAP_vkGetMemoryRemoteAddressNV")
  ->args({"device", "pMemoryGetRemoteAddressInfo", "pAddress"});
#endif /* defined(VK_NV_external_memory_rdma) */
#if defined(VK_NV_external_memory_win32)
addExtern<DAS_BIND_FUN(WRAP_vkGetMemoryWin32HandleNV)>(*this, lib, "vkGetMemoryWin32HandleNV", SideEffects::worstDefault, "WRAP_vkGetMemoryWin32HandleNV")
  ->args({"device", "memory", "handleType", "pHandle"});
#endif /* defined(VK_NV_external_memory_win32) */
#if defined(VK_NV_fragment_shading_rate_enums)
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetFragmentShadingRateEnumNV)>(*this, lib, "vkCmdSetFragmentShadingRateEnumNV", SideEffects::worstDefault, "WRAP_vkCmdSetFragmentShadingRateEnumNV")
  ->args({"commandBuffer", "shadingRate", "combinerOps"});
#endif /* defined(VK_NV_fragment_shading_rate_enums) */
#if defined(VK_NV_low_latency2)
addExtern<DAS_BIND_FUN(WRAP_vkGetLatencyTimingsNV)>(*this, lib, "vkGetLatencyTimingsNV", SideEffects::worstDefault, "WRAP_vkGetLatencyTimingsNV")
  ->args({"device", "swapchain", "pLatencyMarkerInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkLatencySleepNV)>(*this, lib, "vkLatencySleepNV", SideEffects::worstDefault, "WRAP_vkLatencySleepNV")
  ->args({"device", "swapchain", "pSleepInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkQueueNotifyOutOfBandNV)>(*this, lib, "vkQueueNotifyOutOfBandNV", SideEffects::worstDefault, "WRAP_vkQueueNotifyOutOfBandNV")
  ->args({"queue", "pQueueTypeInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkSetLatencyMarkerNV)>(*this, lib, "vkSetLatencyMarkerNV", SideEffects::worstDefault, "WRAP_vkSetLatencyMarkerNV")
  ->args({"device", "swapchain", "pLatencyMarkerInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkSetLatencySleepModeNV)>(*this, lib, "vkSetLatencySleepModeNV", SideEffects::worstDefault, "WRAP_vkSetLatencySleepModeNV")
  ->args({"device", "swapchain", "pSleepModeInfo"});
#endif /* defined(VK_NV_low_latency2) */
#if defined(VK_NV_memory_decompression)
addExtern<DAS_BIND_FUN(WRAP_vkCmdDecompressMemoryIndirectCountNV)>(*this, lib, "vkCmdDecompressMemoryIndirectCountNV", SideEffects::worstDefault, "WRAP_vkCmdDecompressMemoryIndirectCountNV")
  ->args({"commandBuffer", "indirectCommandsAddress", "indirectCommandsCountAddress", "stride"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdDecompressMemoryNV)>(*this, lib, "vkCmdDecompressMemoryNV", SideEffects::worstDefault, "WRAP_vkCmdDecompressMemoryNV")
  ->args({"commandBuffer", "decompressRegionCount", "pDecompressMemoryRegions"});
#endif /* defined(VK_NV_memory_decompression) */
#if defined(VK_NV_mesh_shader)
addExtern<DAS_BIND_FUN(WRAP_vkCmdDrawMeshTasksIndirectCountNV)>(*this, lib, "vkCmdDrawMeshTasksIndirectCountNV", SideEffects::worstDefault, "WRAP_vkCmdDrawMeshTasksIndirectCountNV")
  ->args({"commandBuffer", "buffer", "offset", "countBuffer", "countBufferOffset", "maxDrawCount", "stride"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdDrawMeshTasksIndirectNV)>(*this, lib, "vkCmdDrawMeshTasksIndirectNV", SideEffects::worstDefault, "WRAP_vkCmdDrawMeshTasksIndirectNV")
  ->args({"commandBuffer", "buffer", "offset", "drawCount", "stride"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdDrawMeshTasksNV)>(*this, lib, "vkCmdDrawMeshTasksNV", SideEffects::worstDefault, "WRAP_vkCmdDrawMeshTasksNV")
  ->args({"commandBuffer", "taskCount", "firstTask"});
#endif /* defined(VK_NV_mesh_shader) */
#if defined(VK_NV_optical_flow)
addExtern<DAS_BIND_FUN(WRAP_vkBindOpticalFlowSessionImageNV)>(*this, lib, "vkBindOpticalFlowSessionImageNV", SideEffects::worstDefault, "WRAP_vkBindOpticalFlowSessionImageNV")
  ->args({"device", "session", "bindingPoint", "view", "layout"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdOpticalFlowExecuteNV)>(*this, lib, "vkCmdOpticalFlowExecuteNV", SideEffects::worstDefault, "WRAP_vkCmdOpticalFlowExecuteNV")
  ->args({"commandBuffer", "session", "pExecuteInfo"});
addExtern<DAS_BIND_FUN(WRAP_vkCreateOpticalFlowSessionNV)>(*this, lib, "vkCreateOpticalFlowSessionNV", SideEffects::worstDefault, "WRAP_vkCreateOpticalFlowSessionNV")
  ->args({"device", "pCreateInfo", "pAllocator", "pSession"});
addExtern<DAS_BIND_FUN(WRAP_vkDestroyOpticalFlowSessionNV)>(*this, lib, "vkDestroyOpticalFlowSessionNV", SideEffects::worstDefault, "WRAP_vkDestroyOpticalFlowSessionNV")
  ->args({"device", "session", "pAllocator"});
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDeviceOpticalFlowImageFormatsNV)>(*this, lib, "vkGetPhysicalDeviceOpticalFlowImageFormatsNV", SideEffects::worstDefault, "WRAP_vkGetPhysicalDeviceOpticalFlowImageFormatsNV")
  ->args({"physicalDevice", "pOpticalFlowImageFormatInfo", "pFormatCount", "pImageFormatProperties"});
#endif /* defined(VK_NV_optical_flow) */
#if defined(VK_NV_ray_tracing)
addExtern<DAS_BIND_FUN(WRAP_vkBindAccelerationStructureMemoryNV)>(*this, lib, "vkBindAccelerationStructureMemoryNV", SideEffects::worstDefault, "WRAP_vkBindAccelerationStructureMemoryNV")
  ->args({"device", "bindInfoCount", "pBindInfos"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdBuildAccelerationStructureNV)>(*this, lib, "vkCmdBuildAccelerationStructureNV", SideEffects::worstDefault, "WRAP_vkCmdBuildAccelerationStructureNV")
  ->args({"commandBuffer", "pInfo", "instanceData", "instanceOffset", "update", "dst", "src", "scratch", "scratchOffset"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdCopyAccelerationStructureNV)>(*this, lib, "vkCmdCopyAccelerationStructureNV", SideEffects::worstDefault, "WRAP_vkCmdCopyAccelerationStructureNV")
  ->args({"commandBuffer", "dst", "src", "mode"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdTraceRaysNV)>(*this, lib, "vkCmdTraceRaysNV", SideEffects::worstDefault, "WRAP_vkCmdTraceRaysNV")
  ->args({"commandBuffer", "raygenShaderBindingTableBuffer", "raygenShaderBindingOffset", "missShaderBindingTableBuffer", "missShaderBindingOffset", "missShaderBindingStride", "hitShaderBindingTableBuffer", "hitShaderBindingOffset", "hitShaderBindingStride", "callableShaderBindingTableBuffer", "callableShaderBindingOffset", "callableShaderBindingStride", "width", "height", "depth"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdWriteAccelerationStructuresPropertiesNV)>(*this, lib, "vkCmdWriteAccelerationStructuresPropertiesNV", SideEffects::worstDefault, "WRAP_vkCmdWriteAccelerationStructuresPropertiesNV")
  ->args({"commandBuffer", "accelerationStructureCount", "pAccelerationStructures", "queryType", "queryPool", "firstQuery"});
addExtern<DAS_BIND_FUN(WRAP_vkCompileDeferredNV)>(*this, lib, "vkCompileDeferredNV", SideEffects::worstDefault, "WRAP_vkCompileDeferredNV")
  ->args({"device", "pipeline", "shader"});
addExtern<DAS_BIND_FUN(WRAP_vkCreateAccelerationStructureNV)>(*this, lib, "vkCreateAccelerationStructureNV", SideEffects::worstDefault, "WRAP_vkCreateAccelerationStructureNV")
  ->args({"device", "pCreateInfo", "pAllocator", "pAccelerationStructure"});
addExtern<DAS_BIND_FUN(WRAP_vkCreateRayTracingPipelinesNV)>(*this, lib, "vkCreateRayTracingPipelinesNV", SideEffects::worstDefault, "WRAP_vkCreateRayTracingPipelinesNV")
  ->args({"device", "pipelineCache", "createInfoCount", "pCreateInfos", "pAllocator", "pPipelines"});
addExtern<DAS_BIND_FUN(WRAP_vkDestroyAccelerationStructureNV)>(*this, lib, "vkDestroyAccelerationStructureNV", SideEffects::worstDefault, "WRAP_vkDestroyAccelerationStructureNV")
  ->args({"device", "accelerationStructure", "pAllocator"});
addExtern<DAS_BIND_FUN(WRAP_vkGetAccelerationStructureHandleNV)>(*this, lib, "vkGetAccelerationStructureHandleNV", SideEffects::worstDefault, "WRAP_vkGetAccelerationStructureHandleNV")
  ->args({"device", "accelerationStructure", "dataSize", "pData"});
addExtern<DAS_BIND_FUN(WRAP_vkGetAccelerationStructureMemoryRequirementsNV)>(*this, lib, "vkGetAccelerationStructureMemoryRequirementsNV", SideEffects::worstDefault, "WRAP_vkGetAccelerationStructureMemoryRequirementsNV")
  ->args({"device", "pInfo", "pMemoryRequirements"});
addExtern<DAS_BIND_FUN(WRAP_vkGetRayTracingShaderGroupHandlesNV)>(*this, lib, "vkGetRayTracingShaderGroupHandlesNV", SideEffects::worstDefault, "WRAP_vkGetRayTracingShaderGroupHandlesNV")
  ->args({"device", "pipeline", "firstGroup", "groupCount", "dataSize", "pData"});
#endif /* defined(VK_NV_ray_tracing) */
#if defined(VK_NV_scissor_exclusive) && VK_NV_SCISSOR_EXCLUSIVE_SPEC_VERSION >= 2
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetExclusiveScissorEnableNV)>(*this, lib, "vkCmdSetExclusiveScissorEnableNV", SideEffects::worstDefault, "WRAP_vkCmdSetExclusiveScissorEnableNV")
  ->args({"commandBuffer", "firstExclusiveScissor", "exclusiveScissorCount", "pExclusiveScissorEnables"});
#endif /* defined(VK_NV_scissor_exclusive) && VK_NV_SCISSOR_EXCLUSIVE_SPEC_VERSION >= 2 */
#if defined(VK_NV_scissor_exclusive)
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetExclusiveScissorNV)>(*this, lib, "vkCmdSetExclusiveScissorNV", SideEffects::worstDefault, "WRAP_vkCmdSetExclusiveScissorNV")
  ->args({"commandBuffer", "firstExclusiveScissor", "exclusiveScissorCount", "pExclusiveScissors"});
#endif /* defined(VK_NV_scissor_exclusive) */
#if defined(VK_NV_shading_rate_image)
addExtern<DAS_BIND_FUN(WRAP_vkCmdBindShadingRateImageNV)>(*this, lib, "vkCmdBindShadingRateImageNV", SideEffects::worstDefault, "WRAP_vkCmdBindShadingRateImageNV")
  ->args({"commandBuffer", "imageView", "imageLayout"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetCoarseSampleOrderNV)>(*this, lib, "vkCmdSetCoarseSampleOrderNV", SideEffects::worstDefault, "WRAP_vkCmdSetCoarseSampleOrderNV")
  ->args({"commandBuffer", "sampleOrderType", "customSampleOrderCount", "pCustomSampleOrders"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetViewportShadingRatePaletteNV)>(*this, lib, "vkCmdSetViewportShadingRatePaletteNV", SideEffects::worstDefault, "WRAP_vkCmdSetViewportShadingRatePaletteNV")
  ->args({"commandBuffer", "firstViewport", "viewportCount", "pShadingRatePalettes"});
#endif /* defined(VK_NV_shading_rate_image) */
#if defined(VK_QCOM_tile_properties)
addExtern<DAS_BIND_FUN(WRAP_vkGetDynamicRenderingTilePropertiesQCOM)>(*this, lib, "vkGetDynamicRenderingTilePropertiesQCOM", SideEffects::worstDefault, "WRAP_vkGetDynamicRenderingTilePropertiesQCOM")
  ->args({"device", "pRenderingInfo", "pProperties"});
addExtern<DAS_BIND_FUN(WRAP_vkGetFramebufferTilePropertiesQCOM)>(*this, lib, "vkGetFramebufferTilePropertiesQCOM", SideEffects::worstDefault, "WRAP_vkGetFramebufferTilePropertiesQCOM")
  ->args({"device", "framebuffer", "pPropertiesCount", "pProperties"});
#endif /* defined(VK_QCOM_tile_properties) */
#if defined(VK_QNX_external_memory_screen_buffer)
addExtern<DAS_BIND_FUN(WRAP_vkGetScreenBufferPropertiesQNX)>(*this, lib, "vkGetScreenBufferPropertiesQNX", SideEffects::worstDefault, "WRAP_vkGetScreenBufferPropertiesQNX")
  ->args({"device", "buffer", "pProperties"});
#endif /* defined(VK_QNX_external_memory_screen_buffer) */
#if defined(VK_QNX_screen_surface)
addExtern<DAS_BIND_FUN(WRAP_vkCreateScreenSurfaceQNX)>(*this, lib, "vkCreateScreenSurfaceQNX", SideEffects::worstDefault, "WRAP_vkCreateScreenSurfaceQNX")
  ->args({"instance", "pCreateInfo", "pAllocator", "pSurface"});
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDeviceScreenPresentationSupportQNX)>(*this, lib, "vkGetPhysicalDeviceScreenPresentationSupportQNX", SideEffects::worstDefault, "WRAP_vkGetPhysicalDeviceScreenPresentationSupportQNX")
  ->args({"physicalDevice", "queueFamilyIndex", "window"});
#endif /* defined(VK_QNX_screen_surface) */
#if defined(VK_VALVE_descriptor_set_host_mapping)
addExtern<DAS_BIND_FUN(WRAP_vkGetDescriptorSetHostMappingVALVE)>(*this, lib, "vkGetDescriptorSetHostMappingVALVE", SideEffects::worstDefault, "WRAP_vkGetDescriptorSetHostMappingVALVE")
  ->args({"device", "descriptorSet", "ppData"});
addExtern<DAS_BIND_FUN(WRAP_vkGetDescriptorSetLayoutHostMappingInfoVALVE)>(*this, lib, "vkGetDescriptorSetLayoutHostMappingInfoVALVE", SideEffects::worstDefault, "WRAP_vkGetDescriptorSetLayoutHostMappingInfoVALVE")
  ->args({"device", "pBindingReference", "pHostMapping"});
#endif /* defined(VK_VALVE_descriptor_set_host_mapping) */
#if (defined(VK_EXT_depth_clamp_control)) || (defined(VK_EXT_shader_object) && defined(VK_EXT_depth_clamp_control))
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetDepthClampRangeEXT)>(*this, lib, "vkCmdSetDepthClampRangeEXT", SideEffects::worstDefault, "WRAP_vkCmdSetDepthClampRangeEXT")
  ->args({"commandBuffer", "depthClampMode", "pDepthClampRange"});
#endif /* (defined(VK_EXT_depth_clamp_control)) || (defined(VK_EXT_shader_object) && defined(VK_EXT_depth_clamp_control)) */
#if (defined(VK_EXT_extended_dynamic_state)) || (defined(VK_EXT_shader_object))
addExtern<DAS_BIND_FUN(WRAP_vkCmdBindVertexBuffers2EXT)>(*this, lib, "vkCmdBindVertexBuffers2EXT", SideEffects::worstDefault, "WRAP_vkCmdBindVertexBuffers2EXT")
  ->args({"commandBuffer", "firstBinding", "bindingCount", "pBuffers", "pOffsets", "pSizes", "pStrides"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetCullModeEXT)>(*this, lib, "vkCmdSetCullModeEXT", SideEffects::worstDefault, "WRAP_vkCmdSetCullModeEXT")
  ->args({"commandBuffer", "cullMode"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetDepthBoundsTestEnableEXT)>(*this, lib, "vkCmdSetDepthBoundsTestEnableEXT", SideEffects::worstDefault, "WRAP_vkCmdSetDepthBoundsTestEnableEXT")
  ->args({"commandBuffer", "depthBoundsTestEnable"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetDepthCompareOpEXT)>(*this, lib, "vkCmdSetDepthCompareOpEXT", SideEffects::worstDefault, "WRAP_vkCmdSetDepthCompareOpEXT")
  ->args({"commandBuffer", "depthCompareOp"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetDepthTestEnableEXT)>(*this, lib, "vkCmdSetDepthTestEnableEXT", SideEffects::worstDefault, "WRAP_vkCmdSetDepthTestEnableEXT")
  ->args({"commandBuffer", "depthTestEnable"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetDepthWriteEnableEXT)>(*this, lib, "vkCmdSetDepthWriteEnableEXT", SideEffects::worstDefault, "WRAP_vkCmdSetDepthWriteEnableEXT")
  ->args({"commandBuffer", "depthWriteEnable"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetFrontFaceEXT)>(*this, lib, "vkCmdSetFrontFaceEXT", SideEffects::worstDefault, "WRAP_vkCmdSetFrontFaceEXT")
  ->args({"commandBuffer", "frontFace"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetPrimitiveTopologyEXT)>(*this, lib, "vkCmdSetPrimitiveTopologyEXT", SideEffects::worstDefault, "WRAP_vkCmdSetPrimitiveTopologyEXT")
  ->args({"commandBuffer", "primitiveTopology"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetScissorWithCountEXT)>(*this, lib, "vkCmdSetScissorWithCountEXT", SideEffects::worstDefault, "WRAP_vkCmdSetScissorWithCountEXT")
  ->args({"commandBuffer", "scissorCount", "pScissors"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetStencilOpEXT)>(*this, lib, "vkCmdSetStencilOpEXT", SideEffects::worstDefault, "WRAP_vkCmdSetStencilOpEXT")
  ->args({"commandBuffer", "faceMask", "failOp", "passOp", "depthFailOp", "compareOp"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetStencilTestEnableEXT)>(*this, lib, "vkCmdSetStencilTestEnableEXT", SideEffects::worstDefault, "WRAP_vkCmdSetStencilTestEnableEXT")
  ->args({"commandBuffer", "stencilTestEnable"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetViewportWithCountEXT)>(*this, lib, "vkCmdSetViewportWithCountEXT", SideEffects::worstDefault, "WRAP_vkCmdSetViewportWithCountEXT")
  ->args({"commandBuffer", "viewportCount", "pViewports"});
#endif /* (defined(VK_EXT_extended_dynamic_state)) || (defined(VK_EXT_shader_object)) */
#if (defined(VK_EXT_extended_dynamic_state2)) || (defined(VK_EXT_shader_object))
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetDepthBiasEnableEXT)>(*this, lib, "vkCmdSetDepthBiasEnableEXT", SideEffects::worstDefault, "WRAP_vkCmdSetDepthBiasEnableEXT")
  ->args({"commandBuffer", "depthBiasEnable"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetLogicOpEXT)>(*this, lib, "vkCmdSetLogicOpEXT", SideEffects::worstDefault, "WRAP_vkCmdSetLogicOpEXT")
  ->args({"commandBuffer", "logicOp"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetPatchControlPointsEXT)>(*this, lib, "vkCmdSetPatchControlPointsEXT", SideEffects::worstDefault, "WRAP_vkCmdSetPatchControlPointsEXT")
  ->args({"commandBuffer", "patchControlPoints"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetPrimitiveRestartEnableEXT)>(*this, lib, "vkCmdSetPrimitiveRestartEnableEXT", SideEffects::worstDefault, "WRAP_vkCmdSetPrimitiveRestartEnableEXT")
  ->args({"commandBuffer", "primitiveRestartEnable"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetRasterizerDiscardEnableEXT)>(*this, lib, "vkCmdSetRasterizerDiscardEnableEXT", SideEffects::worstDefault, "WRAP_vkCmdSetRasterizerDiscardEnableEXT")
  ->args({"commandBuffer", "rasterizerDiscardEnable"});
#endif /* (defined(VK_EXT_extended_dynamic_state2)) || (defined(VK_EXT_shader_object)) */
#if (defined(VK_EXT_extended_dynamic_state3)) || (defined(VK_EXT_shader_object))
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetAlphaToCoverageEnableEXT)>(*this, lib, "vkCmdSetAlphaToCoverageEnableEXT", SideEffects::worstDefault, "WRAP_vkCmdSetAlphaToCoverageEnableEXT")
  ->args({"commandBuffer", "alphaToCoverageEnable"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetAlphaToOneEnableEXT)>(*this, lib, "vkCmdSetAlphaToOneEnableEXT", SideEffects::worstDefault, "WRAP_vkCmdSetAlphaToOneEnableEXT")
  ->args({"commandBuffer", "alphaToOneEnable"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetColorBlendEnableEXT)>(*this, lib, "vkCmdSetColorBlendEnableEXT", SideEffects::worstDefault, "WRAP_vkCmdSetColorBlendEnableEXT")
  ->args({"commandBuffer", "firstAttachment", "attachmentCount", "pColorBlendEnables"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetColorBlendEquationEXT)>(*this, lib, "vkCmdSetColorBlendEquationEXT", SideEffects::worstDefault, "WRAP_vkCmdSetColorBlendEquationEXT")
  ->args({"commandBuffer", "firstAttachment", "attachmentCount", "pColorBlendEquations"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetColorWriteMaskEXT)>(*this, lib, "vkCmdSetColorWriteMaskEXT", SideEffects::worstDefault, "WRAP_vkCmdSetColorWriteMaskEXT")
  ->args({"commandBuffer", "firstAttachment", "attachmentCount", "pColorWriteMasks"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetDepthClampEnableEXT)>(*this, lib, "vkCmdSetDepthClampEnableEXT", SideEffects::worstDefault, "WRAP_vkCmdSetDepthClampEnableEXT")
  ->args({"commandBuffer", "depthClampEnable"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetLogicOpEnableEXT)>(*this, lib, "vkCmdSetLogicOpEnableEXT", SideEffects::worstDefault, "WRAP_vkCmdSetLogicOpEnableEXT")
  ->args({"commandBuffer", "logicOpEnable"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetPolygonModeEXT)>(*this, lib, "vkCmdSetPolygonModeEXT", SideEffects::worstDefault, "WRAP_vkCmdSetPolygonModeEXT")
  ->args({"commandBuffer", "polygonMode"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetRasterizationSamplesEXT)>(*this, lib, "vkCmdSetRasterizationSamplesEXT", SideEffects::worstDefault, "WRAP_vkCmdSetRasterizationSamplesEXT")
  ->args({"commandBuffer", "rasterizationSamples"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetSampleMaskEXT)>(*this, lib, "vkCmdSetSampleMaskEXT", SideEffects::worstDefault, "WRAP_vkCmdSetSampleMaskEXT")
  ->args({"commandBuffer", "samples", "pSampleMask"});
#endif /* (defined(VK_EXT_extended_dynamic_state3)) || (defined(VK_EXT_shader_object)) */
#if (defined(VK_EXT_extended_dynamic_state3) && (defined(VK_KHR_maintenance2) || defined(VK_VERSION_1_1))) || (defined(VK_EXT_shader_object))
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetTessellationDomainOriginEXT)>(*this, lib, "vkCmdSetTessellationDomainOriginEXT", SideEffects::worstDefault, "WRAP_vkCmdSetTessellationDomainOriginEXT")
  ->args({"commandBuffer", "domainOrigin"});
#endif /* (defined(VK_EXT_extended_dynamic_state3) && (defined(VK_KHR_maintenance2) || defined(VK_VERSION_1_1))) || (defined(VK_EXT_shader_object)) */
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_EXT_transform_feedback)) || (defined(VK_EXT_shader_object) && defined(VK_EXT_transform_feedback))
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetRasterizationStreamEXT)>(*this, lib, "vkCmdSetRasterizationStreamEXT", SideEffects::worstDefault, "WRAP_vkCmdSetRasterizationStreamEXT")
  ->args({"commandBuffer", "rasterizationStream"});
#endif /* (defined(VK_EXT_extended_dynamic_state3) && defined(VK_EXT_transform_feedback)) || (defined(VK_EXT_shader_object) && defined(VK_EXT_transform_feedback)) */
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_EXT_conservative_rasterization)) || (defined(VK_EXT_shader_object) && defined(VK_EXT_conservative_rasterization))
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetConservativeRasterizationModeEXT)>(*this, lib, "vkCmdSetConservativeRasterizationModeEXT", SideEffects::worstDefault, "WRAP_vkCmdSetConservativeRasterizationModeEXT")
  ->args({"commandBuffer", "conservativeRasterizationMode"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetExtraPrimitiveOverestimationSizeEXT)>(*this, lib, "vkCmdSetExtraPrimitiveOverestimationSizeEXT", SideEffects::worstDefault, "WRAP_vkCmdSetExtraPrimitiveOverestimationSizeEXT")
  ->args({"commandBuffer", "extraPrimitiveOverestimationSize"});
#endif /* (defined(VK_EXT_extended_dynamic_state3) && defined(VK_EXT_conservative_rasterization)) || (defined(VK_EXT_shader_object) && defined(VK_EXT_conservative_rasterization)) */
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_EXT_depth_clip_enable)) || (defined(VK_EXT_shader_object) && defined(VK_EXT_depth_clip_enable))
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetDepthClipEnableEXT)>(*this, lib, "vkCmdSetDepthClipEnableEXT", SideEffects::worstDefault, "WRAP_vkCmdSetDepthClipEnableEXT")
  ->args({"commandBuffer", "depthClipEnable"});
#endif /* (defined(VK_EXT_extended_dynamic_state3) && defined(VK_EXT_depth_clip_enable)) || (defined(VK_EXT_shader_object) && defined(VK_EXT_depth_clip_enable)) */
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_EXT_sample_locations)) || (defined(VK_EXT_shader_object) && defined(VK_EXT_sample_locations))
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetSampleLocationsEnableEXT)>(*this, lib, "vkCmdSetSampleLocationsEnableEXT", SideEffects::worstDefault, "WRAP_vkCmdSetSampleLocationsEnableEXT")
  ->args({"commandBuffer", "sampleLocationsEnable"});
#endif /* (defined(VK_EXT_extended_dynamic_state3) && defined(VK_EXT_sample_locations)) || (defined(VK_EXT_shader_object) && defined(VK_EXT_sample_locations)) */
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_EXT_blend_operation_advanced)) || (defined(VK_EXT_shader_object) && defined(VK_EXT_blend_operation_advanced))
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetColorBlendAdvancedEXT)>(*this, lib, "vkCmdSetColorBlendAdvancedEXT", SideEffects::worstDefault, "WRAP_vkCmdSetColorBlendAdvancedEXT")
  ->args({"commandBuffer", "firstAttachment", "attachmentCount", "pColorBlendAdvanced"});
#endif /* (defined(VK_EXT_extended_dynamic_state3) && defined(VK_EXT_blend_operation_advanced)) || (defined(VK_EXT_shader_object) && defined(VK_EXT_blend_operation_advanced)) */
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_EXT_provoking_vertex)) || (defined(VK_EXT_shader_object) && defined(VK_EXT_provoking_vertex))
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetProvokingVertexModeEXT)>(*this, lib, "vkCmdSetProvokingVertexModeEXT", SideEffects::worstDefault, "WRAP_vkCmdSetProvokingVertexModeEXT")
  ->args({"commandBuffer", "provokingVertexMode"});
#endif /* (defined(VK_EXT_extended_dynamic_state3) && defined(VK_EXT_provoking_vertex)) || (defined(VK_EXT_shader_object) && defined(VK_EXT_provoking_vertex)) */
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_EXT_line_rasterization)) || (defined(VK_EXT_shader_object) && defined(VK_EXT_line_rasterization))
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetLineRasterizationModeEXT)>(*this, lib, "vkCmdSetLineRasterizationModeEXT", SideEffects::worstDefault, "WRAP_vkCmdSetLineRasterizationModeEXT")
  ->args({"commandBuffer", "lineRasterizationMode"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetLineStippleEnableEXT)>(*this, lib, "vkCmdSetLineStippleEnableEXT", SideEffects::worstDefault, "WRAP_vkCmdSetLineStippleEnableEXT")
  ->args({"commandBuffer", "stippledLineEnable"});
#endif /* (defined(VK_EXT_extended_dynamic_state3) && defined(VK_EXT_line_rasterization)) || (defined(VK_EXT_shader_object) && defined(VK_EXT_line_rasterization)) */
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_EXT_depth_clip_control)) || (defined(VK_EXT_shader_object) && defined(VK_EXT_depth_clip_control))
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetDepthClipNegativeOneToOneEXT)>(*this, lib, "vkCmdSetDepthClipNegativeOneToOneEXT", SideEffects::worstDefault, "WRAP_vkCmdSetDepthClipNegativeOneToOneEXT")
  ->args({"commandBuffer", "negativeOneToOne"});
#endif /* (defined(VK_EXT_extended_dynamic_state3) && defined(VK_EXT_depth_clip_control)) || (defined(VK_EXT_shader_object) && defined(VK_EXT_depth_clip_control)) */
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_NV_clip_space_w_scaling)) || (defined(VK_EXT_shader_object) && defined(VK_NV_clip_space_w_scaling))
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetViewportWScalingEnableNV)>(*this, lib, "vkCmdSetViewportWScalingEnableNV", SideEffects::worstDefault, "WRAP_vkCmdSetViewportWScalingEnableNV")
  ->args({"commandBuffer", "viewportWScalingEnable"});
#endif /* (defined(VK_EXT_extended_dynamic_state3) && defined(VK_NV_clip_space_w_scaling)) || (defined(VK_EXT_shader_object) && defined(VK_NV_clip_space_w_scaling)) */
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_NV_viewport_swizzle)) || (defined(VK_EXT_shader_object) && defined(VK_NV_viewport_swizzle))
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetViewportSwizzleNV)>(*this, lib, "vkCmdSetViewportSwizzleNV", SideEffects::worstDefault, "WRAP_vkCmdSetViewportSwizzleNV")
  ->args({"commandBuffer", "firstViewport", "viewportCount", "pViewportSwizzles"});
#endif /* (defined(VK_EXT_extended_dynamic_state3) && defined(VK_NV_viewport_swizzle)) || (defined(VK_EXT_shader_object) && defined(VK_NV_viewport_swizzle)) */
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_NV_fragment_coverage_to_color)) || (defined(VK_EXT_shader_object) && defined(VK_NV_fragment_coverage_to_color))
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetCoverageToColorEnableNV)>(*this, lib, "vkCmdSetCoverageToColorEnableNV", SideEffects::worstDefault, "WRAP_vkCmdSetCoverageToColorEnableNV")
  ->args({"commandBuffer", "coverageToColorEnable"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetCoverageToColorLocationNV)>(*this, lib, "vkCmdSetCoverageToColorLocationNV", SideEffects::worstDefault, "WRAP_vkCmdSetCoverageToColorLocationNV")
  ->args({"commandBuffer", "coverageToColorLocation"});
#endif /* (defined(VK_EXT_extended_dynamic_state3) && defined(VK_NV_fragment_coverage_to_color)) || (defined(VK_EXT_shader_object) && defined(VK_NV_fragment_coverage_to_color)) */
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_NV_framebuffer_mixed_samples)) || (defined(VK_EXT_shader_object) && defined(VK_NV_framebuffer_mixed_samples))
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetCoverageModulationModeNV)>(*this, lib, "vkCmdSetCoverageModulationModeNV", SideEffects::worstDefault, "WRAP_vkCmdSetCoverageModulationModeNV")
  ->args({"commandBuffer", "coverageModulationMode"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetCoverageModulationTableEnableNV)>(*this, lib, "vkCmdSetCoverageModulationTableEnableNV", SideEffects::worstDefault, "WRAP_vkCmdSetCoverageModulationTableEnableNV")
  ->args({"commandBuffer", "coverageModulationTableEnable"});
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetCoverageModulationTableNV)>(*this, lib, "vkCmdSetCoverageModulationTableNV", SideEffects::worstDefault, "WRAP_vkCmdSetCoverageModulationTableNV")
  ->args({"commandBuffer", "coverageModulationTableCount", "pCoverageModulationTable"});
#endif /* (defined(VK_EXT_extended_dynamic_state3) && defined(VK_NV_framebuffer_mixed_samples)) || (defined(VK_EXT_shader_object) && defined(VK_NV_framebuffer_mixed_samples)) */
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_NV_shading_rate_image)) || (defined(VK_EXT_shader_object) && defined(VK_NV_shading_rate_image))
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetShadingRateImageEnableNV)>(*this, lib, "vkCmdSetShadingRateImageEnableNV", SideEffects::worstDefault, "WRAP_vkCmdSetShadingRateImageEnableNV")
  ->args({"commandBuffer", "shadingRateImageEnable"});
#endif /* (defined(VK_EXT_extended_dynamic_state3) && defined(VK_NV_shading_rate_image)) || (defined(VK_EXT_shader_object) && defined(VK_NV_shading_rate_image)) */
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_NV_representative_fragment_test)) || (defined(VK_EXT_shader_object) && defined(VK_NV_representative_fragment_test))
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetRepresentativeFragmentTestEnableNV)>(*this, lib, "vkCmdSetRepresentativeFragmentTestEnableNV", SideEffects::worstDefault, "WRAP_vkCmdSetRepresentativeFragmentTestEnableNV")
  ->args({"commandBuffer", "representativeFragmentTestEnable"});
#endif /* (defined(VK_EXT_extended_dynamic_state3) && defined(VK_NV_representative_fragment_test)) || (defined(VK_EXT_shader_object) && defined(VK_NV_representative_fragment_test)) */
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_NV_coverage_reduction_mode)) || (defined(VK_EXT_shader_object) && defined(VK_NV_coverage_reduction_mode))
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetCoverageReductionModeNV)>(*this, lib, "vkCmdSetCoverageReductionModeNV", SideEffects::worstDefault, "WRAP_vkCmdSetCoverageReductionModeNV")
  ->args({"commandBuffer", "coverageReductionMode"});
#endif /* (defined(VK_EXT_extended_dynamic_state3) && defined(VK_NV_coverage_reduction_mode)) || (defined(VK_EXT_shader_object) && defined(VK_NV_coverage_reduction_mode)) */
#if (defined(VK_EXT_host_image_copy)) || (defined(VK_EXT_image_compression_control))
addExtern<DAS_BIND_FUN(WRAP_vkGetImageSubresourceLayout2EXT)>(*this, lib, "vkGetImageSubresourceLayout2EXT", SideEffects::worstDefault, "WRAP_vkGetImageSubresourceLayout2EXT")
  ->args({"device", "image", "pSubresource", "pLayout"});
#endif /* (defined(VK_EXT_host_image_copy)) || (defined(VK_EXT_image_compression_control)) */
#if (defined(VK_EXT_shader_object)) || (defined(VK_EXT_vertex_input_dynamic_state))
addExtern<DAS_BIND_FUN(WRAP_vkCmdSetVertexInputEXT)>(*this, lib, "vkCmdSetVertexInputEXT", SideEffects::worstDefault, "WRAP_vkCmdSetVertexInputEXT")
  ->args({"commandBuffer", "vertexBindingDescriptionCount", "pVertexBindingDescriptions", "vertexAttributeDescriptionCount", "pVertexAttributeDescriptions"});
#endif /* (defined(VK_EXT_shader_object)) || (defined(VK_EXT_vertex_input_dynamic_state)) */
#if (defined(VK_KHR_descriptor_update_template) && defined(VK_KHR_push_descriptor)) || (defined(VK_KHR_push_descriptor) && (defined(VK_VERSION_1_1) || defined(VK_KHR_descriptor_update_template)))
addExtern<DAS_BIND_FUN(WRAP_vkCmdPushDescriptorSetWithTemplateKHR)>(*this, lib, "vkCmdPushDescriptorSetWithTemplateKHR", SideEffects::worstDefault, "WRAP_vkCmdPushDescriptorSetWithTemplateKHR")
  ->args({"commandBuffer", "descriptorUpdateTemplate", "layout", "set", "pData"});
#endif /* (defined(VK_KHR_descriptor_update_template) && defined(VK_KHR_push_descriptor)) || (defined(VK_KHR_push_descriptor) && (defined(VK_VERSION_1_1) || defined(VK_KHR_descriptor_update_template))) */
#if (defined(VK_KHR_device_group) && defined(VK_KHR_surface)) || (defined(VK_KHR_swapchain) && defined(VK_VERSION_1_1))
addExtern<DAS_BIND_FUN(WRAP_vkGetDeviceGroupPresentCapabilitiesKHR)>(*this, lib, "vkGetDeviceGroupPresentCapabilitiesKHR", SideEffects::worstDefault, "WRAP_vkGetDeviceGroupPresentCapabilitiesKHR")
  ->args({"device", "pDeviceGroupPresentCapabilities"});
addExtern<DAS_BIND_FUN(WRAP_vkGetDeviceGroupSurfacePresentModesKHR)>(*this, lib, "vkGetDeviceGroupSurfacePresentModesKHR", SideEffects::worstDefault, "WRAP_vkGetDeviceGroupSurfacePresentModesKHR")
  ->args({"device", "surface", "pModes"});
addExtern<DAS_BIND_FUN(WRAP_vkGetPhysicalDevicePresentRectanglesKHR)>(*this, lib, "vkGetPhysicalDevicePresentRectanglesKHR", SideEffects::worstDefault, "WRAP_vkGetPhysicalDevicePresentRectanglesKHR")
  ->args({"physicalDevice", "surface", "pRectCount", "pRects"});
#endif /* (defined(VK_KHR_device_group) && defined(VK_KHR_surface)) || (defined(VK_KHR_swapchain) && defined(VK_VERSION_1_1)) */
#if (defined(VK_KHR_device_group) && defined(VK_KHR_swapchain)) || (defined(VK_KHR_swapchain) && defined(VK_VERSION_1_1))
addExtern<DAS_BIND_FUN(WRAP_vkAcquireNextImage2KHR)>(*this, lib, "vkAcquireNextImage2KHR", SideEffects::worstDefault, "WRAP_vkAcquireNextImage2KHR")
  ->args({"device", "pAcquireInfo", "pImageIndex"});
#endif /* (defined(VK_KHR_device_group) && defined(VK_KHR_swapchain)) || (defined(VK_KHR_swapchain) && defined(VK_VERSION_1_1)) */
  /* VOLK_GENERATE_BIND_FUNC */
}

}
